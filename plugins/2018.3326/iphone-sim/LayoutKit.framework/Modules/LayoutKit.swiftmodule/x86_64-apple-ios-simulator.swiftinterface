// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name LayoutKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import AVKit
import CoreGraphics
import CoreMedia
import CoreText
import Foundation
@_exported import LayoutKit
@_exported import LayoutKitInterface
import QuartzCore
import Swift
import UIKit
import VGSL
import VGSLFundamentals
import VGSLUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol AccessibilityContaining {
  var accessibilityElement: VGSLUI.AccessibilityElement? { get }
}
extension LayoutKit.AccessibilityContaining {
  public var accessibilityElement: VGSLUI.AccessibilityElement? {
    get
  }
}
public struct ActionAnimation : Swift.Equatable {
  public let touchDown: [LayoutKit.TransitioningAnimation]
  public let touchUp: [LayoutKit.TransitioningAnimation]
  public static let empty: LayoutKit.ActionAnimation
  public init(touchDown: [LayoutKit.TransitioningAnimation], touchUp: [LayoutKit.TransitioningAnimation])
  public static func == (a: LayoutKit.ActionAnimation, b: LayoutKit.ActionAnimation) -> Swift.Bool
}
public struct ActionLimiter {
  public init(canSend: @escaping () -> Swift.Bool, markSent: @escaping VGSLFundamentals.Action)
}
public protocol AnalyticsTouchEventHandling {
  func handle(touchEvent: LayoutKit.AnalyticsTouchEvent, from sender: Swift.AnyObject)
}
final public class AnalyticsTouchEvent : LayoutKit.AppActionEventProtocol {
  public enum TouchType {
    case click
    case longPress
    public static func == (a: LayoutKit.AnalyticsTouchEvent.TouchType, b: LayoutKit.AnalyticsTouchEvent.TouchType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let touchType: LayoutKit.AnalyticsTouchEvent.TouchType
  final public let path: LayoutKitInterface.UIElementPath
  public init(touchType: LayoutKit.AnalyticsTouchEvent.TouchType, path: LayoutKitInterface.UIElementPath)
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.AnalyticsTouchEvent.Handler?
  @objc deinit
}
public protocol AnalyticsUrlEventHandling {
  func handle(analyticsUrlEvent: LayoutKit.AnalyticsUrlEvent, from sender: Swift.AnyObject)
}
final public class AnalyticsUrlEvent : LayoutKit.AppActionEventProtocol {
  final public let analyticsUrl: Foundation.URL
  public init(analyticsUrl: Foundation.URL)
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.AnalyticsUrlEvent.Handler?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AnchorBlock : LayoutKit.BlockWithTraits {
  public struct Layout : Swift.Equatable {
    public static func == (a: LayoutKit.AnchorBlock.Layout, b: LayoutKit.AnchorBlock.Layout) -> Swift.Bool
  }
  final public let direction: LayoutKit.ContainerBlock.LayoutDirection
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let crossAlignment: VGSLUI.Alignment
  final public let leading: (any LayoutKit.Block)?
  final public let center: any LayoutKit.Block
  final public let trailing: (any LayoutKit.Block)?
  convenience public init(direction: LayoutKit.ContainerBlock.LayoutDirection = .horizontal, axialWeight: LayoutKit.LayoutTrait.Weight = .default, crossTrait: LayoutKit.LayoutTrait = .intrinsic, crossAlignment: VGSLUI.Alignment = .center, leading: (any LayoutKit.Block)? = nil, center: any LayoutKit.Block, trailing: (any LayoutKit.Block)? = nil)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func laidOutHierarchy(for size: CoreFoundation.CGSize) -> (LayoutKit.AnchorBlock, LayoutKit.AnchorBlock.Layout)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public var debugDescription: Swift.String {
    get
  }
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> Self
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> Self
  @objc deinit
}
extension LayoutKit.AnchorBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, with layout: LayoutKit.AnchorBlock.Layout?, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public struct AnchorPoint : Swift.Equatable {
  public init(x: LayoutKit.AnchorValue, y: LayoutKit.AnchorValue)
  public func calculateCGPoint(for rect: CoreFoundation.CGRect) -> CoreFoundation.CGPoint
  public static func == (a: LayoutKit.AnchorPoint, b: LayoutKit.AnchorPoint) -> Swift.Bool
}
public enum AnchorValue : Swift.Equatable {
  case relative(value: CoreFoundation.CGFloat)
  case absolute(value: CoreFoundation.CGFloat)
  public func value(for length: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public static func == (a: LayoutKit.AnchorValue, b: LayoutKit.AnchorValue) -> Swift.Bool
}
final public class AnimatableImageBlock : LayoutKit.ImageBaseBlock {
  final public let imageHolder: any VGSLUI.ImageHolder
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let height: LayoutKit.ImageBlockHeight
  final public let contentMode: VGSLUI.ImageContentMode
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  final public let path: LayoutKitInterface.UIElementPath?
  final public let state: LayoutKit.ImageBaseBlockState
  public init(imageHolder: any VGSLUI.ImageHolder, widthTrait: LayoutKit.LayoutTrait, height: LayoutKit.ImageBlockHeight, contentMode: VGSLUI.ImageContentMode = .default, accessibilityElement: VGSLUI.AccessibilityElement? = nil, path: LayoutKitInterface.UIElementPath? = nil)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
public func == (lhs: LayoutKit.AnimatableImageBlock, rhs: LayoutKit.AnimatableImageBlock) -> Swift.Bool
extension LayoutKit.AnimatableImageBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.AnimatableImageBlock {
  final public func makeCopy() -> LayoutKit.AnimatableImageBlock
}
extension LayoutKit.AnimatableImageBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class AnimatingGradientView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public var isAnimationActive: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init(color: VGSLUI.Color = Color(white: 1, alpha: 0.8))
  @objc deinit
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override final public func willMove(toWindow newWindow: UIKit.UIWindow?)
  @_Concurrency.MainActor @preconcurrency final public func startAnimating()
  @_Concurrency.MainActor @preconcurrency final public func stopAnimating()
}
public protocol AppActionEventProtocol {
  typealias Handler = (Self, Swift.AnyObject) -> Swift.Void
  func makeHandler(responder: UIKit.UIResponder) -> Self.Handler?
}
extension LayoutKit.AppActionEventProtocol {
  public func sendFrom(_ sender: UIKit.UIResponder)
}
final public class AspectBlock<Content> : LayoutKit.WrapperBlock where Content : LayoutKit.Block {
  final public let content: Content
  final public let aspectRatio: CoreFoundation.CGFloat
  final public var child: any LayoutKit.Block {
    get
  }
  public init(content: Content, aspectRatio: CoreFoundation.CGFloat)
  final public var isVerticallyResizable: Swift.Bool {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func makeCopy(wrapping: any LayoutKit.Block) -> Self
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public var debugDescription: Swift.String {
    get
  }
  final public func laidOut(for width: CoreFoundation.CGFloat) -> any LayoutKit.Block
  final public func laidOut(for size: CoreFoundation.CGSize) -> any LayoutKit.Block
  @objc deinit
}
extension LayoutKit.Block {
  public func aspectRatio(_ ratio: CoreFoundation.CGFloat) -> any LayoutKit.Block
}
extension LayoutKit.AspectBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public enum Background : Swift.Equatable {
  case solidColor(VGSLUI.Color)
  case tiledImage(VGSLUI.Image)
  case image(LayoutKit.BackgroundImage)
  case gradient(VGSLUI.Gradient)
  case transparentAction(LayoutKitInterface.UserInterfaceAction)
  case ninePatchImage(LayoutKit.NinePatchImage)
  case block(any LayoutKit.Block)
  indirect case composite(LayoutKit.Background, LayoutKit.Background, Swift.Float?)
  indirect case withInsets(background: LayoutKit.Background, contentInsets: LayoutKit.EdgeInsets)
  public init(backgrounds: LayoutKit.Background...)
}
public func + (lhs: LayoutKit.Background, rhs: LayoutKit.Background) -> LayoutKit.Background
public func += (lhs: inout LayoutKit.Background, rhs: LayoutKit.Background)
public func == (lhs: LayoutKit.Background, rhs: LayoutKit.Background) -> Swift.Bool
extension LayoutKit.Background : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.Background : VGSLUI.ImageContaining {
  public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension Swift.Array where Element == LayoutKit.Background {
  public func composite() -> Element?
}
extension LayoutKit.Background : LayoutKit.UIViewRenderable {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
final public class BackgroundBlock : LayoutKit.WrapperBlock {
  final public let background: LayoutKit.Background
  final public let child: any LayoutKit.Block
  final public let cornerRadius: CoreFoundation.CGFloat
  public init(background: LayoutKit.Background, child: any LayoutKit.Block, cornerRadius: CoreFoundation.CGFloat = 0.0)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> LayoutKit.BackgroundBlock
  public static func == (lhs: LayoutKit.BackgroundBlock, rhs: LayoutKit.BackgroundBlock) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.BackgroundBlock {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.Block {
  public func with(background: LayoutKit.Background) -> LayoutKit.BackgroundBlock
}
extension LayoutKit.BackgroundBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public struct BackgroundImage {
  public init(imageHolder: any VGSLUI.ImageHolder, contentMode: VGSLUI.ImageContentMode = .default, alpha: Swift.Double = 1.0, effects: [VGSLUI.ImageEffect] = [])
}
extension LayoutKit.BackgroundImage : Swift.Equatable {
  public static func == (lhs: LayoutKit.BackgroundImage, rhs: LayoutKit.BackgroundImage) -> Swift.Bool
}
extension LayoutKit.BackgroundImage : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Binding<T> : Swift.Equatable where T : Swift.Equatable {
  @VGSLFundamentals.Property @_projectedValueProperty($value) public var value: T {
    get
    nonmutating set
    nonmutating _modify
  }
  public var $value: VGSLFundamentals.Variable<T> {
    get
  }
  public init(name: Swift.String, value: VGSLFundamentals.Property<T>)
  public static func == (lhs: LayoutKit.Binding<T>, rhs: LayoutKit.Binding<T>) -> Swift.Bool
}
extension LayoutKit.Binding where T : Swift.AdditiveArithmetic {
  public static var zero: LayoutKit.Binding<T> {
    get
  }
}
extension LayoutKit.Binding where T == Swift.String {
  public static var zero: LayoutKit.Binding<Swift.String> {
    get
  }
}
public typealias BlockRenderingImpl = LayoutKit.UIViewRenderable
public protocol Block : AnyObject, LayoutKit.AccessibilityContaining, LayoutKit.ElementFocusUpdating, LayoutKit.ElementStateUpdating, LayoutKit.LayoutCaching, LayoutKit.UIViewRenderable, Swift.CustomDebugStringConvertible, VGSLUI.ImageContaining {
  var isVerticallyResizable: Swift.Bool { get }
  var isHorizontallyResizable: Swift.Bool { get }
  var isVerticallyConstrained: Swift.Bool { get }
  var isHorizontallyConstrained: Swift.Bool { get }
  var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat { get }
  var heightOfVerticallyNonResizableBlock: CoreFoundation.CGFloat { get }
  func widthOfHorizontallyNonResizableBlock(forHeight: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  func heightOfVerticallyNonResizableBlock(forWidth: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  var calculateWidthFirst: Swift.Bool { get }
  var intrinsicContentWidth: CoreFoundation.CGFloat { get }
  func intrinsicContentHeight(forWidth: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  func ascent(forWidth: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight { get }
  var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight { get }
  var minWidth: CoreFoundation.CGFloat { get }
  var minHeight: CoreFoundation.CGFloat { get }
  func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  var blockLayoutDirection: VGSLUI.UserInterfaceLayoutDirection { get }
  var reuseId: Swift.String { get }
  var isEmpty: Swift.Bool { get }
}
extension LayoutKit.Block {
  public var blockLayoutDirection: VGSLUI.UserInterfaceLayoutDirection {
    get
  }
  public var calculateWidthFirst: Swift.Bool {
    get
  }
  public func widthOfHorizontallyNonResizableBlock(forHeight _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public var heightOfVerticallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  public func sizeFor(widthOfHorizontallyResizableBlock: CoreFoundation.CGFloat, heightOfVerticallyResizableBlock: CoreFoundation.CGFloat, constrainedWidth: CoreFoundation.CGFloat, constrainedHeight: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func size(forResizableBlockSize resizableBlockSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public var intrinsicSize: CoreFoundation.CGSize {
    get
  }
  public var calculatedWidthTrait: LayoutKit.LayoutTrait {
    get
  }
  public var calculatedHeightTrait: LayoutKit.LayoutTrait {
    get
  }
  public func ascent(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  public var minWidth: CoreFoundation.CGFloat {
    get
  }
  public var minHeight: CoreFoundation.CGFloat {
    get
  }
  public var reuseId: Swift.String {
    get
  }
  public static var defaultReuseId: Swift.String {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
}
public func == (lhs: any LayoutKit.Block, rhs: any LayoutKit.Block) -> Swift.Bool
public func == (lhs: (any LayoutKit.Block)?, rhs: (any LayoutKit.Block)?) -> Swift.Bool
public func != (lhs: any LayoutKit.Block, rhs: any LayoutKit.Block) -> Swift.Bool
public func != (lhs: (any LayoutKit.Block)?, rhs: (any LayoutKit.Block)?) -> Swift.Bool
public func == (lhs: [any LayoutKit.Block], rhs: [any LayoutKit.Block]) -> Swift.Bool
public func != (lhs: [any LayoutKit.Block], rhs: [any LayoutKit.Block]) -> Swift.Bool
public func === (lhs: [any LayoutKit.Block], rhs: [any LayoutKit.Block]) -> Swift.Bool
public func !== (lhs: [any LayoutKit.Block], rhs: [any LayoutKit.Block]) -> Swift.Bool
extension Swift.Sequence where Self.Element == any LayoutKit.Block {
  public var hasVerticallyNonResizable: Swift.Bool {
    get
  }
  public var hasHorizontallyNonResizable: Swift.Bool {
    get
  }
  public var hasVerticallyResizable: Swift.Bool {
    get
  }
  public var hasHorizontallyResizable: Swift.Bool {
    get
  }
  public var allVerticallyResizable: Swift.Bool {
    get
  }
  public var allHorizontallyResizable: Swift.Bool {
    get
  }
  public var allVerticallyNonResizable: Swift.Bool {
    get
  }
  public var allHorizontallyNonResizable: Swift.Bool {
    get
  }
  public func maxHeightOfVerticallyNonResizableBlocks(for widths: [CoreFoundation.CGFloat]) -> CoreFoundation.CGFloat?
}
extension LayoutKit.Block {
  public func addingAccessibilityID(_ id: @autoclosure () -> Swift.String?) -> any LayoutKit.Block
  public func addingAccessibilityID<T>(_ id: @autoclosure () -> T?) -> any LayoutKit.Block where T : Swift.RawRepresentable, T.RawValue == Swift.String
  public func addingAccessibilityID(withTraits id: @autoclosure () -> (id: Swift.String?, VGSLUI.AccessibilityElement.Traits)?) -> any LayoutKit.Block
  public func addingAccessibilityID<T>(withTraits id: @autoclosure () -> (id: T?, VGSLUI.AccessibilityElement.Traits)?) -> any LayoutKit.Block where T : Swift.RawRepresentable, T.RawValue == Swift.String
}
public enum AnimationChanges : Swift.Equatable {
  case transform([QuartzCore.CATransform3D])
  case opacity([Swift.Float])
  public static func == (a: LayoutKit.AnimationChanges, b: LayoutKit.AnimationChanges) -> Swift.Bool
}
extension QuartzCore.CATransform3D : Swift.Equatable {
}
public func == (lhs: QuartzCore.CATransform3D, rhs: QuartzCore.CATransform3D) -> Swift.Bool
public struct BlockAnimation : Swift.Equatable {
  public let changes: LayoutKit.AnimationChanges
  public let keyTimes: [LayoutKit.BlockAnimation.KeyTime]
  public let duration: Foundation.TimeInterval
  public let timingFunction: LayoutKit.TimingFunction
  public init(changes: LayoutKit.AnimationChanges, keyTimes: [LayoutKit.BlockAnimation.KeyTime], duration: Foundation.TimeInterval, timingFunction: LayoutKit.TimingFunction = .linear)
  public struct KeyTime : Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.Equatable {
    public let value: Swift.Double
    public init(_ value: Swift.Double)
    public init(floatLiteral value: Swift.Double)
    public init(integerLiteral value: Swift.IntegerLiteralType)
    public static func == (a: LayoutKit.BlockAnimation.KeyTime, b: LayoutKit.BlockAnimation.KeyTime) -> Swift.Bool
    public typealias FloatLiteralType = Swift.Double
    public typealias IntegerLiteralType = Swift.IntegerLiteralType
  }
  public static func == (a: LayoutKit.BlockAnimation, b: LayoutKit.BlockAnimation) -> Swift.Bool
}
extension LayoutKit.BlockAnimation {
  public static func makeLoopedRotation(duration: Foundation.TimeInterval) -> LayoutKit.BlockAnimation
  public static var spinner: LayoutKit.BlockAnimation {
    get
  }
}
extension LayoutKit.BlockAnimation {
  public var keyFrameAnimation: QuartzCore.CAKeyframeAnimation {
    get
  }
}
extension LayoutKit.AnimationChanges {
  public var keyPath: Swift.String {
    get
  }
}
extension LayoutKit.AnimationChanges {
  public var values: [Foundation.NSValue] {
    get
  }
}
extension LayoutKit.ContainerBlock.LayoutDirection : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BlockAlignment2D : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.TextBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.ImageBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.AnimatableImageBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.SeparatorBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.SwipeContainerBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.ContainerBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.ShadedBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.SwitchBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.PageControlBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.SwitchableContainerBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.LayoutTrait : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.AnimationChanges : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BlockAnimation : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BlockShadow : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GalleryViewModel.Item : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GalleryBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.PagerBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BackgroundBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BlockBorder : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.TabsBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.LayeredBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GridBlock.Span : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GridBlock.Item : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GridBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.TransitioningBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.BlockTooltip : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.MaskedBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.EmptyBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.Block {
  public var wrappingWidthTrait: LayoutKit.LayoutTrait {
    get
  }
  public var wrappingHeightTrait: LayoutKit.LayoutTrait {
    get
  }
  public func addingDecorations(action: LayoutKitInterface.UserInterfaceAction?) -> any LayoutKit.Block
  public func addingDecorations(boundary: LayoutKit.BoundaryTrait? = nil, border: LayoutKit.BlockBorder? = nil, backgroundColor: VGSLUI.Color? = nil, highlightedBackgroundColor: VGSLUI.Color?? = nil, alpha: CoreFoundation.CGFloat? = nil, blurEffect: LayoutKit.BlurEffect? = nil, actions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, actionAnimation: LayoutKit.ActionAnimation? = nil, doubleTapActions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, longTapActions: LayoutKit.LongTapActions? = nil, pressStartActions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, pressEndActions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, hoverStartActions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, hoverEndActions: VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>? = nil, analyticsURL: Foundation.URL? = nil, shadow: LayoutKit.BlockShadow? = nil, visibilityParams: LayoutKit.VisibilityParams? = nil, tooltips: [LayoutKit.BlockTooltip]? = nil, forceWrapping: Swift.Bool = false, accessibilityElement: VGSLUI.AccessibilityElement? = nil, reuseId: Swift.String? = nil, path: LayoutKitInterface.UIElementPath? = nil, isEmpty: Swift.Bool? = nil, isFocused: Swift.Bool? = nil, captureFocusOnAction: Swift.Bool? = nil) -> any LayoutKit.Block
  public func addingHorizontalGaps(left: CoreFoundation.CGFloat, right: CoreFoundation.CGFloat, clipsToBounds: Swift.Bool? = nil, forceWrapping: Swift.Bool = false) -> any LayoutKit.Block
  public func addingHorizontalGaps(_ value: CoreFoundation.CGFloat) -> any LayoutKit.Block
  public func withHorizontalInsets(_ insets: VGSLUI.SideInsets) -> any LayoutKit.Block
  public func addingVerticalGaps(top: CoreFoundation.CGFloat, bottom: CoreFoundation.CGFloat, clipsToBounds: Swift.Bool? = nil, forceWrapping: Swift.Bool = false) -> any LayoutKit.Block
  public func addingVerticalGaps(_ value: CoreFoundation.CGFloat) -> any LayoutKit.Block
  public func addingEdgeInsets(_ insets: LayoutKit.EdgeInsets, clipsToBounds: Swift.Bool? = nil, forceWrapping: Swift.Bool = false) -> any LayoutKit.Block
  public func addingTransform(transform: CoreFoundation.CGAffineTransform, anchorPoint: LayoutKit.AnchorPoint) -> any LayoutKit.Block
  public func addingEdgeGaps(_ value: CoreFoundation.CGFloat) -> any LayoutKit.Block
  public func rotated(by angle: CoreFoundation.CGFloat) -> any LayoutKit.Block
}
public struct BlockAlignment2D : Swift.Equatable {
  public let horizontal: VGSLUI.Alignment
  public let vertical: VGSLUI.Alignment
  public static let `default`: LayoutKit.BlockAlignment2D
  public static let topLeft: LayoutKit.BlockAlignment2D
  public static let topCenter: LayoutKit.BlockAlignment2D
  public static let topRight: LayoutKit.BlockAlignment2D
  public static let centerLeft: LayoutKit.BlockAlignment2D
  public static let center: LayoutKit.BlockAlignment2D
  public static let centerRight: LayoutKit.BlockAlignment2D
  public static let bottomLeft: LayoutKit.BlockAlignment2D
  public static let bottomCenter: LayoutKit.BlockAlignment2D
  public static let bottomRight: LayoutKit.BlockAlignment2D
  public init(horizontal: VGSLUI.Alignment = .leading, vertical: VGSLUI.Alignment = .leading)
  public static func == (a: LayoutKit.BlockAlignment2D, b: LayoutKit.BlockAlignment2D) -> Swift.Bool
}
public struct BlockBorder : Swift.Equatable {
  public enum Style {
    case solid
    case dashed
    public static let `default`: LayoutKit.BlockBorder.Style
    public static func == (a: LayoutKit.BlockBorder.Style, b: LayoutKit.BlockBorder.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let style: LayoutKit.BlockBorder.Style
  public let color: VGSLUI.Color
  public let width: CoreFoundation.CGFloat
  public init(style: LayoutKit.BlockBorder.Style = .default, color: VGSLUI.Color, width: CoreFoundation.CGFloat = 1)
  public static func == (a: LayoutKit.BlockBorder, b: LayoutKit.BlockBorder) -> Swift.Bool
}
public struct BlockError : Swift.Error {
  public let message: Swift.String
}
@inlinable public func modifyError<R>(_ modificator: (LayoutKit.BlockError) -> some Error, _ block: () throws -> R) throws -> R {
  do {
    return try block()
  } catch let e as BlockError {
    throw modificator(e)
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class BlockHostingView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public var block: (any LayoutKit.UIViewRenderable)! {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct BlockShadow : Swift.Equatable {
  public enum Defaults {
    public static let blurRadius: CoreFoundation.CGFloat
    public static let offset: CoreFoundation.CGPoint
    public static let opacity: Swift.Float
    public static let color: VGSLUI.Color
  }
  public static let maxBlurRadius: CoreFoundation.CGFloat
  public static let maxOffset: CoreFoundation.CGFloat
  public let cornerRadii: LayoutKit.CornerRadii
  public let offset: CoreFoundation.CGPoint
  public let opacity: Swift.Float
  public let color: VGSLUI.Color
  public var blurRadius: CoreFoundation.CGFloat {
    get
  }
  public init(cornerRadii: LayoutKit.CornerRadii, blurRadius: CoreFoundation.CGFloat = Defaults.blurRadius, offset: CoreFoundation.CGPoint = Defaults.offset, opacity: Swift.Float = Defaults.opacity, color: VGSLUI.Color = Defaults.color)
  public static func == (lhs: LayoutKit.BlockShadow, rhs: LayoutKit.BlockShadow) -> Swift.Bool
}
extension LayoutKit.BlockShadow {
  public init(cornerRadius: CoreFoundation.CGFloat, blurRadius: CoreFoundation.CGFloat = Defaults.blurRadius, offset: CoreFoundation.CGPoint = Defaults.offset, opacity: Swift.Float = Defaults.opacity, color: VGSLUI.Color = Defaults.color)
}
public struct PagerPath : Swift.Equatable {
  public let cardId: Swift.String
  public let pagerId: Swift.String
  public init(cardId: Swift.String, pagerId: Swift.String)
  public static func == (a: LayoutKit.PagerPath, b: LayoutKit.PagerPath) -> Swift.Bool
}
public typealias TooltipViewFactory = () async -> (any UIKit.UIView & VGSLUI.VisibleBoundsTracking)?
public struct BlockTooltip : Swift.Equatable {
  public enum Position : Swift.String, Swift.CaseIterable {
    case left
    case topLeft
    case top
    case topRight
    case right
    case bottomRight
    case bottom
    case bottomLeft
    case center
    public init?(rawValue: Swift.String)
    public typealias AllCases = [LayoutKit.BlockTooltip.Position]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [LayoutKit.BlockTooltip.Position] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Mode : Swift.Equatable {
    case modal
    case nonModal
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LayoutKit.BlockTooltip.Mode, b: LayoutKit.BlockTooltip.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let params: LayoutKit.BlockTooltipParams
  public let block: any LayoutKit.Block
  public let offset: CoreFoundation.CGPoint
  public let position: LayoutKit.BlockTooltip.Position
  public let useLegacyWidth: Swift.Bool
  public let tooltipViewFactory: LayoutKit.TooltipViewFactory?
  public init(block: any LayoutKit.Block, params: LayoutKit.BlockTooltipParams, offset: CoreFoundation.CGPoint, position: LayoutKit.BlockTooltip.Position, useLegacyWidth: Swift.Bool = true, tooltipViewFactory: LayoutKit.TooltipViewFactory? = nil)
  public var id: Swift.String {
    get
  }
  public static func == (lhs: LayoutKit.BlockTooltip, rhs: LayoutKit.BlockTooltip) -> Swift.Bool
}
extension LayoutKit.BlockTooltip {
  public func calculateFrame(targeting targetRect: CoreFoundation.CGRect, constrainedBy bounds: CoreFoundation.CGRect, useLegacyWidth: Swift.Bool = true) -> CoreFoundation.CGRect
}
public struct BlockTooltipParams : Swift.Equatable {
  public let id: Swift.String
  public let mode: LayoutKit.BlockTooltip.Mode
  public let duration: Foundation.TimeInterval
  public let closeByTapOutside: Swift.Bool
  public let backgroundAccessibilityDescription: Swift.String?
  public let animationIn: [LayoutKit.TransitioningAnimation]?
  public let animationOut: [LayoutKit.TransitioningAnimation]?
  public init(id: Swift.String, mode: LayoutKit.BlockTooltip.Mode, duration: Foundation.TimeInterval, closeByTapOutside: Swift.Bool, tapOutsideActions: [LayoutKitInterface.UserInterfaceAction] = [], backgroundAccessibilityDescription: Swift.String? = nil, animationIn: [LayoutKit.TransitioningAnimation]? = nil, animationOut: [LayoutKit.TransitioningAnimation]? = nil)
  public static func == (a: LayoutKit.BlockTooltipParams, b: LayoutKit.BlockTooltipParams) -> Swift.Bool
}
public typealias BlockView = UIKit.UIView & LayoutKit.BlockViewProtocol
public protocol BlockViewProtocol : AnyObject, LayoutKit.EffectiveBackgroundColorProviding, LayoutKit.LayoutReporterProvider, VGSLUI.VisibleBoundsTracking {
}
public protocol BlockWithTraits : LayoutKit.BlockWithHeightTrait, LayoutKit.BlockWithWidthTrait {
}
public protocol BlockWithWidthTrait : LayoutKit.Block {
  var widthTrait: LayoutKit.LayoutTrait { get }
}
public protocol BlockWithHeightTrait : LayoutKit.Block {
  var heightTrait: LayoutKit.LayoutTrait { get }
}
extension LayoutKit.BlockWithWidthTrait {
  public var isHorizontallyResizable: Swift.Bool {
    get
  }
  public var isHorizontallyConstrained: Swift.Bool {
    get
  }
  public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  public var minWidth: CoreFoundation.CGFloat {
    get
  }
}
extension LayoutKit.BlockWithHeightTrait {
  public var isVerticallyResizable: Swift.Bool {
    get
  }
  public var isVerticallyConstrained: Swift.Bool {
    get
  }
  public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  public var minHeight: CoreFoundation.CGFloat {
    get
  }
}
public enum BlurEffect {
  case light
  case dark
  public static func == (a: LayoutKit.BlurEffect, b: LayoutKit.BlurEffect) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum BoundaryTrait : Swift.Equatable {
  case noClip
  case clipCorner(LayoutKit.CornerRadii)
  case clipPath(CoreGraphics.CGPath)
  public static let clips: LayoutKit.BoundaryTrait
  public static func clipCorner(radius: CoreFoundation.CGFloat, corners: CoreFoundation.CGRect.Corners = .all) -> LayoutKit.BoundaryTrait
  public static func cornerRadius(_ radius: CoreFoundation.CGFloat, corners: CoreFoundation.CGRect.Corners = .all) -> LayoutKit.BoundaryTrait
  public static func path(_ path: CoreGraphics.CGPath) -> LayoutKit.BoundaryTrait
  public static func == (a: LayoutKit.BoundaryTrait, b: LayoutKit.BoundaryTrait) -> Swift.Bool
}
@objc @_Concurrency.MainActor @preconcurrency final public class BoxShadowView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public var shadowColor: VGSLUI.Color {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(shadowColor: VGSLUI.Color)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @objc deinit
}
final public class ClosureIntrinsicCalculator : LayoutKit.IntrinsicCalculator {
  public init(widthGetter: @escaping () -> CoreFoundation.CGFloat, heightGetter: @escaping (_ width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat)
  final public func calculateWidth() -> CoreFoundation.CGFloat
  final public func calculateHeight(width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  @objc deinit
}
extension CoreMedia.CMTime {
  public init(value: Swift.Int)
}
extension LayoutKitInterface.CommonHandler {
  public func perform(sendingFrom sender: UIKit.UIResponder)
}
@objc @_Concurrency.MainActor @preconcurrency final public class CompositeView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public static let defaultBlendingCoefficient: Swift.Float
  @_Concurrency.MainActor @preconcurrency final public let backView: any UIKit.UIView & LayoutKit.BlockViewProtocol
  @_Concurrency.MainActor @preconcurrency final public let frontView: any UIKit.UIView & LayoutKit.BlockViewProtocol
  @_Concurrency.MainActor @preconcurrency final public var blendingCoefficient: Swift.Float? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(backView: any UIKit.UIView & LayoutKit.BlockViewProtocol, frontView: any UIKit.UIView & LayoutKit.BlockViewProtocol)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @objc deinit
}
final public class ContainerBlock {
  public static let defaultAnchorPoint: LayoutKit.AnchorPoint
  @frozen public enum LayoutDirection : Swift.CaseIterable {
    case horizontal
    case vertical
    public static func == (a: LayoutKit.ContainerBlock.LayoutDirection, b: LayoutKit.ContainerBlock.LayoutDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [LayoutKit.ContainerBlock.LayoutDirection]
    nonisolated public static var allCases: [LayoutKit.ContainerBlock.LayoutDirection] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LayoutMode {
    case wrap
    case noWrap
    public static func == (a: LayoutKit.ContainerBlock.LayoutMode, b: LayoutKit.ContainerBlock.LayoutMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Child : Swift.Equatable {
    public var content: any LayoutKit.Block
    public let crossAlignment: LayoutKit.ContainerBlock.CrossAlignment
    public init(content: any LayoutKit.Block, crossAlignment: LayoutKit.ContainerBlock.CrossAlignment = .leading)
  }
  public enum CrossAlignment {
    case leading
    case center
    case trailing
    case baseline
    public static func == (a: LayoutKit.ContainerBlock.CrossAlignment, b: LayoutKit.ContainerBlock.CrossAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AxialAlignment {
    case leading
    case center
    case trailing
    case spaceBetween
    case spaceAround
    case spaceEvenly
    public static func == (a: LayoutKit.ContainerBlock.AxialAlignment, b: LayoutKit.ContainerBlock.AxialAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Separator : Swift.Equatable {
    public let style: LayoutKit.ContainerBlock.Child
    public let showAtEnd: Swift.Bool
    public let showAtStart: Swift.Bool
    public let showBetween: Swift.Bool
    public init(style: LayoutKit.ContainerBlock.Child, showAtEnd: Swift.Bool = false, showAtStart: Swift.Bool = false, showBetween: Swift.Bool = false)
    public static func == (a: LayoutKit.ContainerBlock.Separator, b: LayoutKit.ContainerBlock.Separator) -> Swift.Bool
  }
  final public let blockLayoutDirection: VGSLUI.UserInterfaceLayoutDirection
  final public let layoutDirection: LayoutKit.ContainerBlock.LayoutDirection
  final public let layoutMode: LayoutKit.ContainerBlock.LayoutMode
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let axialAlignment: LayoutKit.ContainerBlock.AxialAlignment
  final public let crossAlignment: LayoutKit.ContainerBlock.CrossAlignment
  final public let gaps: [CoreFoundation.CGFloat]
  final public let children: [LayoutKit.ContainerBlock.Child]
  final public let separator: LayoutKit.ContainerBlock.Separator?
  final public let lineSeparator: LayoutKit.ContainerBlock.Separator?
  final public let contentAnimation: LayoutKit.BlockAnimation?
  final public let anchorPoint: LayoutKit.AnchorPoint
  final public let childrenTransform: CoreFoundation.CGAffineTransform
  final public let clipContent: Swift.Bool
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  final public let path: LayoutKitInterface.UIElementPath?
  public init(blockLayoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, layoutDirection: LayoutKit.ContainerBlock.LayoutDirection, layoutMode: LayoutKit.ContainerBlock.LayoutMode = .noWrap, widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, axialAlignment: LayoutKit.ContainerBlock.AxialAlignment = .leading, crossAlignment: LayoutKit.ContainerBlock.CrossAlignment = .leading, gaps: [CoreFoundation.CGFloat]? = nil, children: [LayoutKit.ContainerBlock.Child], separator: LayoutKit.ContainerBlock.Separator? = nil, lineSeparator: LayoutKit.ContainerBlock.Separator? = nil, contentAnimation: LayoutKit.BlockAnimation? = nil, anchorPoint: LayoutKit.AnchorPoint = ContainerBlock.defaultAnchorPoint, childrenTransform: CoreFoundation.CGAffineTransform = .identity, clipContent: Swift.Bool = true, accessibilityElement: VGSLUI.AccessibilityElement? = nil, path: LayoutKitInterface.UIElementPath? = nil) throws
  final public func ascent(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  final public var isVerticallyResizable: Swift.Bool {
    get
  }
  final public var isHorizontallyResizable: Swift.Bool {
    get
  }
  final public var calculateWidthFirst: Swift.Bool {
    get
  }
  final public var isVerticallyConstrained: Swift.Bool {
    get
  }
  final public var isHorizontallyConstrained: Swift.Bool {
    get
  }
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  final public var heightOfVerticallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  final public func widthOfHorizontallyNonResizableBlock(forHeight height: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.ContainerBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.ContainerBlock, rhs: LayoutKit.ContainerBlock) -> Swift.Bool
}
extension LayoutKit.ContainerBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.ContainerBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.ContainerBlock
}
extension LayoutKit.ContainerBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.ContainerBlock
}
extension LayoutKit.ContainerBlock.Child {
  public static func == (lhs: LayoutKit.ContainerBlock.Child, rhs: LayoutKit.ContainerBlock.Child) -> Swift.Bool
}
extension LayoutKit.ContainerBlock.CrossAlignment {
  public func offset(forAvailableSpace availableSpace: CoreFoundation.CGFloat, contentSize: CoreFoundation.CGFloat = 0) -> CoreFoundation.CGFloat
}
extension LayoutKit.ContainerBlock : LayoutKit.ImageRenderableBlock {
  final public func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
extension LayoutKit.ContainerBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
extension LayoutKit.ContainerBlock {
  final public func modifying(layoutDirection: LayoutKit.ContainerBlock.LayoutDirection? = nil, layoutMode: LayoutKit.ContainerBlock.LayoutMode? = nil, widthTrait: LayoutKit.LayoutTrait? = nil, heightTrait: LayoutKit.LayoutTrait? = nil, axialAlignment: LayoutKit.ContainerBlock.AxialAlignment? = nil, crossAlignment: LayoutKit.ContainerBlock.CrossAlignment? = nil, gaps: [CoreFoundation.CGFloat]? = nil, children: [LayoutKit.ContainerBlock.Child]? = nil, contentAnimation: LayoutKit.BlockAnimation?? = nil, anchorPoint: LayoutKit.AnchorPoint? = nil, childrenTransform: CoreFoundation.CGAffineTransform? = nil, clipContent: Swift.Bool? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil, path: LayoutKitInterface.UIElementPath? = nil) throws -> LayoutKit.ContainerBlock
  convenience public init(layoutDirection: LayoutKit.ContainerBlock.LayoutDirection, layoutMode: LayoutKit.ContainerBlock.LayoutMode = .noWrap, widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, horizontalChildrenAlignment: VGSLUI.Alignment = .leading, verticalChildrenAlignment: VGSLUI.Alignment = .leading, gaps: [CoreFoundation.CGFloat]? = nil, children: [any LayoutKit.Block], contentAnimation: LayoutKit.BlockAnimation? = nil, anchorPoint: LayoutKit.AnchorPoint = ContainerBlock.defaultAnchorPoint, childrenTransform: CoreFoundation.CGAffineTransform = .identity, clipContent: Swift.Bool = true, accessibilityElement: VGSLUI.AccessibilityElement? = nil, path: LayoutKitInterface.UIElementPath? = nil) throws
}
public struct ContextMenu : Swift.Equatable {
  public struct Item : Swift.Equatable {
    public let image: VGSLUI.Image
    public let text: Swift.String
    public let action: LayoutKitInterface.UserInterfaceAction
    public let isDestructive: Swift.Bool
    public init(image: VGSLUI.Image, text: Swift.String, action: LayoutKitInterface.UserInterfaceAction, isDestructive: Swift.Bool = false)
    public static func == (lhs: LayoutKit.ContextMenu.Item, rhs: LayoutKit.ContextMenu.Item) -> Swift.Bool
  }
  public let title: Swift.String?
  public let cancelTitle: Swift.String
  public let items: VGSLFundamentals.NonEmptyArray<LayoutKit.ContextMenu.Item>
  public let preview: any LayoutKit.Block
  public init(title: Swift.String? = nil, cancelTitle: Swift.String, items: VGSLFundamentals.NonEmptyArray<LayoutKit.ContextMenu.Item>, preview: any LayoutKit.Block)
  public static func == (lhs: LayoutKit.ContextMenu, rhs: LayoutKit.ContextMenu) -> Swift.Bool
}
extension LayoutKit.ContextMenu : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct CornerRadii : Swift.Equatable {
  public let topLeft: CoreFoundation.CGFloat
  public let topRight: CoreFoundation.CGFloat
  public let bottomLeft: CoreFoundation.CGFloat
  public let bottomRight: CoreFoundation.CGFloat
  public init(topLeft: CoreFoundation.CGFloat, topRight: CoreFoundation.CGFloat, bottomLeft: CoreFoundation.CGFloat, bottomRight: CoreFoundation.CGFloat)
  public static func == (a: LayoutKit.CornerRadii, b: LayoutKit.CornerRadii) -> Swift.Bool
}
extension LayoutKit.CornerRadii : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: CoreFoundation.CGFloat.NativeType)
  public init(_ value: CoreFoundation.CGFloat)
  public typealias FloatLiteralType = CoreFoundation.CGFloat.NativeType
}
extension LayoutKit.CornerRadii {
  public static var zero: LayoutKit.CornerRadii
}
extension LayoutKit.CornerRadii {
  public var unifiedRadius: CoreFoundation.CGFloat? {
    get
  }
  public var maskedCorners: QuartzCore.CACornerMask {
    get
  }
}
final public class DebugInfoBlock : LayoutKit.WrapperBlock, LayoutKit.LayoutCachingDefaultImpl {
  public static let showOverlayURL: Foundation.URL
  final public let child: any LayoutKit.Block
  final public let showDebugInfo: VGSLFundamentals.Action
  public init(child: any LayoutKit.Block, showDebugInfo: @escaping VGSLFundamentals.Action)
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> LayoutKit.DebugInfoBlock
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.DebugInfoBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.DebugInfoBlock, rhs: LayoutKit.DebugInfoBlock) -> Swift.Bool
}
extension LayoutKit.DebugInfoBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.DebugInfoBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
final public class DefaultPlayerFactory : LayoutKit.PlayerFactory {
  final public func makePlayer(data: LayoutKit.VideoData?, config: LayoutKit.PlaybackConfig?) -> any LayoutKit.Player
  final public func makePlayerView() -> any LayoutKit.PlayerView
  public init(itemsProvider: any LayoutKit.PlayerItemsProvider = DefaultPlayerItemsProvider())
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class DefaultPlayerView : UIKit.UIView, LayoutKit.PlayerView {
  @_Concurrency.MainActor @preconcurrency final public func onVisibleBoundsChanged(from _: CoreFoundation.CGRect, to _: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency final public func attach(player: any LayoutKit.Player)
  @_Concurrency.MainActor @preconcurrency final public func set(scale: LayoutKit.VideoScale)
  @_Concurrency.MainActor @preconcurrency final public var videoRatio: CoreFoundation.CGFloat? {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override public static var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct ChangeBoundsTransition : Swift.Equatable {
  public let duration: Foundation.TimeInterval
  public let delay: Foundation.TimeInterval
  public let timingFunction: LayoutKit.TimingFunction
  public init(duration: Foundation.TimeInterval, delay: Foundation.TimeInterval, timingFunction: LayoutKit.TimingFunction)
  public static func == (a: LayoutKit.ChangeBoundsTransition, b: LayoutKit.ChangeBoundsTransition) -> Swift.Bool
}
final public class DetachableAnimationBlock : LayoutKit.WrapperBlock, LayoutKit.LayoutCachingDefaultImpl, Swift.Identifiable {
  final public let child: any LayoutKit.Block
  final public let id: Swift.String
  final public let animationIn: [LayoutKit.TransitioningAnimation]?
  final public let animationOut: [LayoutKit.TransitioningAnimation]?
  final public let animationChange: LayoutKit.ChangeBoundsTransition?
  public init(child: any LayoutKit.Block, id: Swift.String, animationIn: [LayoutKit.TransitioningAnimation]?, animationOut: [LayoutKit.TransitioningAnimation]?, animationChange: LayoutKit.ChangeBoundsTransition?)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func makeCopy(wrapping child: any LayoutKit.Block) -> LayoutKit.DetachableAnimationBlock
  public typealias ID = Swift.String
  @objc deinit
}
extension LayoutKit.DetachableAnimationBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.DetachableAnimationBlock, rhs: LayoutKit.DetachableAnimationBlock) -> Swift.Bool
}
extension LayoutKit.DetachableAnimationBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.DetachableAnimationBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> Self
}
extension LayoutKit.DetachableAnimationBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> Self
}
extension LayoutKit.DetachableAnimationBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public protocol EffectiveBackgroundColorProviding {
  var effectiveBackgroundColor: UIKit.UIColor? { get }
}
public protocol ElementState {
}
extension LayoutKit.ElementState {
  public func isDifferent(from newState: any LayoutKit.ElementState) -> Swift.Bool
}
public typealias BlocksState = [LayoutKitInterface.UIElementPath : any LayoutKit.ElementState]
public protocol ElementStateObserver : AnyObject {
  func elementStateChanged(_ state: any LayoutKit.ElementState, forPath path: LayoutKitInterface.UIElementPath)
  func focusedElementChanged(isFocused: Swift.Bool, forPath path: LayoutKitInterface.UIElementPath)
  func clearFocus()
}
extension LayoutKit.ElementStateObserver {
  public func focusedElementChanged(isFocused _: Swift.Bool, forPath _: LayoutKitInterface.UIElementPath)
  public func clearFocus()
}
extension Swift.Dictionary where Key == LayoutKitInterface.UIElementPath, Value == any LayoutKit.ElementState {
  @inlinable public func getState<T>(at path: Key) -> T? where T : LayoutKit.ElementState {
    guard let value = self[path] else {
      return nil
    }

    guard let state = value as? T else {
      assertionFailure("Unexpected state type \(value)")
      return nil
    }

    return state
  }
}
public protocol ElementStateUpdating {
  func updated(withStates states: LayoutKit.BlocksState) throws -> Self
}
public protocol ElementStateUpdatingDefaultImpl : LayoutKit.Block {
}
extension LayoutKit.ElementStateUpdatingDefaultImpl {
  public func updated(withStates _: LayoutKit.BlocksState) -> Self
}
public protocol ElementFocusUpdating {
  func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> Self
}
extension LayoutKit.ElementFocusUpdating {
  public func updated(path _: LayoutKitInterface.UIElementPath, isFocused _: Swift.Bool) throws -> Self
}
public struct ElementsTransformation : Swift.Equatable {
  public enum Style {
    case slide
    case overlap
    public static func == (a: LayoutKit.ElementsTransformation.Style, b: LayoutKit.ElementsTransformation.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let nextElementAlpa: CoreFoundation.CGFloat
  public let previousElementAlpha: CoreFoundation.CGFloat
  public let nextElementScale: CoreFoundation.CGFloat
  public let previousElementScale: CoreFoundation.CGFloat
  public let style: LayoutKit.ElementsTransformation.Style
  public let scrollDirection: LayoutKit.ScrollDirection
  public init(nextElementAlpha: CoreFoundation.CGFloat, previousElementAlpha: CoreFoundation.CGFloat, nextElementScale: CoreFoundation.CGFloat, previousElementScale: CoreFoundation.CGFloat, style: LayoutKit.ElementsTransformation.Style, scrollDirection: LayoutKit.ScrollDirection)
  public static func == (a: LayoutKit.ElementsTransformation, b: LayoutKit.ElementsTransformation) -> Swift.Bool
}
final public class EmptyBlock : LayoutKit.BlockWithTraits {
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  public init(widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .resizable)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
public func == (lhs: LayoutKit.EmptyBlock, rhs: LayoutKit.EmptyBlock) -> Swift.Bool
extension LayoutKit.EmptyBlock {
  public static let zeroSized: LayoutKit.EmptyBlock
}
extension LayoutKit.EmptyBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.EmptyBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.EmptyBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
final public class FixedLengthMaskFormatter : LayoutKit.MaskFormatter {
  public init(pattern: Swift.String, alwaysVisible: Swift.Bool, patternElements: [LayoutKit.PatternElement])
  final public func formatted(rawText: Swift.String, rawCursorPosition: LayoutKit.CursorData? = nil) -> LayoutKit.InputData
  final public func equals(_ other: any LayoutKit.MaskFormatter) -> Swift.Bool
  @objc deinit
}
public struct PatternElement {
  public init(key: Swift.Character, regex: Foundation.NSRegularExpression, placeholder: Swift.Character)
}
public struct Pattern : Swift.Equatable {
  public let regexp: Foundation.NSRegularExpression
  public var placeHolder: Swift.Character
  public static func == (a: LayoutKit.Pattern, b: LayoutKit.Pattern) -> Swift.Bool
}
final public class GalleryBlock : LayoutKit.BlockWithTraits {
  final public let model: LayoutKit.GalleryViewModel
  final public let state: LayoutKit.GalleryViewState
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  public init(model: LayoutKit.GalleryViewModel, state: LayoutKit.GalleryViewState, widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait) throws
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.GalleryBlock {
  convenience public init(gaps: [CoreFoundation.CGFloat], children: [any LayoutKit.Block], path: LayoutKitInterface.UIElementPath, direction: LayoutKit.ScrollDirection, crossAlignment: VGSLUI.Alignment, scrollMode: LayoutKit.GalleryViewModel.ScrollMode = .default, state: LayoutKit.GalleryViewState? = nil, widthTrait: LayoutKit.LayoutTrait? = nil, heightTrait: LayoutKit.LayoutTrait? = nil, areEmptySpaceTouchesEnabled: Swift.Bool = true, alwaysBounceVertical: Swift.Bool = false, bounces: Swift.Bool = true) throws
  convenience public init(gaps: [CoreFoundation.CGFloat], children: [any LayoutKit.Block], path: LayoutKitInterface.UIElementPath, direction: LayoutKit.ScrollDirection, crossAlignment: VGSLUI.Alignment, scrollMode: LayoutKit.GalleryViewModel.ScrollMode = .default, contentPosition: LayoutKit.GalleryViewState.Position, widthTrait: LayoutKit.LayoutTrait? = nil, heightTrait: LayoutKit.LayoutTrait? = nil, areEmptySpaceTouchesEnabled: Swift.Bool = true, alwaysBounceVertical: Swift.Bool = false, bounces: Swift.Bool = true) throws
}
extension LayoutKit.GalleryBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.GalleryBlock, rhs: LayoutKit.GalleryBlock) -> Swift.Bool
}
extension LayoutKit.GalleryBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.GalleryBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.GalleryBlock
}
extension LayoutKit.GalleryBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.GalleryBlock
}
extension LayoutKit.GalleryBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.GalleryBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public protocol GalleryScrollEventHandling {
  func handle(galleryScrollEvent: LayoutKit.GalleryScrollEvent, from sender: Swift.AnyObject)
}
final public class GalleryScrollEvent : LayoutKit.AppActionEventProtocol {
  public enum Direction {
    case none
    case forward
    case backward
    public init(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat)
    public static func == (a: LayoutKit.GalleryScrollEvent.Direction, b: LayoutKit.GalleryScrollEvent.Direction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let path: LayoutKitInterface.UIElementPath
  final public let direction: LayoutKit.GalleryScrollEvent.Direction
  final public let firstVisibleItemIndex: Swift.Int
  final public let lastVisibleItemIndex: Swift.Int
  final public let itemsCount: Swift.Int
  public init(path: LayoutKitInterface.UIElementPath, direction: LayoutKit.GalleryScrollEvent.Direction, firstVisibleItemIndex: Swift.Int, lastVisibleItemIndex: Swift.Int, itemsCount: Swift.Int)
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.GalleryScrollEvent.Handler?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class GalleryView : LayoutKit.BlockView {
  public typealias LayoutFactory = (LayoutKit.GalleryViewModel, CoreFoundation.CGSize) -> any LayoutKit.GalleryViewLayouting
  @_Concurrency.MainActor @preconcurrency final public var layoutReporter: LayoutKit.LayoutReporter?
  @_Concurrency.MainActor @preconcurrency final public var visibleBoundsTrackingSubviews: [any UIKit.UIView & VGSLUI.VisibleBoundsTracking] {
    get
  }
  @_Concurrency.MainActor @preconcurrency weak final public var observer: (any LayoutKit.ElementStateObserver)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var path: LayoutKitInterface.UIElementPath {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var visibilityState: LayoutKit.GalleryVisibilityState {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var effectiveBackgroundColor: UIKit.UIColor? {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public func configure(model: LayoutKit.GalleryViewModel, state: LayoutKit.GalleryViewState, layoutFactory: @escaping LayoutKit.GalleryView.LayoutFactory = GalleryViewLayout.init, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  @_Concurrency.MainActor @preconcurrency weak final public var updatesDelegate: (any LayoutKit.GalleryViewModelDelegate)?
  @_Concurrency.MainActor @preconcurrency weak final public var visibilityDelegate: (any LayoutKit.GalleryVisibilityDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @objc deinit
}
extension LayoutKit.GalleryView : VGSLUI.ScrollDelegate {
  @_Concurrency.MainActor @preconcurrency final public func onWillBeginDragging(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
  @_Concurrency.MainActor @preconcurrency final public func onWillEndDragging(_: any UIKit.UIView & VGSLUI.ScrollViewType, withVelocity _: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor @preconcurrency final public func onDidScroll(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
  @_Concurrency.MainActor @preconcurrency final public func onDidEndDragging(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency final public func onDidEndDecelerating(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
  @_Concurrency.MainActor @preconcurrency final public func onDidEndScrollingAnimation(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
}
extension LayoutKit.GalleryView : VGSLUI.ScrollViewTrackable {
  @_Concurrency.MainActor @preconcurrency final public var isTracking: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isDragging: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isDecelerating: Swift.Bool {
    get
  }
}
extension LayoutKit.GalleryView : VGSLUI.VisibleBoundsTrackingContainer {
}
public protocol GalleryViewLayouting {
  var pageOrigins: [CoreFoundation.CGFloat] { get }
  var blockFrames: [CoreFoundation.CGRect] { get }
  var contentSize: CoreFoundation.CGSize { get }
  var transformation: LayoutKit.ElementsTransformation? { get }
  var scrollDirection: LayoutKit.ScrollDirection { get }
  func contentOffset(pageIndex: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  func pageIndex(forContentOffset contentOffset: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  func isEqual(to model: LayoutKit.GalleryViewModel, boundsSize: CoreFoundation.CGSize) -> Swift.Bool
}
public struct GalleryViewLayout : LayoutKit.GalleryViewLayouting, Swift.Equatable {
  public struct Page {
    public let index: Swift.Int
    public let origin: CoreFoundation.CGFloat
    public let size: CoreFoundation.CGFloat
    public func contains(_ offset: CoreFoundation.CGFloat) -> Swift.Bool
  }
  public let model: LayoutKit.GalleryViewModel
  public let boundsSize: CoreFoundation.CGSize
  public let blockFrames: [CoreFoundation.CGRect]
  public let blockPages: [LayoutKit.GalleryViewLayout.Page]
  public let contentSize: CoreFoundation.CGSize
  public var transformation: LayoutKit.ElementsTransformation? {
    get
  }
  public var scrollDirection: LayoutKit.ScrollDirection {
    get
  }
  public var pageOrigins: [CoreFoundation.CGFloat] {
    get
  }
  public init(model: LayoutKit.GalleryViewModel, boundsSize: CoreFoundation.CGSize? = nil)
  public func contentOffset(pageIndex: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func pageIndex(forContentOffset contentOffset: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func isEqual(to model: LayoutKit.GalleryViewModel, boundsSize: CoreFoundation.CGSize) -> Swift.Bool
  public static func == (lhs: LayoutKit.GalleryViewLayout, rhs: LayoutKit.GalleryViewLayout) -> Swift.Bool
}
extension LayoutKit.GalleryViewModel {
  public var intrinsicSize: CoreFoundation.CGSize {
    get
  }
}
public struct GalleryViewMetrics : Swift.Equatable {
  public let axialInsetMode: LayoutKit.InsetMode
  public let crossInsetMode: LayoutKit.InsetMode
  public let spacings: [CoreFoundation.CGFloat]
  public let crossSpacing: CoreFoundation.CGFloat
  public init(axialInsetMode: LayoutKit.InsetMode, crossInsetMode: LayoutKit.InsetMode = .fixed(values: .zero), spacings: [CoreFoundation.CGFloat], crossSpacing: CoreFoundation.CGFloat)
  public init(gaps: [CoreFoundation.CGFloat])
  public func gaps(forSize size: CoreFoundation.CGFloat) -> [CoreFoundation.CGFloat]
  public static func == (a: LayoutKit.GalleryViewMetrics, b: LayoutKit.GalleryViewMetrics) -> Swift.Bool
}
public struct GalleryViewModel : Swift.Equatable {
  public enum ScrollMode : Swift.Equatable {
    case `default`
    case autoPaging(inertionEnabled: Swift.Bool)
    case fixedPaging(pageSize: CoreFoundation.CGFloat)
    public static func == (a: LayoutKit.GalleryViewModel.ScrollMode, b: LayoutKit.GalleryViewModel.ScrollMode) -> Swift.Bool
  }
  public struct Item : Swift.Equatable {
    public let crossAlignment: VGSLUI.Alignment
    public var content: any LayoutKit.Block
    public init(crossAlignment: VGSLUI.Alignment, content: any LayoutKit.Block)
  }
  public enum Scrollbar : Swift.Equatable {
    case none
    case auto
    public var show: Swift.Bool {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LayoutKit.GalleryViewModel.Scrollbar, b: LayoutKit.GalleryViewModel.Scrollbar) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public var items: [LayoutKit.GalleryViewModel.Item]
  public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  public let metrics: LayoutKit.GalleryViewMetrics
  public let scrollMode: LayoutKit.GalleryViewModel.ScrollMode
  public let path: LayoutKitInterface.UIElementPath
  public let alignment: VGSLUI.Alignment
  public let direction: LayoutKit.ScrollDirection
  public let bufferSize: Swift.Int
  public let columnCount: Swift.Int
  public let areEmptySpaceTouchesEnabled: Swift.Bool
  public let alwaysBounceVertical: Swift.Bool
  public let bounces: Swift.Bool
  public let infiniteScroll: Swift.Bool
  public let scrollbar: LayoutKit.GalleryViewModel.Scrollbar
  public let transformation: LayoutKit.ElementsTransformation?
  public init(blocks: [any LayoutKit.Block], layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, metrics: LayoutKit.GalleryViewMetrics, scrollMode: LayoutKit.GalleryViewModel.ScrollMode = .default, path: LayoutKitInterface.UIElementPath, alignment: VGSLUI.Alignment = .center, direction: LayoutKit.ScrollDirection = .horizontal, bufferSize: Swift.Int = 0, columnCount: Swift.Int = 1, crossAlignment: VGSLUI.Alignment = .leading, areEmptySpaceTouchesEnabled: Swift.Bool = true, alwaysBounceVertical: Swift.Bool = false, bounces: Swift.Bool = true, infiniteScroll: Swift.Bool = false, scrollbar: LayoutKit.GalleryViewModel.Scrollbar = .none, transformation: LayoutKit.ElementsTransformation? = nil)
  public init(items: [LayoutKit.GalleryViewModel.Item], layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, metrics: LayoutKit.GalleryViewMetrics, scrollMode: LayoutKit.GalleryViewModel.ScrollMode = .default, path: LayoutKitInterface.UIElementPath, alignment: VGSLUI.Alignment = .center, direction: LayoutKit.ScrollDirection = .horizontal, bufferSize: Swift.Int = 0, columnCount: Swift.Int = 1, areEmptySpaceTouchesEnabled: Swift.Bool = true, alwaysBounceVertical: Swift.Bool = false, bounces: Swift.Bool = true, infiniteScroll: Swift.Bool = false, scrollbar: LayoutKit.GalleryViewModel.Scrollbar = .none, transformation: LayoutKit.ElementsTransformation? = nil)
  public func modifying(items: [LayoutKit.GalleryViewModel.Item]? = nil, metrics: LayoutKit.GalleryViewMetrics? = nil, scrollMode: LayoutKit.GalleryViewModel.ScrollMode? = nil, path: LayoutKitInterface.UIElementPath? = nil, bufferSize: Swift.Int? = nil, direction: LayoutKit.ScrollDirection? = nil, areEmptySpaceTouchesEnabled: Swift.Bool? = nil) -> LayoutKit.GalleryViewModel
  public static func == (a: LayoutKit.GalleryViewModel, b: LayoutKit.GalleryViewModel) -> Swift.Bool
}
extension LayoutKit.GalleryViewModel.Item {
  public static func == (lhs: LayoutKit.GalleryViewModel.Item, rhs: LayoutKit.GalleryViewModel.Item) -> Swift.Bool
}
public protocol GalleryViewModelDelegate : AnyObject {
  func onContentOffsetChanged(_ contentOffset: CoreFoundation.CGFloat, in model: LayoutKit.GalleryViewModel)
}
public struct GalleryViewState : LayoutKit.ElementState, Swift.Equatable {
  @frozen public enum Position : Swift.Equatable {
    case offset(_: CoreFoundation.CGFloat, firstVisibleItemIndex: Swift.Int = 0)
    case paging(index: CoreFoundation.CGFloat)
    public var offset: CoreFoundation.CGFloat? {
      get
    }
    public var pageIndex: CoreFoundation.CGFloat? {
      get
    }
    public var isPaging: Swift.Bool {
      get
    }
    public static func == (lhs: LayoutKit.GalleryViewState.Position, rhs: LayoutKit.GalleryViewState.Position) -> Swift.Bool
  }
  public let contentPosition: LayoutKit.GalleryViewState.Position
  public let itemsCount: Swift.Int
  public let isScrolling: Swift.Bool
  public let scrollRange: CoreFoundation.CGFloat?
  public let animated: Swift.Bool
  public init(contentOffset: CoreFoundation.CGFloat, itemsCount: Swift.Int)
  public init(contentPageIndex: CoreFoundation.CGFloat, itemsCount: Swift.Int, animated: Swift.Bool)
  public init(contentPosition: LayoutKit.GalleryViewState.Position, itemsCount: Swift.Int, isScrolling: Swift.Bool, scrollRange: CoreFoundation.CGFloat? = nil, animated: Swift.Bool)
  public static func == (lhs: LayoutKit.GalleryViewState, rhs: LayoutKit.GalleryViewState) -> Swift.Bool
}
extension LayoutKit.GalleryViewState {
  public func resetToModelIfInconsistent(_ model: LayoutKit.GalleryViewModel) -> LayoutKit.GalleryViewState
}
public protocol GalleryVisibilityDelegate : AnyObject {
  func onGalleryVisibilityChanged()
}
public struct GalleryVisibilityState : Swift.Equatable {
  public struct Item : Swift.Equatable {
    public let state: LayoutKit.VisibilityState
    public let index: Swift.Int
    public init(state: LayoutKit.VisibilityState, index: Swift.Int)
    public static func == (a: LayoutKit.GalleryVisibilityState.Item, b: LayoutKit.GalleryVisibilityState.Item) -> Swift.Bool
  }
  public let visibleItems: [LayoutKit.GalleryVisibilityState.Item]
  public let selectedItemIndex: CoreFoundation.CGFloat?
  public let isChangingContentOffsetDueToUserActions: Swift.Bool
  public init(visibleItems: [LayoutKit.GalleryVisibilityState.Item], selectedItemIndex: CoreFoundation.CGFloat?, isChangingContentOffsetDueToUserActions: Swift.Bool)
  public func intersected(with visibleBounds: CoreFoundation.CGRect) -> LayoutKit.GalleryVisibilityState
  public static func == (a: LayoutKit.GalleryVisibilityState, b: LayoutKit.GalleryVisibilityState) -> Swift.Bool
}
public struct GenericCollectionLayout {
  public let frames: [CoreFoundation.CGRect]
  public let contentSize: CoreFoundation.CGSize
  public let transformation: LayoutKit.ElementsTransformation?
  public init(frames: [CoreFoundation.CGRect], contentSize: CoreFoundation.CGSize = .zero, transformation: LayoutKit.ElementsTransformation? = nil)
  public init(frames: [CoreFoundation.CGRect], pageSize: CoreFoundation.CGSize, transformation: LayoutKit.ElementsTransformation? = nil)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class GenericCollectionReusableView : UIKit.UICollectionReusableView {
  @_Concurrency.MainActor @preconcurrency final public var model: (any LayoutKit.UIViewRenderable)! {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public func configure(model: any LayoutKit.UIViewRenderable, observer: (any LayoutKit.ElementStateObserver)? = nil)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class GenericCollectionViewCell : UIKit.UICollectionViewCell, VGSLUI.VisibleBoundsTrackingContainer {
  @_Concurrency.MainActor @preconcurrency public var model: (any LayoutKit.UIViewRenderable)! {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var visibleBoundsTrackingSubviews: [any UIKit.UIView & VGSLUI.VisibleBoundsTracking] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var view: (any UIKit.UIView & LayoutKit.BlockViewProtocol)? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(model: any LayoutKit.UIViewRenderable, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?, accessibilityElement: VGSLUI.AccessibilityElement?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias CollectionHeaderModel = LayoutKit.Block
public typealias CollectionFooterModel = LayoutKit.Block
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class GenericCollectionViewDataSource : ObjectiveC.NSObject, UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor @preconcurrency final public var models: [[any LayoutKit.Block]]
  @_Concurrency.MainActor @preconcurrency final public var headerModels: [any LayoutKit.Block]
  @_Concurrency.MainActor @preconcurrency final public var footerModels: [any LayoutKit.Block]
  @_Concurrency.MainActor @preconcurrency weak final public var observer: (any LayoutKit.ElementStateObserver)?
  @_Concurrency.MainActor @preconcurrency weak final public var overscrollDelegate: (any VGSLUI.ScrollDelegate)?
  @_Concurrency.MainActor @preconcurrency weak final public var renderingDelegate: (any LayoutKit.RenderingDelegate)?
  @_Concurrency.MainActor @preconcurrency @objc final public func numberOfSections(in _: UIKit.UICollectionView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc final public func collectionView(_: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc final public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor @preconcurrency @objc final public func collectionView(_ collectionView: UIKit.UICollectionView, viewForSupplementaryElementOfKind kind: Swift.String, at indexPath: Foundation.IndexPath) -> UIKit.UICollectionReusableView
  @_Concurrency.MainActor @preconcurrency final public func configureCell(_ cell: UIKit.UICollectionViewCell?, at path: Foundation.IndexPath)
  @_Concurrency.MainActor @preconcurrency final public func configureCell(_ cell: LayoutKit.GenericCollectionViewCell, with model: any LayoutKit.Block)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class GenericCollectionViewLayout : UIKit.UICollectionViewLayout {
  @_Concurrency.MainActor @preconcurrency final public var layout: LayoutKit.GenericCollectionLayout? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var collectionViewContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutAttributesForItem(at indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewLayoutAttributes?
  @_Concurrency.MainActor @preconcurrency @objc override final public func shouldInvalidateLayout(forBoundsChange _: CoreFoundation.CGRect) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutAttributesForElements(in rect: CoreFoundation.CGRect) -> [UIKit.UICollectionViewLayoutAttributes]?
  @_Concurrency.MainActor @preconcurrency @objc override final public var flipsHorizontallyInOppositeLayoutDirection: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol IntrinsicCalculator : AnyObject {
  func calculateWidth() -> CoreFoundation.CGFloat
  func calculateHeight(width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
}
final public class GenericViewBlock : LayoutKit.BlockWithTraits {
  public enum Trait : Swift.Equatable {
    case resizable
    case fixed(CoreFoundation.CGFloat)
    case intrinsic(any LayoutKit.IntrinsicCalculator)
  }
  public typealias LayerType = QuartzCore.CALayer
  public enum Content {
    case view(LayoutKit.ViewType)
    case layer(LayoutKit.GenericViewBlock.LayerType)
  }
  final public let content: VGSLFundamentals.Lazy<LayoutKit.GenericViewBlock.Content>
  final public let width: LayoutKit.GenericViewBlock.Trait
  final public let height: LayoutKit.GenericViewBlock.Trait
  final public var widthTrait: LayoutKit.LayoutTrait {
    get
  }
  final public var heightTrait: LayoutKit.LayoutTrait {
    get
  }
  public init(lazyContent: VGSLFundamentals.Lazy<LayoutKit.GenericViewBlock.Content>, width: LayoutKit.GenericViewBlock.Trait, height: LayoutKit.GenericViewBlock.Trait)
  convenience public init(content: LayoutKit.GenericViewBlock.Content, width: LayoutKit.GenericViewBlock.Trait, height: LayoutKit.GenericViewBlock.Trait)
  convenience public init(view: LayoutKit.ViewType, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil)
  convenience public init(layer: LayoutKit.GenericViewBlock.LayerType, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension LayoutKit.GenericViewBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.GenericViewBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.GenericViewBlock {
  public static func makeIntrinsicSized(for view: LayoutKit.ViewType) -> LayoutKit.GenericViewBlock
  public static func makeIntrinsicSized(for view: VGSLFundamentals.Lazy<some ViewType>) -> LayoutKit.GenericViewBlock
}
extension LayoutKit.GenericViewBlock.Trait {
  public static func == (lhs: LayoutKit.GenericViewBlock.Trait, rhs: LayoutKit.GenericViewBlock.Trait) -> Swift.Bool
}
extension LayoutKit.GenericViewBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
}
final public class GestureBlock : LayoutKit.WrapperBlock, LayoutKit.LayoutCachingDefaultImpl {
  final public let child: any LayoutKit.Block
  final public let upActions: [LayoutKitInterface.UserInterfaceAction]?
  final public let downActions: [LayoutKitInterface.UserInterfaceAction]?
  final public let leftActions: [LayoutKitInterface.UserInterfaceAction]?
  final public let rightActions: [LayoutKitInterface.UserInterfaceAction]?
  public init(child: any LayoutKit.Block, upActions: [LayoutKitInterface.UserInterfaceAction]? = nil, downActions: [LayoutKitInterface.UserInterfaceAction]? = nil, leftActions: [LayoutKitInterface.UserInterfaceAction]? = nil, rightActions: [LayoutKitInterface.UserInterfaceAction]? = nil)
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> LayoutKit.GestureBlock
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.GestureBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.GestureBlock, rhs: LayoutKit.GestureBlock) -> Swift.Bool
}
extension LayoutKit.GestureBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.GestureBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
final public class GradientBlock : LayoutKit.BlockWithTraits {
  final public let gradient: VGSLUI.Gradient
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  public init(gradient: VGSLUI.Gradient, widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .resizable)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public var debugDescription: Swift.String {
    get
  }
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  @objc deinit
}
extension LayoutKit.GradientBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.GradientBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.GradientBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
@_hasMissingDesignatedInitializers final public class GridBlock : LayoutKit.BlockWithTraits {
  public struct Span : Swift.Equatable {
    public let rows: Swift.Int
    public let columns: Swift.Int
    public static let `default`: LayoutKit.GridBlock.Span
    public init(rows: Swift.Int = 1, columns: Swift.Int = 1)
    public static func == (a: LayoutKit.GridBlock.Span, b: LayoutKit.GridBlock.Span) -> Swift.Bool
  }
  public struct Item : Swift.Equatable {
    public struct Weight : Swift.Equatable {
      public let column: LayoutKit.LayoutTrait.Weight?
      public let row: LayoutKit.LayoutTrait.Weight?
      public init(column: LayoutKit.LayoutTrait.Weight? = nil, row: LayoutKit.LayoutTrait.Weight? = nil)
      public static func == (a: LayoutKit.GridBlock.Item.Weight, b: LayoutKit.GridBlock.Item.Weight) -> Swift.Bool
    }
    public let span: LayoutKit.GridBlock.Span
    public let weight: LayoutKit.GridBlock.Item.Weight
    public var contents: any LayoutKit.Block
    public let alignment: LayoutKit.BlockAlignment2D
    public init(span: LayoutKit.GridBlock.Span = .default, weight: LayoutKit.GridBlock.Item.Weight, contents: any LayoutKit.Block, alignment: LayoutKit.BlockAlignment2D = .default)
  }
  public enum Direction : Swift.String {
    case horizontal
    case vertical
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Layout {
    public let size: CoreFoundation.CGSize
    public let itemFrames: [CoreFoundation.CGRect]
  }
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let contentAlignment: LayoutKit.BlockAlignment2D
  final public let items: [LayoutKit.GridBlock.Item]
  final public let columnCount: Swift.Int
  final public let path: LayoutKitInterface.UIElementPath?
  convenience public init(widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait, contentAlignment: LayoutKit.BlockAlignment2D = .default, items: [LayoutKit.GridBlock.Item], columnCount: Swift.Int, path: LayoutKitInterface.UIElementPath? = nil) throws
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.GridBlock {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.GridBlock
}
extension LayoutKit.GridBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.GridBlock
}
extension LayoutKit.GridBlock.Item {
  public static func == (lhs: LayoutKit.GridBlock.Item, rhs: LayoutKit.GridBlock.Item) -> Swift.Bool
}
extension LayoutKit.GridBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, with layout: LayoutKit.GridBlock.Layout?, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public protocol ImageBaseBlock : LayoutKit.BlockWithWidthTrait {
  var path: LayoutKitInterface.UIElementPath? { get }
  var widthTrait: LayoutKit.LayoutTrait { get }
  var height: LayoutKit.ImageBlockHeight { get }
  var imageHolder: any VGSLUI.ImageHolder { get }
  var state: LayoutKit.ImageBaseBlockState { get }
  func makeCopy() -> Self
}
public enum ImageBlockHeight : Swift.Equatable {
  case trait(LayoutKit.LayoutTrait)
  case ratio(Swift.Double)
  public static func == (a: LayoutKit.ImageBlockHeight, b: LayoutKit.ImageBlockHeight) -> Swift.Bool
}
public struct ImageBaseBlockState : LayoutKit.ElementState, Swift.Equatable {
  public let intrinsicContentSize: CoreFoundation.CGSize?
  public init(widthTrait: LayoutKit.LayoutTrait, height: LayoutKit.ImageBlockHeight, imageHolder: any VGSLUI.ImageHolder)
  public static func == (a: LayoutKit.ImageBaseBlockState, b: LayoutKit.ImageBaseBlockState) -> Swift.Bool
}
extension LayoutKit.ImageBaseBlock {
  public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public var isVerticallyResizable: Swift.Bool {
    get
  }
  public var isVerticallyConstrained: Swift.Bool {
    get
  }
  public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func updated(withStates states: LayoutKit.BlocksState) throws -> Self
  public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
final public class ImageBlock : LayoutKit.ImageBaseBlock {
  final public let imageHolder: any VGSLUI.ImageHolder
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let height: LayoutKit.ImageBlockHeight
  final public let contentMode: VGSLUI.ImageContentMode
  final public let tintColor: VGSLUI.Color?
  final public let tintMode: VGSLUI.TintMode
  final public let effects: [VGSLUI.ImageEffect]
  final public let filter: VGSLUI.AnyEquatableImageFilter?
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  final public let appearanceAnimation: LayoutKit.TransitioningAnimation?
  final public let blurUsingMetal: Swift.Bool?
  final public let tintUsingMetal: Swift.Bool?
  final public let path: LayoutKitInterface.UIElementPath?
  final public let state: LayoutKit.ImageBaseBlockState
  public init(imageHolder: any VGSLUI.ImageHolder, widthTrait: LayoutKit.LayoutTrait, height: LayoutKit.ImageBlockHeight, contentMode: VGSLUI.ImageContentMode, tintColor: VGSLUI.Color?, tintMode: VGSLUI.TintMode, effects: [VGSLUI.ImageEffect] = [], filter: VGSLUI.AnyEquatableImageFilter? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil, appearanceAnimation: LayoutKit.TransitioningAnimation? = nil, blurUsingMetal: Swift.Bool? = nil, tintUsingMetal: Swift.Bool? = nil, path: LayoutKitInterface.UIElementPath? = nil)
  convenience public init(imageHolder: any VGSLUI.ImageHolder, widthTrait: LayoutKit.LayoutTrait = .intrinsic, heightTrait: LayoutKit.LayoutTrait = .intrinsic, contentMode: VGSLUI.ImageContentMode = .default, tintColor: VGSLUI.Color? = nil, tintMode: VGSLUI.TintMode = .sourceIn, effects: [VGSLUI.ImageEffect] = [], filter: VGSLUI.AnyEquatableImageFilter? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil, appearanceAnimation: LayoutKit.TransitioningAnimation? = nil, blurUsingMetal: Swift.Bool? = nil, tintUsingMetal: Swift.Bool? = nil, path: LayoutKitInterface.UIElementPath? = nil)
  convenience public init(imageHolder: any VGSLUI.ImageHolder, size: CoreFoundation.CGSize, contentMode: VGSLUI.ImageContentMode = .default, tintColor: VGSLUI.Color? = nil, tintMode: VGSLUI.TintMode = .sourceIn, effects: [VGSLUI.ImageEffect] = [], filter: VGSLUI.AnyEquatableImageFilter? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil, appearanceAnimation: LayoutKit.TransitioningAnimation? = nil, blurUsingMetal: Swift.Bool? = nil, tintUsingMetal: Swift.Bool? = nil, path: LayoutKitInterface.UIElementPath? = nil)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
public func == (lhs: LayoutKit.ImageBlock, rhs: LayoutKit.ImageBlock) -> Swift.Bool
extension LayoutKit.ImageBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.ImageBlock {
  final public func makeCopy(with imageHolder: any VGSLUI.ImageHolder) -> Self
  final public func makeCopy() -> Self
}
extension LayoutKit.ImageBlock : LayoutKit.ImageRenderableBlock {
  final public func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
extension LayoutKit.ImageBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
extension VGSLUI.RemoteImageViewContainer : LayoutKit.BlockViewProtocol {
  @_Concurrency.MainActor @preconcurrency final public var effectiveBackgroundColor: UIKit.UIColor? {
    get
  }
}
extension VGSLUI.RemoteImageViewContainer : VGSLUI.VisibleBoundsTrackingLeaf {
}
public protocol ImageRenderableBlock : LayoutKit.Block {
  func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
extension LayoutKit.ImageRenderableBlock {
  public func makeUIImage(withSize size: CoreFoundation.CGSize) -> VGSLUI.Image
}
public enum InsetMode : Swift.Equatable {
  public struct Resizable : Swift.Equatable {
    public let minValue: CoreFoundation.CGFloat
    public let maxViewportSize: CoreFoundation.CGFloat
    public init(minValue: CoreFoundation.CGFloat, maxViewportSize: CoreFoundation.CGFloat)
    public static func == (a: LayoutKit.InsetMode.Resizable, b: LayoutKit.InsetMode.Resizable) -> Swift.Bool
  }
  case fixed(values: VGSLUI.SideInsets)
  case resizable(params: LayoutKit.InsetMode.Resizable)
  public static func == (a: LayoutKit.InsetMode, b: LayoutKit.InsetMode) -> Swift.Bool
}
extension LayoutKit.InsetMode {
  public func insets(forSize size: CoreFoundation.CGFloat) -> VGSLUI.SideInsets
}
final public class LayeredBlock : LayoutKit.BlockWithTraits {
  public struct Child : Swift.Equatable {
    public var content: any LayoutKit.Block
    public let alignment: LayoutKit.BlockAlignment2D
    public init(content: any LayoutKit.Block, alignment: LayoutKit.BlockAlignment2D = .default)
  }
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let children: [LayoutKit.LayeredBlock.Child]
  convenience public init(widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, horizontalChildrenAlignment: VGSLUI.Alignment = .leading, verticalChildrenAlignment: VGSLUI.Alignment = .leading, children: [any LayoutKit.Block])
  public init(widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, children: [LayoutKit.LayeredBlock.Child])
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.LayeredBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.LayeredBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.LayeredBlock
}
extension LayoutKit.LayeredBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.LayeredBlock
}
extension LayoutKit.LayeredBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.LayeredBlock, rhs: LayoutKit.LayeredBlock) -> Swift.Bool
}
extension LayoutKit.LayeredBlock.Child {
  public static func == (lhs: LayoutKit.LayeredBlock.Child, rhs: LayoutKit.LayeredBlock.Child) -> Swift.Bool
}
extension LayoutKit.LayeredBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public protocol LayoutCaching {
  func laidOut(for width: CoreFoundation.CGFloat) -> any LayoutKit.Block
  func laidOut(for size: CoreFoundation.CGSize) -> any LayoutKit.Block
}
public protocol LayoutCachingDefaultImpl : LayoutKit.Block {
}
extension LayoutKit.LayoutCachingDefaultImpl {
  public func laidOut(for _: CoreFoundation.CGFloat) -> any LayoutKit.Block
  public func laidOut(for _: CoreFoundation.CGSize) -> any LayoutKit.Block
}
public protocol LayoutReporterProvider {
  var layoutReporter: LayoutKit.LayoutReporter? { get set }
}
extension LayoutKit.LayoutReporterProvider {
  public var layoutReporter: LayoutKit.LayoutReporter? {
    get
    set
  }
}
public struct LayoutReporter {
}
@frozen public enum LayoutTrait : Swift.Equatable {
  case fixed(CoreFoundation.CGFloat)
  case intrinsic(constrained: Swift.Bool, minSize: CoreFoundation.CGFloat, maxSize: CoreFoundation.CGFloat)
  case weighted(LayoutKit.LayoutTrait.Weight)
  public struct Weight : Swift.RawRepresentable, Swift.ExpressibleByFloatLiteral, Swift.ExpressibleByIntegerLiteral, Swift.Equatable, Swift.Comparable {
    public let rawValue: CoreFoundation.CGFloat
    public init?(rawValue: CoreFoundation.CGFloat)
    public init(floatLiteral value: Swift.FloatLiteralType)
    public init(integerLiteral value: Swift.IntegerLiteralType)
    public static let `default`: LayoutKit.LayoutTrait.Weight
    public static func < (lhs: LayoutKit.LayoutTrait.Weight, rhs: LayoutKit.LayoutTrait.Weight) -> Swift.Bool
    public static func / (lhs: LayoutKit.LayoutTrait.Weight, rhs: LayoutKit.LayoutTrait.Weight) -> LayoutKit.LayoutTrait.Weight
    public typealias FloatLiteralType = Swift.FloatLiteralType
    public typealias IntegerLiteralType = Swift.IntegerLiteralType
    public typealias RawValue = CoreFoundation.CGFloat
  }
  public static let resizable: LayoutKit.LayoutTrait
  public static let intrinsic: LayoutKit.LayoutTrait
  public static func == (a: LayoutKit.LayoutTrait, b: LayoutKit.LayoutTrait) -> Swift.Bool
}
extension LayoutKit.LayoutTrait {
  public var isResizable: Swift.Bool {
    get
  }
  public var fixedValue: CoreFoundation.CGFloat? {
    get
  }
  public var isConstrained: Swift.Bool {
    get
  }
}
extension LayoutKit.LayeredBlock : LayoutKit.ImageRenderableBlock {
  final public func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
public enum LongTapActions : Swift.Equatable {
  case actions(VGSLFundamentals.NonEmptyArray<LayoutKitInterface.UserInterfaceAction>)
  case contextMenu(LayoutKit.ContextMenu)
  public static func == (a: LayoutKit.LongTapActions, b: LayoutKit.LongTapActions) -> Swift.Bool
}
extension LayoutKit.LongTapActions : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct MarksConfiguration : Swift.Equatable {
  public init(minValue: CoreFoundation.CGFloat, maxValue: CoreFoundation.CGFloat, activeMark: LayoutKit.MarksConfiguration.RoundedRectangle, inactiveMark: LayoutKit.MarksConfiguration.RoundedRectangle, layoutDirection: VGSLUI.UserInterfaceLayoutDirection)
  public static let empty: LayoutKit.MarksConfiguration
}
extension LayoutKit.MarksConfiguration {
  public struct RoundedRectangle : Swift.Equatable {
    public init(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat, color: VGSLUI.Color, borderWidth: CoreFoundation.CGFloat, borderColor: VGSLUI.Color)
    public static let empty: LayoutKit.MarksConfiguration.RoundedRectangle
    public static func == (a: LayoutKit.MarksConfiguration.RoundedRectangle, b: LayoutKit.MarksConfiguration.RoundedRectangle) -> Swift.Bool
  }
  public static func == (lhs: LayoutKit.MarksConfiguration, rhs: LayoutKit.MarksConfiguration) -> Swift.Bool
}
final public class MaskedBlock : LayoutKit.SizeForwardingBlock {
  final public let maskBlock: any LayoutKit.Block
  final public let maskedBlock: any LayoutKit.Block
  final public let allowsUserInteraction: Swift.Bool
  final public var sizeProvider: any LayoutKit.Block {
    get
  }
  public init(maskBlock: any LayoutKit.Block, maskedBlock: any LayoutKit.Block, allowsUserInteraction: Swift.Bool = false)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.MaskedBlock
  @objc deinit
}
extension LayoutKit.MaskedBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.MaskedBlock, rhs: LayoutKit.MaskedBlock) -> Swift.Bool
}
extension LayoutKit.MaskedBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.MaskedBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.MaskedBlock
}
extension LayoutKit.MaskedBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.MaskedBlock : LayoutKit.UIViewRenderable {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class MaskedInputViewModel {
  public enum Action : Swift.Equatable {
    case insert(string: Swift.String, range: Swift.Range<Swift.String.Index>)
    case clear(pos: Swift.String.Index)
    case clearRange(range: Swift.Range<Swift.String.Index>)
    public static func == (a: LayoutKit.MaskedInputViewModel.Action, b: LayoutKit.MaskedInputViewModel.Action) -> Swift.Bool
  }
  @objc deinit
}
public protocol MaskFormatter {
  func formatted(rawText: Swift.String, rawCursorPosition: LayoutKit.CursorData?) -> LayoutKit.InputData
  func equals(_ other: any LayoutKit.MaskFormatter) -> Swift.Bool
}
final public class MaskValidator : Swift.Equatable {
  public init(formatter: any LayoutKit.MaskFormatter)
  final public func formatted(rawText: Swift.String, rawCursorPosition: LayoutKit.CursorData? = nil) -> LayoutKit.InputData
  final public func removeSymbols(at index: Swift.String.Index, data: LayoutKit.InputData) -> (Swift.String, LayoutKit.CursorData?)
  final public func removeSymbols(at range: Swift.Range<Swift.String.Index>, data: LayoutKit.InputData) -> (Swift.String, LayoutKit.CursorData?)
  final public func addSymbols(at range: Swift.Range<Swift.String.Index>, data: LayoutKit.InputData, string: Swift.String) -> (Swift.String, LayoutKit.CursorData?)
  public static func == (lhs: LayoutKit.MaskValidator, rhs: LayoutKit.MaskValidator) -> Swift.Bool
  @objc deinit
}
public enum CursorPositionTag {
}
public typealias CursorPosition = VGSLFundamentals.Tagged<LayoutKit.CursorPositionTag, Swift.String.Index>
public struct CursorData : Swift.Equatable {
  public static func == (a: LayoutKit.CursorData, b: LayoutKit.CursorData) -> Swift.Bool
}
public struct InputData {
  public struct RawCharacter : Swift.Equatable {
    public static func == (a: LayoutKit.InputData.RawCharacter, b: LayoutKit.InputData.RawCharacter) -> Swift.Bool
  }
  public let text: Swift.String
  public let cursorPosition: LayoutKit.CursorPosition?
  public var rawData: [LayoutKit.InputData.RawCharacter]
  public var rawText: Swift.String {
    get
  }
}
extension LayoutKitInterface.Menu {
  public func makeActionSheetModel(sender: UIKit.UIResponder, parentPath: LayoutKitInterface.UIElementPath, cancelTitle: Swift.String, userInterfaceStyle: VGSLUI.UserInterfaceStyle) -> VGSLUI.ActionSheetModel?
}
public struct NinePatchImage {
  public init(imageHolder: any VGSLUI.ImageHolder, insets: LayoutKit.EdgeInsets)
}
extension LayoutKit.NinePatchImage : Swift.Equatable {
  public static func == (lhs: LayoutKit.NinePatchImage, rhs: LayoutKit.NinePatchImage) -> Swift.Bool
}
extension LayoutKit.NinePatchImage : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class NinePatchImageView : UIKit.UIView, VGSLUI.RemoteImageViewContentProtocol {
  @_Concurrency.MainActor @preconcurrency final public var capInsets: UIKit.UIEdgeInsets {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var appearanceAnimation: VGSLUI.ImageViewAnimation?
  @_Concurrency.MainActor @preconcurrency final public var imageRedrawingStyle: VGSLUI.ImageRedrawingStyle?
  @_Concurrency.MainActor @preconcurrency final public var imageContentMode: VGSLUI.ImageContentMode
  @_Concurrency.MainActor @preconcurrency @objc override final public func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency final public func setImage(_ image: UIKit.UIImage?, animated _: Swift.Bool?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class NoContentTouchDelaysCollectionView : UIKit.UICollectionView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect, collectionViewLayout layout: UIKit.UICollectionViewLayout)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func touchesShouldCancel(in _: UIKit.UIView) -> Swift.Bool
  @objc deinit
}
public protocol PaddingProvidingBlock : LayoutKit.Block {
  var paddings: LayoutKit.EdgeInsets { get }
  var child: any LayoutKit.Block { get }
}
extension LayoutKit.PaddingProvidingBlock {
  public func margins(direction: LayoutKit.ScrollDirection) -> CoreFoundation.CGFloat
}
final public class PageControlBlock : LayoutKit.BlockWithTraits {
  public typealias State = LayoutKit.PagerViewState
  final public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  final public let pageControlPath: LayoutKitInterface.UIElementPath?
  final public let pagerPath: LayoutKit.PagerPath?
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let configuration: LayoutKit.PageIndicatorConfiguration
  final public let state: LayoutKit.PageControlBlock.State
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  public init(layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, pageControlPath: LayoutKitInterface.UIElementPath? = nil, pagerPath: LayoutKit.PagerPath?, widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait, configuration: LayoutKit.PageIndicatorConfiguration, state: LayoutKit.PageControlBlock.State)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.PageControlBlock
  @objc deinit
}
public func == (lhs: LayoutKit.PageControlBlock, rhs: LayoutKit.PageControlBlock) -> Swift.Bool
extension LayoutKit.PageControlBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.PageControlBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public struct PageIndicatorConfiguration : Swift.Equatable {
  public enum Animation {
    case scale, slider, worm
    public static func == (a: LayoutKit.PageIndicatorConfiguration.Animation, b: LayoutKit.PageIndicatorConfiguration.Animation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ItemPlacement : Swift.Equatable {
    case fixed(spaceBetweenCenters: CoreFoundation.CGFloat)
    case stretch(spacing: CoreFoundation.CGFloat, maxVisibleItems: Swift.Int)
    public static func == (a: LayoutKit.PageIndicatorConfiguration.ItemPlacement, b: LayoutKit.PageIndicatorConfiguration.ItemPlacement) -> Swift.Bool
  }
  public let highlightedColor: VGSLUI.Color
  public let normalColor: VGSLUI.Color
  public let highlightedBorder: LayoutKit.BlockBorder
  public let normalBorder: LayoutKit.BlockBorder
  public let highlightedHeightScale: CoreFoundation.CGFloat
  public let highlightedWidthScale: CoreFoundation.CGFloat
  public let disappearingHeightScale: CoreFoundation.CGFloat
  public let disappearingWidthScale: CoreFoundation.CGFloat
  public let pageSize: CoreFoundation.CGSize
  public let highlightedPageCornerRadius: CoreFoundation.CGFloat?
  public let pageCornerRadius: CoreFoundation.CGFloat
  public let animation: LayoutKit.PageIndicatorConfiguration.Animation
  public let itemPlacement: LayoutKit.PageIndicatorConfiguration.ItemPlacement
  public init(highlightedColor: VGSLUI.Color, normalColor: VGSLUI.Color, highlightedBorder: LayoutKit.BlockBorder, normalBorder: LayoutKit.BlockBorder, highlightedHeightScale: CoreFoundation.CGFloat, highlightedWidthScale: CoreFoundation.CGFloat, disappearingHeightScale: CoreFoundation.CGFloat, disappearingWidthScale: CoreFoundation.CGFloat, pageSize: CoreFoundation.CGSize, highlightedPageCornerRadius: CoreFoundation.CGFloat?, pageCornerRadius: CoreFoundation.CGFloat, animation: LayoutKit.PageIndicatorConfiguration.Animation, itemPlacement: LayoutKit.PageIndicatorConfiguration.ItemPlacement)
  public static func == (a: LayoutKit.PageIndicatorConfiguration, b: LayoutKit.PageIndicatorConfiguration) -> Swift.Bool
}
extension LayoutKit.PageIndicatorConfiguration {
  public struct RoundedRectangleIndicator {
    public let size: CoreFoundation.CGSize
    public let cornerRadius: CoreFoundation.CGFloat
    public let backgroundColor: VGSLUI.Color
    public let borderWidth: CoreFoundation.CGFloat
    public let borderColor: VGSLUI.Color
    public init(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat, backgroundColor: VGSLUI.Color, borderWidth: CoreFoundation.CGFloat, borderColor: VGSLUI.Color)
  }
}
final public class PagerBlock : LayoutKit.BlockWithTraits {
  public enum LayoutMode : Swift.Equatable {
    case pageSize(VGSLUI.RelativeValue)
    case neighbourPageSize(CoreFoundation.CGFloat)
    case pageContentSize
    public static func == (a: LayoutKit.PagerBlock.LayoutMode, b: LayoutKit.PagerBlock.LayoutMode) -> Swift.Bool
  }
  final public let pagerPath: LayoutKit.PagerPath?
  final public let layoutMode: LayoutKit.PagerBlock.LayoutMode
  final public let alignment: VGSLUI.Alignment
  final public let gallery: LayoutKit.GalleryViewModel
  final public let state: LayoutKit.PagerViewState
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  public init(pagerPath: LayoutKit.PagerPath?, alignment: VGSLUI.Alignment, layoutMode: LayoutKit.PagerBlock.LayoutMode, gallery: LayoutKit.GalleryViewModel, selectedActions: [[LayoutKitInterface.UserInterfaceAction]], state: LayoutKit.PagerViewState, widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait) throws
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.PagerBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.PagerBlock, rhs: LayoutKit.PagerBlock) -> Swift.Bool
}
extension LayoutKit.PagerBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.PagerBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.PagerBlock
}
extension LayoutKit.PagerBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.PagerBlock
}
extension LayoutKit.PagerBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension Swift.Dictionary where Key == LayoutKitInterface.UIElementPath, Value == any LayoutKit.ElementState {
  public func pagerViewState(for pagerPath: LayoutKit.PagerPath?) -> LayoutKit.PagerViewState?
}
extension LayoutKit.PagerBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public protocol PagerEventHandling {
  func handle(event: LayoutKit.PagerSelectedPageChangedEvent, from sender: Swift.AnyObject)
}
final public class PagerSelectedPageChangedEvent : LayoutKit.AppActionEventProtocol {
  final public let path: LayoutKitInterface.UIElementPath
  final public let selectedPageIndex: Swift.Int
  public init(path: LayoutKitInterface.UIElementPath, selectedPageIndex: Swift.Int)
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.PagerSelectedPageChangedEvent.Handler?
  @objc deinit
}
public struct PagerViewLayout : LayoutKit.GalleryViewLayouting, Swift.Equatable {
  public struct Page {
    public let index: Swift.Int
    public let origin: CoreFoundation.CGFloat
    public let size: CoreFoundation.CGFloat
    public func contains(_ offset: CoreFoundation.CGFloat) -> Swift.Bool
  }
  public let model: LayoutKit.GalleryViewModel
  public let layoutMode: LayoutKit.PagerBlock.LayoutMode
  public let boundsSize: CoreFoundation.CGSize
  public let blockFrames: [CoreFoundation.CGRect]
  public let blockPages: [LayoutKit.PagerViewLayout.Page]
  public let contentSize: CoreFoundation.CGSize
  public var pageOrigins: [CoreFoundation.CGFloat] {
    get
  }
  public var transformation: LayoutKit.ElementsTransformation? {
    get
  }
  public var scrollDirection: LayoutKit.ScrollDirection {
    get
  }
  public init(model: LayoutKit.GalleryViewModel, alignment: VGSLUI.Alignment, layoutMode: LayoutKit.PagerBlock.LayoutMode, boundsSize: CoreFoundation.CGSize)
  public func contentOffset(pageIndex: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func pageIndex(forContentOffset contentOffset: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func isEqual(to model: LayoutKit.GalleryViewModel, boundsSize: CoreFoundation.CGSize) -> Swift.Bool
  public static func == (lhs: LayoutKit.PagerViewLayout, rhs: LayoutKit.PagerViewLayout) -> Swift.Bool
}
extension LayoutKit.GalleryViewModel {
  public func intrinsicPagerSize(forWidth width: CoreFoundation.CGFloat?, layoutMode: LayoutKit.PagerBlock.LayoutMode) -> CoreFoundation.CGSize
}
public struct PagerViewState : LayoutKit.ElementState, Swift.Equatable {
  public let numberOfPages: Swift.Int
  public let currentPage: CoreFoundation.CGFloat
  public let animated: Swift.Bool
  public init(numberOfPages: Swift.Int, currentPage: Swift.Int, animated: Swift.Bool)
  public static let `default`: LayoutKit.PagerViewState
  public static func == (a: LayoutKit.PagerViewState, b: LayoutKit.PagerViewState) -> Swift.Bool
}
extension LayoutKit.PagerViewState {
  public func synchronized(with model: LayoutKit.GalleryViewModel) -> LayoutKit.PagerViewState
}
public protocol PathIdentifiable {
  var path: LayoutKitInterface.UIElementPath? { get }
}
extension LayoutKit.PathIdentifiable {
  public var path: LayoutKitInterface.UIElementPath? {
    get
  }
}
final public class PhoneMaskFormatter : LayoutKit.MaskFormatter {
  public init(masksByCountryCode: VGSLFundamentals.JSONDictionary, extraSymbols: Swift.String)
  final public func formatted(rawText: Swift.String, rawCursorPosition: LayoutKit.CursorData? = nil) -> LayoutKit.InputData
  final public func equals(_ other: any LayoutKit.MaskFormatter) -> Swift.Bool
  @objc deinit
}
final public class PinchToZoomBlock : LayoutKit.WrapperBlock, LayoutKit.LayoutCachingDefaultImpl {
  final public let child: any LayoutKit.Block
  final public let overlayView: LayoutKit.ViewType
  public init(child: any LayoutKit.Block, overlayView: LayoutKit.ViewType)
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> LayoutKit.PinchToZoomBlock
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.PinchToZoomBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.PinchToZoomBlock, rhs: LayoutKit.PinchToZoomBlock) -> Swift.Bool
}
extension LayoutKit.PinchToZoomBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.PinchToZoomBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public protocol Player {
  var signal: VGSLFundamentals.Signal<LayoutKit.PlayerEvent> { get }
  func set(data: LayoutKit.VideoData, config: LayoutKit.PlaybackConfig)
  func play()
  func pause()
  func set(isMuted: Swift.Bool)
  func seek(to position: CoreMedia.CMTime)
}
public enum PlayerEvent {
  case pause
  case buffering
  case play
  case end
  case fatal
  case currentTimeUpdate(_: Swift.Int)
  case durationUpdate(_: Swift.Int)
}
public protocol PlayerFactory {
  func makePlayer(data: LayoutKit.VideoData?, config: LayoutKit.PlaybackConfig?) -> any LayoutKit.Player
  func makePlayerView() -> any LayoutKit.PlayerView
}
public struct PlaybackConfig : Swift.Equatable {
  public let autoPlay: Swift.Bool
  public let repeatable: Swift.Bool
  public let isMuted: Swift.Bool
  public let startPosition: CoreMedia.CMTime
  public let settingsPayload: [Swift.String : Any]
  public init(autoPlay: Swift.Bool, repeatable: Swift.Bool, isMuted: Swift.Bool, startPosition: CoreMedia.CMTime, settingsPayload: [Swift.String : Any])
  public static let `default`: LayoutKit.PlaybackConfig
  public static func == (lhs: LayoutKit.PlaybackConfig, rhs: LayoutKit.PlaybackConfig) -> Swift.Bool
}
public protocol PlayerItemsProvider : AnyObject {
  func getAVPlayerItem(from url: Foundation.URL, completion: @escaping (AVFoundation.AVPlayerItem) -> Swift.Void)
}
public class DefaultPlayerItemsProvider : LayoutKit.PlayerItemsProvider {
  public init()
  public func getAVPlayerItem(from url: Foundation.URL, completion: @escaping (AVFoundation.AVPlayerItem) -> Swift.Void)
  @objc deinit
}
extension VGSLNetworking.CachedURLResourceRequester : LayoutKit.PlayerItemsProvider {
  @_Concurrency.MainActor @preconcurrency final public func getAVPlayerItem(from url: Foundation.URL, completion: @escaping (AVFoundation.AVPlayerItem) -> Swift.Void)
}
public enum PlayerStatus {
  case unknown
  case readyToPlay
  case failed
  public static func == (a: LayoutKit.PlayerStatus, b: LayoutKit.PlayerStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol PlayerView : UIKit.UIView, VGSLUI.VisibleBoundsTracking {
  var videoRatio: CoreFoundation.CGFloat? { get }
  func attach(player: any LayoutKit.Player)
  func set(scale: LayoutKit.VideoScale)
}
extension LayoutKit.PlayerView {
  public var videoRatio: CoreFoundation.CGFloat? {
    get
  }
  public func set(scale _: LayoutKit.VideoScale)
}
public protocol RenderingDelegate : AnyObject {
  func mapView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, to id: LayoutKit.BlockViewID)
  func tooltipAnchorViewAdded(anchorView: any LayoutKit.TooltipAnchorView)
  func tooltipAnchorViewRemoved(anchorView: any LayoutKit.TooltipAnchorView)
  func reportRenderingError(message: Swift.String, isWarning: Swift.Bool, path: LayoutKitInterface.UIElementPath)
}
public typealias BlockViewID = VGSLFundamentals.Tagged<any LayoutKit.BlockViewProtocol, Swift.String>
public protocol DivViewMetaProviding : AnyObject {
  func subview(with id: LayoutKit.BlockViewID) -> (any UIKit.UIView & LayoutKit.BlockViewProtocol)?
}
extension LayoutKit.RenderingDelegate {
  public func reportRenderingError(message _: Swift.String, isWarning _: Swift.Bool, path _: LayoutKitInterface.UIElementPath)
  public func reportViewWasCreated()
  public func reportBlockWillConfigure(path _: LayoutKitInterface.UIElementPath)
  public func reportBlockDidConfigure(path _: LayoutKitInterface.UIElementPath)
  public func reportViewWillLayout(path _: LayoutKitInterface.UIElementPath)
  public func reportViewDidLayout(path _: LayoutKitInterface.UIElementPath)
}
public struct ResizableBlockMeasure {
  public enum Measure {
    case resizable(LayoutKit.LayoutTrait.Weight, reservedSpace: CoreFoundation.CGFloat = 0)
    case nonResizable
  }
  public init(resizableBlockCount: Swift.Int, lengthAvailablePerWeightUnit: CoreFoundation.CGFloat, lengthAvailableForResizableBlocks: CoreFoundation.CGFloat)
  public mutating func measureNext(_ measure: LayoutKit.ResizableBlockMeasure.Measure) -> CoreFoundation.CGFloat
}
extension CoreGraphics.CGPath {
  public static func roundedRect(size: CoreFoundation.CGSize, cornerRadii: LayoutKit.CornerRadii, inset: CoreFoundation.CGFloat = 0) -> CoreGraphics.CGPath
}
@objc @_inheritsConvenienceInitializers final public class ScrollableContentPager : ObjectiveC.NSObject {
  final public func setPageOrigins(_ pageOrigins: [CoreFoundation.CGFloat], withPagingEnabled pagingEnabled: Swift.Bool, isHorizontal: Swift.Bool)
  final public func setInitialOffset(_ offset: CoreFoundation.CGFloat)
  final public var currentPageIndex: Swift.Int? {
    get
  }
  final public var lastTargetPageIndex: Swift.Int? {
    get
  }
  final public func targetPageOffset(forProposedOffset offset: CoreFoundation.CGFloat, velocity: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  @objc override dynamic public init()
  @objc deinit
}
extension LayoutKit.ScrollableContentPager : VGSLUI.ScrollDelegate {
  @_Concurrency.MainActor @preconcurrency final public func onWillBeginDragging(_ scrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
  @_Concurrency.MainActor @preconcurrency final public func onWillEndDragging(_: any UIKit.UIView & VGSLUI.ScrollViewType, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
}
@frozen public enum ScrollDirection : Swift.Equatable, Swift.CaseIterable {
  case horizontal
  case vertical
  public var isHorizontal: Swift.Bool {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LayoutKit.ScrollDirection, b: LayoutKit.ScrollDirection) -> Swift.Bool
  public typealias AllCases = [LayoutKit.ScrollDirection]
  nonisolated public static var allCases: [LayoutKit.ScrollDirection] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_Concurrency.MainActor @preconcurrency final public class SegmentedProgressView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency final public var currentTimestamp: Swift.Double {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var fillColor: VGSLUI.Color {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var segmentBackgroundColor: VGSLUI.Color {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var intervals: [Swift.Double] {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public init(fillColor: VGSLUI.Color, segmentBackgroundColor: VGSLUI.Color)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override final public func draw(_: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency final public func setNeedsLayoutAndReloadLayers()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class SeparatorBlock : LayoutKit.BlockWithTraits {
  public enum Direction {
    case horizontal
    case vertical
    public static func == (a: LayoutKit.SeparatorBlock.Direction, b: LayoutKit.SeparatorBlock.Direction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let color: VGSLUI.Color
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  convenience public init(color: VGSLUI.Color = .clear, direction: LayoutKit.SeparatorBlock.Direction = .horizontal, weight: LayoutKit.LayoutTrait.Weight = .default)
  convenience public init(color: VGSLUI.Color = .clear, direction: LayoutKit.SeparatorBlock.Direction = .horizontal, size: CoreFoundation.CGFloat)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  @objc deinit
}
public func == (lhs: LayoutKit.SeparatorBlock, rhs: LayoutKit.SeparatorBlock) -> Swift.Bool
extension LayoutKit.SeparatorBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.SeparatorBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.SeparatorBlock : LayoutKit.ImageRenderableBlock {
  final public func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
extension LayoutKit.SeparatorBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
final public class ShadedBlock {
  final public let block: any LayoutKit.Block
  final public let shadow: LayoutKit.BlockShadow
  public init(block: any LayoutKit.Block, shadow: LayoutKit.BlockShadow)
  @objc deinit
}
extension LayoutKit.ShadedBlock : LayoutKit.WrapperBlock {
  final public var child: any LayoutKit.Block {
    get
  }
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> LayoutKit.ShadedBlock
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
}
extension LayoutKit.ShadedBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.ShadedBlock, rhs: LayoutKit.ShadedBlock) -> Swift.Bool
}
extension LayoutKit.Block {
  public func shaded(with shadow: LayoutKit.BlockShadow?) -> any LayoutKit.Block
  public func shaded(with cornerRadius: CoreFoundation.CGFloat) -> any LayoutKit.Block
}
extension LayoutKit.ShadedBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.ShadedBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public protocol SizeForwardingBlock : LayoutKit.Block {
  var sizeProvider: any LayoutKit.Block { get }
}
extension LayoutKit.SizeForwardingBlock {
  public var isVerticallyResizable: Swift.Bool {
    get
  }
  public var isHorizontallyResizable: Swift.Bool {
    get
  }
  public var isVerticallyConstrained: Swift.Bool {
    get
  }
  public var isHorizontallyConstrained: Swift.Bool {
    get
  }
  public var calculateWidthFirst: Swift.Bool {
    get
  }
  public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func widthOfHorizontallyNonResizableBlock(forHeight height: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public var heightOfVerticallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  public var minWidth: CoreFoundation.CGFloat {
    get
  }
  public var minHeight: CoreFoundation.CGFloat {
    get
  }
  public var reuseId: Swift.String {
    get
  }
}
final public class SliderBlock : LayoutKit.BlockWithTraits {
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public init(sliderModel: LayoutKit.SliderModel, widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension LayoutKit.SliderBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.SliderBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.SliderBlock : LayoutKit.UIViewRenderable {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public struct SliderModel : Swift.Equatable {
  public struct ThumbModel : Swift.Equatable {
    public let block: any LayoutKit.Block
    public var value: LayoutKit.Binding<Swift.Int>
    public let size: CoreFoundation.CGSize
    public let offsetX: CoreFoundation.CGFloat
    public let offsetY: CoreFoundation.CGFloat
    public init(block: any LayoutKit.Block, value: LayoutKit.Binding<Swift.Int>, size: CoreFoundation.CGSize, offsetX: CoreFoundation.CGFloat, offsetY: CoreFoundation.CGFloat)
    public static func == (lhs: LayoutKit.SliderModel.ThumbModel, rhs: LayoutKit.SliderModel.ThumbModel) -> Swift.Bool
  }
  public struct MarkModel : Swift.Equatable {
    public let block: any LayoutKit.Block
    public let size: CoreFoundation.CGSize
    public init(block: any LayoutKit.Block, size: CoreFoundation.CGSize)
    public static func == (lhs: LayoutKit.SliderModel.MarkModel, rhs: LayoutKit.SliderModel.MarkModel) -> Swift.Bool
  }
  public struct RangeModel : Swift.Equatable {
    public let start: Swift.Int
    public let end: Swift.Int
    public let margins: LayoutKit.EdgeInsets
    public let activeTrack: any LayoutKit.Block
    public let inactiveTrack: any LayoutKit.Block
    public init(start: Swift.Int, end: Swift.Int, margins: LayoutKit.EdgeInsets, activeTrack: any LayoutKit.Block, inactiveTrack: any LayoutKit.Block)
    public static func == (lhs: LayoutKit.SliderModel.RangeModel, rhs: LayoutKit.SliderModel.RangeModel) -> Swift.Bool
  }
  public var firstThumb: LayoutKit.SliderModel.ThumbModel
  public var secondThumb: LayoutKit.SliderModel.ThumbModel?
  public let minValue: Swift.Int
  public let maxValue: Swift.Int
  public let marksConfiguration: LayoutKit.MarksConfiguration
  public let ranges: [LayoutKit.SliderModel.RangeModel]
  public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  public let path: LayoutKitInterface.UIElementPath?
  public let isEnabled: Swift.Bool
  public var valueRange: Swift.Int {
    get
  }
  public var sliderHeight: CoreFoundation.CGFloat {
    get
  }
  public var sliderIntrinsicWidth: CoreFoundation.CGFloat {
    get
  }
  public var sliderTopTextPadding: CoreFoundation.CGFloat {
    get
  }
  public var sliderBottomTextPadding: CoreFoundation.CGFloat {
    get
  }
  public var horizontalInset: CoreFoundation.CGFloat {
    get
  }
  public init(firstThumb: LayoutKit.SliderModel.ThumbModel, secondThumb: LayoutKit.SliderModel.ThumbModel? = nil, minValue: Swift.Int, maxValue: Swift.Int, marksConfiguration: LayoutKit.MarksConfiguration, ranges: [LayoutKit.SliderModel.RangeModel], layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, path: LayoutKitInterface.UIElementPath? = nil, isEnabled: Swift.Bool = true)
  public static func == (lhs: LayoutKit.SliderModel, rhs: LayoutKit.SliderModel) -> Swift.Bool
}
public enum SliderThumbNumber {
  case first
  case second
  public static func == (a: LayoutKit.SliderThumbNumber, b: LayoutKit.SliderThumbNumber) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class StateBlock : LayoutKit.WrapperBlock, LayoutKit.LayoutCachingDefaultImpl {
  final public let child: any LayoutKit.Block
  final public let ids: Swift.Set<Swift.String>
  public init(child: any LayoutKit.Block, ids: Swift.Set<Swift.String>)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func makeCopy(wrapping child: any LayoutKit.Block) -> LayoutKit.StateBlock
  @objc deinit
}
extension LayoutKit.StateBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.StateBlock, rhs: LayoutKit.StateBlock) -> Swift.Bool
}
extension LayoutKit.StateBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.Block {
  public func addingStateBlock(ids: Swift.Set<Swift.String>) -> any LayoutKit.Block
}
extension LayoutKit.StateBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
final public class SwipeContainerBlock : LayoutKit.WrapperBlock {
  public enum State : LayoutKit.ElementState {
    case normal
    case right
    case left
    public static let `default`: LayoutKit.SwipeContainerBlock.State
    public static func == (a: LayoutKit.SwipeContainerBlock.State, b: LayoutKit.SwipeContainerBlock.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let child: any LayoutKit.Block
  public init(child: any LayoutKit.Block, state: LayoutKit.SwipeContainerBlock.State, path: LayoutKitInterface.UIElementPath, swipeOutActions: [LayoutKitInterface.UserInterfaceAction])
  final public func intrinsicContentHeight(forWidth: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func makeCopy(wrapping child: any LayoutKit.Block) -> LayoutKit.SwipeContainerBlock
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  public static func == (lhs: LayoutKit.SwipeContainerBlock, rhs: LayoutKit.SwipeContainerBlock) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.SwipeContainerBlock : LayoutKit.LayoutCaching {
  final public func laidOut(for width: CoreFoundation.CGFloat) -> any LayoutKit.Block
  final public func laidOut(for size: CoreFoundation.CGSize) -> any LayoutKit.Block
}
extension LayoutKit.SwipeContainerBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.SwipeContainerBlock
}
extension LayoutKit.SwipeContainerBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.SwipeContainerBlock
}
extension LayoutKit.SwipeContainerBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
final public class SwitchableContainerBlock : LayoutKit.Block {
  public enum Selection : Swift.Int, Swift.Equatable {
    case left
    case right
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct Title : Swift.Equatable {
    public let selected: Foundation.NSAttributedString
    public let deselected: Foundation.NSAttributedString
    public init(selected: Foundation.NSAttributedString, deselected: Foundation.NSAttributedString)
    public init(text: Swift.String, selectedTypo: VGSLUI.Typo, deselectedTypo: VGSLUI.Typo)
    public static func == (a: LayoutKit.SwitchableContainerBlock.Title, b: LayoutKit.SwitchableContainerBlock.Title) -> Swift.Bool
  }
  public struct Item {
    public let title: LayoutKit.SwitchableContainerBlock.Title
    public let content: any LayoutKit.Block
    public init(title: LayoutKit.SwitchableContainerBlock.Title, content: any LayoutKit.Block)
  }
  public typealias Pair<T> = (T, T)
  public typealias Titles = LayoutKit.SwitchableContainerBlock.Pair<LayoutKit.SwitchableContainerBlock.Title>
  public typealias Items = LayoutKit.SwitchableContainerBlock.Pair<LayoutKit.SwitchableContainerBlock.Item>
  final public let selectedItem: LayoutKit.SwitchableContainerBlock.Selection
  final public let items: LayoutKit.SwitchableContainerBlock.Items
  final public let backgroundColor: VGSLUI.Color
  final public let selectedBackgroundColor: VGSLUI.Color
  final public let titleGaps: CoreFoundation.CGFloat
  final public let titleContentGap: CoreFoundation.CGFloat
  final public let selectorSideGaps: CoreFoundation.CGFloat
  final public let switchAction: LayoutKitInterface.UserInterfaceAction?
  final public let path: LayoutKitInterface.UIElementPath
  public init(selectedItem: LayoutKit.SwitchableContainerBlock.Selection, items: LayoutKit.SwitchableContainerBlock.Items, backgroundColor: VGSLUI.Color, selectedBackgroundColor: VGSLUI.Color, titleGaps: CoreFoundation.CGFloat, titleContentGap: CoreFoundation.CGFloat, selectorSideGaps: CoreFoundation.CGFloat, switchAction: LayoutKitInterface.UserInterfaceAction?, path: LayoutKitInterface.UIElementPath)
  final public var isVerticallyResizable: Swift.Bool {
    get
  }
  final public var isHorizontallyResizable: Swift.Bool {
    get
  }
  final public let isVerticallyConstrained: Swift.Bool
  final public let isHorizontallyConstrained: Swift.Bool
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  final public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.SwitchableContainerBlock.Item : Swift.Equatable {
  public static func == (lhs: LayoutKit.SwitchableContainerBlock.Item, rhs: LayoutKit.SwitchableContainerBlock.Item) -> Swift.Bool
}
extension LayoutKit.SwitchableContainerBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.SwitchableContainerBlock, rhs: LayoutKit.SwitchableContainerBlock) -> Swift.Bool
}
extension LayoutKit.SwitchableContainerBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.SwitchableContainerBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.SwitchableContainerBlock
}
extension LayoutKit.SwitchableContainerBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.SwitchableContainerBlock
}
extension LayoutKit.SwitchableContainerBlock : LayoutKit.LayoutCaching {
  final public func laidOut(for width: CoreFoundation.CGFloat) -> any LayoutKit.Block
  final public func laidOut(for size: CoreFoundation.CGSize) -> any LayoutKit.Block
}
extension LayoutKit.SwitchableContainerBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public struct SwitchableContainerBlockState : LayoutKit.ElementState, Swift.Equatable {
  public let selectedItem: LayoutKit.SwitchableContainerBlock.Selection
  public init(selectedItem: LayoutKit.SwitchableContainerBlock.Selection)
  public static func == (a: LayoutKit.SwitchableContainerBlockState, b: LayoutKit.SwitchableContainerBlockState) -> Swift.Bool
}
final public class SwitchBlock : LayoutKit.Block {
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let on: LayoutKit.Binding<Swift.Bool>
  final public let enabled: Swift.Bool
  final public let action: LayoutKitInterface.UserInterfaceAction?
  final public let onTintColor: VGSLUI.Color?
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  public init(widthTrait: LayoutKit.LayoutTrait = .intrinsic, heightTrait: LayoutKit.LayoutTrait = .intrinsic, on: Swift.Bool, enabled: Swift.Bool, action: LayoutKitInterface.UserInterfaceAction?, onTintColor: VGSLUI.Color? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil)
  public init(widthTrait: LayoutKit.LayoutTrait = .intrinsic, heightTrait: LayoutKit.LayoutTrait = .intrinsic, on: LayoutKit.Binding<Swift.Bool>, enabled: Swift.Bool, action: LayoutKitInterface.UserInterfaceAction?, onTintColor: VGSLUI.Color? = nil, accessibilityElement: VGSLUI.AccessibilityElement? = nil)
  final public var isVerticallyResizable: Swift.Bool {
    get
  }
  final public var isHorizontallyResizable: Swift.Bool {
    get
  }
  final public let isVerticallyConstrained: Swift.Bool
  final public let isHorizontallyConstrained: Swift.Bool
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  final public func heightOfVerticallyNonResizableBlock(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  @objc deinit
}
public func == (lhs: LayoutKit.SwitchBlock, rhs: LayoutKit.SwitchBlock) -> Swift.Bool
extension LayoutKit.SwitchBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.SwitchBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.SwitchBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public enum TabbedPagesHeightMode : Swift.Equatable {
  case byHighestPage
  case bySelectedPage
  public static let `default`: LayoutKit.TabbedPagesHeightMode
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LayoutKit.TabbedPagesHeightMode, b: LayoutKit.TabbedPagesHeightMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class TabbedPagesView : LayoutKit.BlockView, VGSLUI.VisibleBoundsTrackingContainer {
  @_Concurrency.MainActor @preconcurrency final public let visibleBoundsTrackingSubviews: [any UIKit.UIView & VGSLUI.VisibleBoundsTracking]
  @_Concurrency.MainActor @preconcurrency final public var effectiveBackgroundColor: UIKit.UIColor? {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var layoutReporter: LayoutKit.LayoutReporter?
  @_Concurrency.MainActor @preconcurrency final public func configure(model: LayoutKit.TabViewModel, state: LayoutKit.TabViewState, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  @_Concurrency.MainActor @preconcurrency weak final public var updatesDelegate: (any LayoutKit.TabbedPagesViewModelDelegate)? {
    get
    set
  }
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @objc deinit
}
public protocol TabbedPagesViewModelDelegate : AnyObject {
  func onSelectedPageIndexChanged(_ index: CoreFoundation.CGFloat, inModel model: LayoutKit.TabContentsViewModel)
}
public struct TabContentsViewModel : Swift.Equatable {
  public let path: LayoutKitInterface.UIElementPath!
  public var pages: [LayoutKit.TabPageViewModel]
  public let pagesHeight: LayoutKit.TabbedPagesHeightMode
  public let background: LayoutKit.Background?
  public let footer: (any LayoutKit.Block)?
  public let scrollingEnabled: Swift.Bool
  public let contentInsets: LayoutKit.EdgeInsets
  public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  public init(pages: [LayoutKit.TabPageViewModel], pagesHeight: LayoutKit.TabbedPagesHeightMode, contentInsets: LayoutKit.EdgeInsets = .zero, path: LayoutKitInterface.UIElementPath? = nil, background: LayoutKit.Background? = nil, footer: (any LayoutKit.Block)? = nil, scrollingEnabled: Swift.Bool = true, layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight) throws
  public static func == (lhs: LayoutKit.TabContentsViewModel, rhs: LayoutKit.TabContentsViewModel) -> Swift.Bool
}
extension LayoutKit.TabContentsViewModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class TabListViewModel : Swift.Equatable {
  public static let defaultListPaddings: LayoutKit.EdgeInsets
  final public let tabTitles: [LayoutKit.UILink]
  final public let titleStyle: LayoutKit.TabTitleStyle
  final public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  final public let listPaddings: LayoutKit.EdgeInsets
  final public let delimiterStyle: LayoutKit.TabTitleDelimiterStyle?
  public init(tabTitles: [LayoutKit.UILink], titleStyle: LayoutKit.TabTitleStyle = TabTitleStyle(), layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, listPaddings: LayoutKit.EdgeInsets = defaultListPaddings, delimiterStyle: LayoutKit.TabTitleDelimiterStyle? = nil)
  convenience public init(tabTitleLinks: [LayoutKit.UILink], insets: LayoutKit.EdgeInsets = defaultListPaddings, staticAttributes: VGSLUI.Typo = TabTitleStyle.defaultTypo, baseColor: VGSLUI.Color = TabTitleStyle.defaultBaseTextColor, selectedColor: VGSLUI.Color = TabTitleStyle.defaultActiveTextColor, selectedBackgroundColor: VGSLUI.Color = TabTitleStyle.defaultActiveBackgroundColor, delimiterStyle: LayoutKit.TabTitleDelimiterStyle? = nil)
  public static func == (lhs: LayoutKit.TabListViewModel, rhs: LayoutKit.TabListViewModel) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.TabListViewModel : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class TabPageViewModel {
  final public let block: any LayoutKit.Block
  final public let path: LayoutKitInterface.UIElementPath
  @objc deinit
}
extension LayoutKit.Block {
  public func makeTabPage(with path: LayoutKitInterface.UIElementPath) -> LayoutKit.TabPageViewModel
}
extension LayoutKit.TabPageViewModel : Swift.Equatable {
  public static func == (lhs: LayoutKit.TabPageViewModel, rhs: LayoutKit.TabPageViewModel) -> Swift.Bool
}
public func === (lhs: [LayoutKit.TabPageViewModel], rhs: [LayoutKit.TabPageViewModel]) -> Swift.Bool
public func !== (lhs: [LayoutKit.TabPageViewModel], rhs: [LayoutKit.TabPageViewModel]) -> Swift.Bool
extension LayoutKit.TabPageViewModel : VGSLUI.ImageContaining {
  public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.TabPageViewModel : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class TabsBlock : LayoutKit.BlockWithTraits {
  final public let model: LayoutKit.TabViewModel
  final public let state: LayoutKit.TabViewState
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  public init(model: LayoutKit.TabViewModel, state: LayoutKit.TabViewState, widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic) throws
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.TabsBlock : Swift.Equatable {
  public static func == (lhs: LayoutKit.TabsBlock, rhs: LayoutKit.TabsBlock) -> Swift.Bool
}
extension LayoutKit.TabsBlock : VGSLUI.ImageContaining {
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
}
extension LayoutKit.TabsBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> LayoutKit.TabsBlock
}
extension LayoutKit.TabsBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.TabsBlock
}
extension LayoutKit.TabsBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.TabsBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public let tabChangedUrl: Foundation.URL
public struct TabSeparatorStyle : Swift.Equatable {
  public let color: VGSLUI.Color
  public let insets: LayoutKit.EdgeInsets
  public init(color: VGSLUI.Color = Color(red: 0, green: 0, blue: 0, alpha: 0.08), insets: LayoutKit.EdgeInsets = EdgeInsets(top: 0, left: 0, bottom: 16, right: 0))
  public static func == (a: LayoutKit.TabSeparatorStyle, b: LayoutKit.TabSeparatorStyle) -> Swift.Bool
}
extension LayoutKit.TabSeparatorStyle : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct TabTitleDelimiterStyle : Swift.Equatable {
  public let imageHolder: any VGSLUI.ImageHolder
  public let width: CoreFoundation.CGFloat
  public let height: CoreFoundation.CGFloat
  public init(imageHolder: any VGSLUI.ImageHolder, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  public static func == (lhs: LayoutKit.TabTitleDelimiterStyle, rhs: LayoutKit.TabTitleDelimiterStyle) -> Swift.Bool
}
public struct TabTitleStyle : Swift.Equatable {
  public static let defaultTypo: VGSLUI.Typo
  public static let defaultPaddings: LayoutKit.EdgeInsets
  public static let defaultActiveTextColor: VGSLUI.RGBAColor
  public static let defaultBaseTextColor: VGSLUI.RGBAColor
  public static let defaultActiveBackgroundColor: VGSLUI.RGBAColor
  public let typo: VGSLUI.Typo
  public let inactiveTypo: VGSLUI.Typo
  public let paddings: LayoutKit.EdgeInsets
  public let cornerRadius: LayoutKit.CornerRadii?
  public let baseTextColor: VGSLUI.Color
  public let activeTextColor: VGSLUI.Color
  public let activeBackgroundColor: VGSLUI.Color
  public let inactiveBackgroundColor: VGSLUI.Color
  public let itemSpacing: CoreFoundation.CGFloat?
  public init(typo: VGSLUI.Typo = defaultTypo, inactiveTypo: VGSLUI.Typo? = nil, paddings: LayoutKit.EdgeInsets = defaultPaddings, cornerRadius: LayoutKit.CornerRadii? = nil, baseTextColor: VGSLUI.Color = defaultBaseTextColor, activeTextColor: VGSLUI.Color = defaultActiveTextColor, activeBackgroundColor: VGSLUI.Color = defaultActiveBackgroundColor, inactiveBackgroundColor: VGSLUI.Color = .clear, itemSpacing: CoreFoundation.CGFloat? = nil)
  public static func == (lhs: LayoutKit.TabTitleStyle, rhs: LayoutKit.TabTitleStyle) -> Swift.Bool
}
extension LayoutKit.TabTitleStyle : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct TabViewLayout : Swift.Equatable {
  public let size: CoreFoundation.CGSize
  public let listFrame: CoreFoundation.CGRect
  public let contentsFrame: CoreFoundation.CGRect
  public let separatorFrame: CoreFoundation.CGRect
  public init(model: LayoutKit.TabViewModel, selectedPageIndex: CoreFoundation.CGFloat, width: CoreFoundation.CGFloat? = nil, height oldHeight: CoreFoundation.CGFloat? = nil)
  public init(model: LayoutKit.TabViewModel, selectedPageIndex: CoreFoundation.CGFloat, size: CoreFoundation.CGSize)
  public static func == (a: LayoutKit.TabViewLayout, b: LayoutKit.TabViewLayout) -> Swift.Bool
}
final public class TabViewModel : Swift.Equatable {
  final public let listModel: LayoutKit.TabListViewModel
  final public let contentsModel: LayoutKit.TabContentsViewModel
  final public let separatorStyle: LayoutKit.TabSeparatorStyle?
  final public let tabTitleDelimiter: LayoutKit.TabTitleDelimiterStyle?
  public init(listModel: LayoutKit.TabListViewModel, contentsModel: LayoutKit.TabContentsViewModel, separatorStyle: LayoutKit.TabSeparatorStyle? = nil, tabTitleDelimiter: LayoutKit.TabTitleDelimiterStyle? = nil) throws
  public static func == (lhs: LayoutKit.TabViewModel, rhs: LayoutKit.TabViewModel) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.TabViewModel : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
public struct TabViewState : LayoutKit.ElementState, Swift.Equatable {
  public let selectedPageIndex: CoreFoundation.CGFloat
  public let countOfPages: Swift.Int
  public static let `default`: LayoutKit.TabViewState
  public init(selectedPageIndex: CoreFoundation.CGFloat, countOfPages: Swift.Int)
  public static func == (a: LayoutKit.TabViewState, b: LayoutKit.TabViewState) -> Swift.Bool
}
public struct TextAnimation : Swift.Equatable {
  public let duration: Swift.Int
  public let repeatCount: Swift.Int?
  public let startDelay: Swift.Int
  public init(duration: Swift.Int, repeatCount: Swift.Int?, startDelay: Swift.Int)
  public static func == (a: LayoutKit.TextAnimation, b: LayoutKit.TextAnimation) -> Swift.Bool
}
final public class TextBlock : LayoutKit.BlockWithTraits {
  public struct InlineImage : Swift.Equatable {
    public let size: CoreFoundation.CGSize
    public let holder: any VGSLUI.ImageHolder
    public let location: Swift.Int
    public let tintColor: VGSLUI.Color?
    public let tintMode: VGSLUI.TintMode
    public init(size: CoreFoundation.CGSize, holder: any VGSLUI.ImageHolder, location: Swift.Int, tintColor: VGSLUI.Color? = nil, tintMode: VGSLUI.TintMode = .sourceIn)
  }
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let text: Foundation.NSAttributedString
  final public let textGradient: VGSLUI.Gradient?
  final public let verticalAlignment: VGSLUI.Alignment
  final public let maxIntrinsicNumberOfLines: Swift.Int
  final public let minNumberOfHiddenLines: Swift.Int
  final public let images: [LayoutKit.TextBlock.InlineImage]
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  final public let canSelect: Swift.Bool
  final public let tightenWidth: Swift.Bool
  final public let additionalTextInsets: LayoutKit.EdgeInsets
  final public let truncationToken: Foundation.NSAttributedString?
  final public let truncationImages: [LayoutKit.TextBlock.InlineImage]
  final public let autoEllipsize: Swift.Bool
  final public let path: LayoutKitInterface.UIElementPath?
  final public let isFocused: Swift.Bool
  public init(widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait = .intrinsic, text: Foundation.NSAttributedString, textGradient: VGSLUI.Gradient? = nil, verticalAlignment: VGSLUI.Alignment = .center, maxIntrinsicNumberOfLines: Swift.Int = .max, minNumberOfHiddenLines: Swift.Int = 0, images: [LayoutKit.TextBlock.InlineImage] = [], accessibilityElement: VGSLUI.AccessibilityElement?, truncationToken: Foundation.NSAttributedString? = nil, truncationImages: [LayoutKit.TextBlock.InlineImage] = [], additionalTextInsets: LayoutKit.EdgeInsets? = nil, canSelect: Swift.Bool = false, tightenWidth: Swift.Bool = false, autoEllipsize: Swift.Bool = true, path: LayoutKitInterface.UIElementPath? = nil, isFocused: Swift.Bool = false)
  convenience public init(widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait = .intrinsic, text: Foundation.NSAttributedString, textGradient: VGSLUI.Gradient? = nil, verticalAlignment: VGSLUI.Alignment = .center, maxIntrinsicNumberOfLines: Swift.Int = .max, minNumberOfHiddenLines: Swift.Int = 0, images: [LayoutKit.TextBlock.InlineImage] = [], truncationToken: Foundation.NSAttributedString? = nil, truncationImages: [LayoutKit.TextBlock.InlineImage] = [], additionalTextInsets: LayoutKit.EdgeInsets? = nil, canSelect: Swift.Bool = false, tightenWidth: Swift.Bool = false, autoEllipsize: Swift.Bool = true, path: LayoutKitInterface.UIElementPath? = nil, isFocused: Swift.Bool = false)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func ascent(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  public static func == (lhs: LayoutKit.TextBlock, rhs: LayoutKit.TextBlock) -> Swift.Bool
  final public func calculateTextIntrinsicContentHeight(for width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  @objc deinit
}
extension LayoutKit.TextBlock.InlineImage {
  public static func == (lhs: LayoutKit.TextBlock.InlineImage, rhs: LayoutKit.TextBlock.InlineImage) -> Swift.Bool
}
extension LayoutKit.TextBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.TextBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.TextBlock
}
extension LayoutKit.TextBlock {
  convenience public init?(copyingAttributesFrom block: LayoutKit.TextBlock, text: Swift.String)
}
extension LayoutKit.TextBlock : LayoutKit.ImageRenderableBlock {
  final public func drawInRect(_ rect: CoreFoundation.CGRect, context: CoreGraphics.CGContext)
}
extension LayoutKit.TextBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public struct TextBlockViewState : LayoutKit.ElementState, Swift.Equatable {
  public let text: Swift.String
  public init(text: Swift.String)
  public static func == (a: LayoutKit.TextBlockViewState, b: LayoutKit.TextBlockViewState) -> Swift.Bool
}
final public class TextFieldBlock : LayoutKit.Block {
  public struct SideControl : Swift.Equatable {
    public let image: VGSLUI.Image
    public let tintColor: VGSLUI.Color?
    public let action: LayoutKitInterface.UserInterfaceAction
    public let accessibilityElement: VGSLUI.AccessibilityElement?
    public init(image: VGSLUI.Image, tintColor: VGSLUI.Color? = nil, action: LayoutKitInterface.UserInterfaceAction, accessibilityElement: VGSLUI.AccessibilityElement? = nil)
  }
  public enum ToolbarType : Swift.Equatable {
    case `default`(LayoutKit.TextFieldBlock.Toolbar)
    case custom(any LayoutKit.Block)
  }
  public struct Toolbar : Swift.Equatable {
    public let doneButtonAction: LayoutKitInterface.UserInterfaceAction
    public init(doneButtonAction: LayoutKitInterface.UserInterfaceAction)
    public static func == (a: LayoutKit.TextFieldBlock.Toolbar, b: LayoutKit.TextFieldBlock.Toolbar) -> Swift.Bool
  }
  public enum Placeholders : Swift.Equatable {
    public struct Separate : Swift.Equatable {
      public struct AnimatableAttributes : Swift.Equatable {
        public let size: VGSLUI.FontSize
        public let height: VGSLUI.FontLineHeight
        public let color: VGSLUI.Color
        public init(size: VGSLUI.FontSize, height: VGSLUI.FontLineHeight, color: VGSLUI.Color)
      }
      public struct Field : Swift.Equatable {
        public enum Position {
          case normal
          case center
          public static func == (a: LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position, b: LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position) -> Swift.Bool
          public func hash(into hasher: inout Swift.Hasher)
          public var hashValue: Swift.Int {
            get
          }
        }
        public let attributes: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes
        public let position: LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position
        public init(attributes: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes, position: LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position)
        public static func == (a: LayoutKit.TextFieldBlock.Placeholders.Separate.Field, b: LayoutKit.TextFieldBlock.Placeholders.Separate.Field) -> Swift.Bool
      }
      public let text: Swift.String
      public let headerAttributes: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes
      public let gap: CoreFoundation.CGFloat
      public let field: LayoutKit.TextFieldBlock.Placeholders.Separate.Field
      public let fontWeight: VGSLUI.FontWeight
      public init(text: Swift.String, headerAttributes: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes, gap: CoreFoundation.CGFloat, field: LayoutKit.TextFieldBlock.Placeholders.Separate.Field, fontWeight: VGSLUI.FontWeight)
      public static func == (a: LayoutKit.TextFieldBlock.Placeholders.Separate, b: LayoutKit.TextFieldBlock.Placeholders.Separate) -> Swift.Bool
    }
    case separate(LayoutKit.TextFieldBlock.Placeholders.Separate)
    case fieldOnly(Foundation.NSAttributedString)
    public static func == (a: LayoutKit.TextFieldBlock.Placeholders, b: LayoutKit.TextFieldBlock.Placeholders) -> Swift.Bool
  }
  public enum TextAutocapitalizationType {
    case none
    case words
    case sentences
    case allCharacters
    public static func == (a: LayoutKit.TextFieldBlock.TextAutocapitalizationType, b: LayoutKit.TextFieldBlock.TextAutocapitalizationType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TextAutocorrectionType {
    case `default`
    case no
    case yes
    public static func == (a: LayoutKit.TextFieldBlock.TextAutocorrectionType, b: LayoutKit.TextFieldBlock.TextAutocorrectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum KeyboardType {
    case `default`
    case asciiCapable
    case numbersAndPunctuation
    case URL
    case numberPad
    case phonePad
    case namePhonePad
    case emailAddress
    case decimalPad
    case twitter
    case webSearch
    case asciiCapableNumberPad
    public static func == (a: LayoutKit.TextFieldBlock.KeyboardType, b: LayoutKit.TextFieldBlock.KeyboardType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Interaction : Swift.Equatable {
    case unchanged
    case enabled(isFirstResponder: Swift.Bool)
    case disabled
    public static func == (a: LayoutKit.TextFieldBlock.Interaction, b: LayoutKit.TextFieldBlock.Interaction) -> Swift.Bool
  }
  public static let defaultKeyboardAppearance: LayoutKit.TextFieldBlock.KeyboardAppearance
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let text: Foundation.NSAttributedString
  final public let placeholders: LayoutKit.TextFieldBlock.Placeholders?
  final public let backgroundColor: VGSLUI.Color
  final public let maxIntrinsicNumberOfLines: Swift.Int
  final public let keyboardAppearance: LayoutKit.TextFieldBlock.KeyboardAppearance
  final public let updateAction: LayoutKitInterface.UserInterfaceAction
  final public let returnButtonPressedAction: LayoutKitInterface.UserInterfaceAction?
  final public let didBeginEditingAction: LayoutKitInterface.UserInterfaceAction?
  final public let autocapitalizationType: LayoutKit.TextFieldBlock.TextAutocapitalizationType
  final public let autocorrectionType: LayoutKit.TextFieldBlock.TextAutocorrectionType
  final public let isSecureTextEntry: Swift.Bool
  final public let rightControl: LayoutKit.TextFieldBlock.SideControl?
  final public let toolbar: LayoutKit.TextFieldBlock.ToolbarType?
  final public let keyboardType: LayoutKit.TextFieldBlock.KeyboardType
  final public let interaction: LayoutKit.TextFieldBlock.Interaction
  final public let accessibilityElement: VGSLUI.AccessibilityElement?
  public init(widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, text: Foundation.NSAttributedString, placeholders: LayoutKit.TextFieldBlock.Placeholders? = nil, backgroundColor: VGSLUI.Color = .clear, keyboardAppearance: LayoutKit.TextFieldBlock.KeyboardAppearance = defaultKeyboardAppearance, updateAction: LayoutKitInterface.UserInterfaceAction, returnButtonPressedAction: LayoutKitInterface.UserInterfaceAction? = nil, didBeginEditingAction: LayoutKitInterface.UserInterfaceAction? = nil, autocapitalizationType: LayoutKit.TextFieldBlock.TextAutocapitalizationType = .none, autocorrectionType: LayoutKit.TextFieldBlock.TextAutocorrectionType = .no, isSecureTextEntry: Swift.Bool = false, rightControl: LayoutKit.TextFieldBlock.SideControl? = nil, toolbar: LayoutKit.TextFieldBlock.ToolbarType? = nil, keyboardType: LayoutKit.TextFieldBlock.KeyboardType = .default, interaction: LayoutKit.TextFieldBlock.Interaction = .unchanged, accessibilityElement: VGSLUI.AccessibilityElement? = nil)
  final public var isVerticallyResizable: Swift.Bool {
    get
  }
  final public var isHorizontallyResizable: Swift.Bool {
    get
  }
  final public var isVerticallyConstrained: Swift.Bool {
    get
  }
  final public var isHorizontallyConstrained: Swift.Bool {
    get
  }
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var widthOfHorizontallyNonResizableBlock: CoreFoundation.CGFloat {
    get
  }
  final public func heightOfVerticallyNonResizableBlock(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var weightOfVerticallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public var weightOfHorizontallyResizableBlock: LayoutKit.LayoutTrait.Weight {
    get
  }
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  public enum KeyboardAppearance {
    case `default`
    case light
    case dark
    public static func == (a: LayoutKit.TextFieldBlock.KeyboardAppearance, b: LayoutKit.TextFieldBlock.KeyboardAppearance) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  @objc deinit
}
extension LayoutKit.TextFieldBlock {
  public static func == (lhs: LayoutKit.TextFieldBlock, rhs: LayoutKit.TextFieldBlock) -> Swift.Bool
}
extension LayoutKit.TextFieldBlock.SideControl {
  public static func == (lhs: LayoutKit.TextFieldBlock.SideControl, rhs: LayoutKit.TextFieldBlock.SideControl) -> Swift.Bool
}
extension LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes {
  public static func == (lhs: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes, rhs: LayoutKit.TextFieldBlock.Placeholders.Separate.AnimatableAttributes) -> Swift.Bool
}
extension LayoutKit.TextFieldBlock.ToolbarType {
  public static func == (lhs: LayoutKit.TextFieldBlock.ToolbarType, rhs: LayoutKit.TextFieldBlock.ToolbarType) -> Swift.Bool
}
extension LayoutKit.TextFieldBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.TextFieldBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.TextFieldBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.TextFieldBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
public typealias TextInputFilter = (Swift.String) -> Swift.Bool
final public class TextInputBlock : LayoutKit.BlockWithTraits {
  public enum InputType : Swift.Equatable {
    public enum KeyboardType : Swift.Equatable {
      case `default`
      case URL
      case phonePad
      case namePhonePad
      case emailAddress
      case decimalPad
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: LayoutKit.TextInputBlock.InputType.KeyboardType, b: LayoutKit.TextInputBlock.InputType.KeyboardType) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct SelectionItem : Swift.Equatable {
      public let value: Swift.String
      public let text: Swift.String
      public init(value: Swift.String, text: Swift.String)
      public static func == (a: LayoutKit.TextInputBlock.InputType.SelectionItem, b: LayoutKit.TextInputBlock.InputType.SelectionItem) -> Swift.Bool
    }
    case keyboard(LayoutKit.TextInputBlock.InputType.KeyboardType)
    case selection([LayoutKit.TextInputBlock.InputType.SelectionItem])
    public static let `default`: LayoutKit.TextInputBlock.InputType
    public static func == (a: LayoutKit.TextInputBlock.InputType, b: LayoutKit.TextInputBlock.InputType) -> Swift.Bool
  }
  public enum AutocapitalizationType {
    case none
    case words
    case sentences
    case allCharacters
    public static func == (a: LayoutKit.TextInputBlock.AutocapitalizationType, b: LayoutKit.TextInputBlock.AutocapitalizationType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TextAlignmentHorizontal : Swift.Equatable {
    case left
    case center
    case right
    case start
    case end
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LayoutKit.TextInputBlock.TextAlignmentHorizontal, b: LayoutKit.TextInputBlock.TextAlignmentHorizontal) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TextAlignmentVertical : Swift.Equatable {
    case top
    case center
    case bottom
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LayoutKit.TextInputBlock.TextAlignmentVertical, b: LayoutKit.TextInputBlock.TextAlignmentVertical) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum EnterKeyType : Swift.Equatable {
    case `default`
    case go
    case search
    case send
    case done
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: LayoutKit.TextInputBlock.EnterKeyType, b: LayoutKit.TextInputBlock.EnterKeyType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let hint: Foundation.NSAttributedString
  final public let textValue: LayoutKit.Binding<Swift.String>
  final public let rawTextValue: LayoutKit.Binding<Swift.String>?
  final public let textTypo: VGSLUI.Typo
  final public let multiLineMode: Swift.Bool
  final public let inputType: LayoutKit.TextInputBlock.InputType
  final public var accessoryView: LayoutKit.ViewType?
  final public let autocapitalizationType: LayoutKit.TextInputBlock.AutocapitalizationType
  final public let enterKeyType: LayoutKit.TextInputBlock.EnterKeyType
  final public let highlightColor: VGSLUI.Color?
  final public let maxVisibleLines: Swift.Int?
  final public let selectAllOnFocus: Swift.Bool
  final public let maskValidator: LayoutKit.MaskValidator?
  final public let path: LayoutKitInterface.UIElementPath
  final public let isFocused: Swift.Bool
  final public let onFocusActions: [LayoutKitInterface.UserInterfaceAction]
  final public let onBlurActions: [LayoutKitInterface.UserInterfaceAction]
  final public let enterKeyActions: [LayoutKitInterface.UserInterfaceAction]
  final public let textAlignmentHorizontal: LayoutKit.TextInputBlock.TextAlignmentHorizontal
  final public let textAlignmentVertical: LayoutKit.TextInputBlock.TextAlignmentVertical
  weak final public var parentScrollView: (any UIKit.UIView & VGSLUI.ScrollViewType)?
  final public let filters: [LayoutKit.TextInputFilter]?
  final public let validators: [LayoutKit.TextInputValidator]?
  final public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  final public let paddings: LayoutKit.EdgeInsets?
  final public let isEnabled: Swift.Bool
  final public let maxLength: Swift.Int?
  final public let autocorrection: Swift.Bool
  final public let isSecure: Swift.Bool
  final public let enablesReturnKeyAutomatically: Swift.Bool
  final public let spellChecking: Swift.Bool?
  public init(widthTrait: LayoutKit.LayoutTrait = .resizable, heightTrait: LayoutKit.LayoutTrait = .intrinsic, hint: Foundation.NSAttributedString, textValue: LayoutKit.Binding<Swift.String>, rawTextValue: LayoutKit.Binding<Swift.String>? = nil, textTypo: VGSLUI.Typo, multiLineMode: Swift.Bool = true, inputType: LayoutKit.TextInputBlock.InputType = .default, accessoryView: LayoutKit.ViewType? = nil, autocapitalizationType: LayoutKit.TextInputBlock.AutocapitalizationType = .sentences, enterKeyType: LayoutKit.TextInputBlock.EnterKeyType = .default, highlightColor: VGSLUI.Color? = nil, maxVisibleLines: Swift.Int? = nil, selectAllOnFocus: Swift.Bool = false, maskValidator: LayoutKit.MaskValidator? = nil, path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool = false, onFocusActions: [LayoutKitInterface.UserInterfaceAction] = [], onBlurActions: [LayoutKitInterface.UserInterfaceAction] = [], enterKeyActions: [LayoutKitInterface.UserInterfaceAction] = [], parentScrollView: (any UIKit.UIView & VGSLUI.ScrollViewType)? = nil, filters: [LayoutKit.TextInputFilter]? = nil, validators: [LayoutKit.TextInputValidator]? = nil, layoutDirection: VGSLUI.UserInterfaceLayoutDirection, textAlignmentHorizontal: LayoutKit.TextInputBlock.TextAlignmentHorizontal = .start, textAlignmentVertical: LayoutKit.TextInputBlock.TextAlignmentVertical = .center, paddings: LayoutKit.EdgeInsets? = nil, isEnabled: Swift.Bool = true, maxLength: Swift.Int? = nil, shouldClearFocus: VGSLFundamentals.Variable<Swift.Bool> = .constant(true), autocorrection: Swift.Bool = false, isSecure: Swift.Bool = false, enablesReturnKeyAutomatically: Swift.Bool = false, spellChecking: Swift.Bool? = nil)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  @objc deinit
}
extension LayoutKit.TextInputBlock {
  public static func == (lhs: LayoutKit.TextInputBlock, rhs: LayoutKit.TextInputBlock) -> Swift.Bool
}
extension LayoutKit.TextInputBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.TextInputBlock : LayoutKit.ElementStateUpdatingDefaultImpl {
}
extension LayoutKit.TextInputBlock : LayoutKit.ElementFocusUpdating {
  final public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> LayoutKit.TextInputBlock
}
extension LayoutKit.TextInputBlock {
  final public func modifying(widthTrait: LayoutKit.LayoutTrait? = nil, heightTrait: LayoutKit.LayoutTrait? = nil, hint: Foundation.NSAttributedString? = nil, textValue: LayoutKit.Binding<Swift.String>? = nil, rawTextValue: LayoutKit.Binding<Swift.String>? = nil, textTypo: VGSLUI.Typo? = nil, multiLineMode: Swift.Bool? = nil, inputType: LayoutKit.TextInputBlock.InputType? = nil, accessoryView: LayoutKit.ViewType? = nil, autocapitalizationType: LayoutKit.TextInputBlock.AutocapitalizationType? = nil, enterKeyType: LayoutKit.TextInputBlock.EnterKeyType? = nil, highlightColor: VGSLUI.Color? = nil, maxVisibleLines: Swift.Int? = nil, selectAllOnFocus: Swift.Bool? = nil, maskValidator: LayoutKit.MaskValidator? = nil, path: LayoutKitInterface.UIElementPath? = nil, isFocused: Swift.Bool? = nil, onFocusActions: [LayoutKitInterface.UserInterfaceAction]? = nil, onBlurActions: [LayoutKitInterface.UserInterfaceAction]? = nil, enterKeyActions: [LayoutKitInterface.UserInterfaceAction]? = nil, parentScrollView: (any UIKit.UIView & VGSLUI.ScrollViewType)? = nil, filters: [LayoutKit.TextInputFilter]? = nil, validators: [LayoutKit.TextInputValidator]? = nil, layoutDirection: VGSLUI.UserInterfaceLayoutDirection? = nil, textAlignmentHorizontal: LayoutKit.TextInputBlock.TextAlignmentHorizontal? = nil, textAlignmentVertical: LayoutKit.TextInputBlock.TextAlignmentVertical? = nil, paddings: LayoutKit.EdgeInsets? = nil, isEnabled: Swift.Bool? = nil, maxLength: Swift.Int? = nil, shouldClearFocus: VGSLFundamentals.Variable<Swift.Bool>? = nil, autocorrection: Swift.Bool? = nil, isSecure: Swift.Bool? = nil, enablesReturnKeyAutomatically: Swift.Bool? = nil, spellChecking: Swift.Bool? = nil) -> LayoutKit.TextInputBlock
}
extension LayoutKit.TextInputBlock : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension LayoutKit.TextInputBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
final public class TextInputValidator {
  final public let message: () -> Swift.String?
  final public var isValid: LayoutKit.Binding<Swift.Bool>
  public init(isValid: LayoutKit.Binding<Swift.Bool>, allowEmpty: Swift.Bool, validator: @escaping (Swift.String) -> Swift.Bool, message: @escaping () -> Swift.String?)
  final public func validate(_ text: Swift.String) -> Swift.Bool
  @objc deinit
}
public enum TimingFunction {
  case linear, easeIn, easeOut, easeInEaseOut
  public static func == (a: LayoutKit.TimingFunction, b: LayoutKit.TimingFunction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TooltipAnchorView : UIKit.UIView {
  var tooltips: [LayoutKit.BlockTooltip] { get }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class TooltipContainerView : UIKit.UIView, LayoutKit.UIActionEventPerforming {
  @_Concurrency.MainActor @preconcurrency public init(tooltip: LayoutKit.DefaultTooltipManager.Tooltip, handleAction: @escaping (LayoutKit.UIActionEvent) -> Swift.Void, onCloseAction: @escaping VGSLFundamentals.Action)
  @_Concurrency.MainActor @preconcurrency @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency final public func perform(uiActionEvent event: LayoutKit.UIActionEvent, from _: Swift.AnyObject)
  @_Concurrency.MainActor @preconcurrency final public func close(animated: Swift.Bool)
  @objc deinit
}
public protocol TooltipEventPerforming {
  func perform(tooltipEvent event: LayoutKit.TooltipEvent, from sender: Swift.AnyObject)
}
final public class TooltipEvent : LayoutKit.AppActionEventProtocol {
  final public let tooltipView: any UIKit.UIView & VGSLUI.VisibleBoundsTracking
  weak final public var tooltipAnchorView: LayoutKit.ViewType? {
    get
  }
  final public let info: LayoutKit.TooltipInfo
  final public let params: LayoutKit.BlockTooltipParams
  public init(info: LayoutKit.TooltipInfo, params: LayoutKit.BlockTooltipParams, tooltipView: any UIKit.UIView & VGSLUI.VisibleBoundsTracking, tooltipAnchorView: LayoutKit.ViewType?)
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.TooltipEvent.Handler?
  @objc deinit
}
public enum TooltipFactory {
  public static func makeTooltip(text: Swift.String, position: LayoutKit.BlockTooltip.Position, width: CoreFoundation.CGFloat? = nil, theme: VGSLUI.Theme = .light) -> any LayoutKit.Block
}
public struct TooltipInfo : Swift.Equatable {
  public let id: Swift.String
  public let showsOnStart: Swift.Bool
  public let multiple: Swift.Bool
  public init(id: Swift.String, showsOnStart: Swift.Bool, multiple: Swift.Bool)
  public static func == (a: LayoutKit.TooltipInfo, b: LayoutKit.TooltipInfo) -> Swift.Bool
}
public protocol TooltipActionPerformer {
  func showTooltip(info: LayoutKit.TooltipInfo)
  func hideTooltip(id: Swift.String)
}
public protocol TooltipManager : LayoutKit.RenderingDelegate, LayoutKit.TooltipActionPerformer {
  func tooltipAnchorViewAdded(anchorView: any LayoutKit.TooltipAnchorView)
  func tooltipAnchorViewRemoved(anchorView: any LayoutKit.TooltipAnchorView)
  func reset()
  func setHandler(_ handler: @escaping (LayoutKit.UIActionEvent) -> Swift.Void)
}
extension LayoutKit.TooltipManager {
  public func setHandler(_: @escaping (LayoutKit.UIActionEvent) -> Swift.Void)
}
public class DefaultTooltipManager : LayoutKit.TooltipManager {
  public struct Tooltip {
    public let params: LayoutKit.BlockTooltipParams
    public let view: any UIKit.UIView & VGSLUI.VisibleBoundsTracking
  }
  public var shownTooltips: VGSLFundamentals.Property<Swift.Set<Swift.String>>
  public init(shownTooltips: VGSLFundamentals.Property<Swift.Set<Swift.String>> = Property(), handleAction: @escaping (LayoutKit.UIActionEvent) -> Swift.Void = { _ in })
  public func showTooltip(info: LayoutKit.TooltipInfo)
  public func hideTooltip(id: Swift.String)
  public func tooltipAnchorViewAdded(anchorView: any LayoutKit.TooltipAnchorView)
  public func tooltipAnchorViewRemoved(anchorView: any LayoutKit.TooltipAnchorView)
  public func reset()
  public func setHandler(_ handler: @escaping (LayoutKit.UIActionEvent) -> Swift.Void)
  @objc deinit
}
extension LayoutKit.TooltipManager {
  public func mapView(_: any UIKit.UIView & LayoutKit.BlockViewProtocol, to _: LayoutKit.BlockViewID)
  public func reset()
}
public protocol TooltipProtocol {
  func makeTooltipEvent(with info: LayoutKit.TooltipInfo) -> LayoutKit.TooltipEvent?
}
public func makeTooltip(with info: LayoutKit.TooltipInfo, rootView: UIKit.UIView) -> LayoutKit.TooltipEvent?
public struct TransitioningAnimation : Swift.Equatable {
  @frozen public enum Kind : Swift.String, Swift.Equatable, Swift.CaseIterable {
    case fade
    case scaleXY
    case translationX
    case translationY
    public init?(rawValue: Swift.String)
    public typealias AllCases = [LayoutKit.TransitioningAnimation.Kind]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [LayoutKit.TransitioningAnimation.Kind] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let kind: LayoutKit.TransitioningAnimation.Kind
  public let start: Swift.Double
  public let end: Swift.Double
  public let duration: Foundation.TimeInterval
  public let delay: Foundation.TimeInterval
  public let timingFunction: LayoutKit.TimingFunction
  public static let empty: LayoutKit.TransitioningAnimation
  public static let defaultLeadingSlideDistance: Swift.Double
  public static let defaultTrailingSlideDistance: Swift.Double
  public init(kind: LayoutKit.TransitioningAnimation.Kind, start: Swift.Double, end: Swift.Double, duration: Foundation.TimeInterval, delay: Foundation.TimeInterval, timingFunction: LayoutKit.TimingFunction)
  public static func == (a: LayoutKit.TransitioningAnimation, b: LayoutKit.TransitioningAnimation) -> Swift.Bool
}
final public class TransitioningBlock : LayoutKit.WrapperBlock {
  public typealias Layout = CoreFoundation.CGRect
  final public let from: (any LayoutKit.Block)?
  final public let to: any LayoutKit.Block
  final public let animationOut: [LayoutKit.TransitioningAnimation]?
  final public let animationIn: [LayoutKit.TransitioningAnimation]?
  final public var child: any LayoutKit.Block {
    get
  }
  public init(from: (any LayoutKit.Block)?, to: any LayoutKit.Block, animationOut: [LayoutKit.TransitioningAnimation]?, animationIn: [LayoutKit.TransitioningAnimation]?)
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public func makeCopy(wrapping block: any LayoutKit.Block) -> Self
  public static func == (lhs: LayoutKit.TransitioningBlock, rhs: LayoutKit.TransitioningBlock) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.TransitioningBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, with layout: LayoutKit.TransitioningBlock.Layout?, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
}
public typealias EdgeInsets = VGSLUI.EdgeInsets
public protocol UIActionEventPerforming {
  func perform(uiActionEvent event: LayoutKit.UIActionEvent, from sender: Swift.AnyObject)
}
extension LayoutKit.UIActionEventPerforming {
  public func perform(uiActionEvents events: [LayoutKit.UIActionEvent], from sender: Swift.AnyObject)
}
final public class UIActionEvent : LayoutKit.AppActionEventProtocol {
  final public let originalSender: UIKit.UIResponder
  final public let uiAction: LayoutKitInterface.UserInterfaceAction
  public init(uiAction: LayoutKitInterface.UserInterfaceAction, originalSender: UIKit.UIResponder)
  final public var payload: LayoutKitInterface.UserInterfaceAction.Payload {
    get
  }
  final public func makeHandler(responder: UIKit.UIResponder) -> LayoutKit.UIActionEvent.Handler?
  @objc deinit
}
extension Swift.Array : LayoutKit.AppActionEventProtocol where Element == LayoutKit.UIActionEvent {
  public func makeHandler(responder: UIKit.UIResponder) -> Swift.Array<Element>.Handler?
}
extension Swift.Array where Element == LayoutKit.UIActionEvent {
  public func handlingURLPayload(handleEvent: @escaping (LayoutKit.UIActionEvent, _ isLast: Swift.Bool) -> Swift.Void) -> [LayoutKit.UIActionEvent]
}
final public class UIActionEventPerformingAdapter<HandledType> : LayoutKit.UIActionEventPerforming {
  public typealias Transform = (LayoutKit.UIActionEvent) -> HandledType?
  public typealias Handler = (HandledType) -> Swift.Void
  public init(transform: @escaping LayoutKit.UIActionEventPerformingAdapter<HandledType>.Transform, handler: @escaping LayoutKit.UIActionEventPerformingAdapter<HandledType>.Handler)
  final public func perform(uiActionEvent event: LayoutKit.UIActionEvent, from sender: Swift.AnyObject)
  @objc deinit
}
extension LayoutKitInterface.UserInterfaceAction {
  public typealias ResponderType = UIKit.UIResponder
  public func perform(sendingFrom sender: LayoutKitInterface.UserInterfaceAction.ResponderType)
  public func performLongPress(sendingFrom sender: LayoutKitInterface.UserInterfaceAction.ResponderType)
}
extension Swift.Array where Element == LayoutKitInterface.UserInterfaceAction {
  public func perform(sendingFrom sender: LayoutKitInterface.UserInterfaceAction.ResponderType)
}
public struct UILink : Swift.Equatable {
  public let text: Swift.String
  public let path: LayoutKitInterface.UIElementPath
  public let url: Foundation.URL?
  public init(text: Swift.String, url: Foundation.URL? = nil, path: LayoutKitInterface.UIElementPath)
  public init(text: Swift.String, action: LayoutKitInterface.UserInterfaceAction)
  public static func == (a: LayoutKit.UILink, b: LayoutKit.UILink) -> Swift.Bool
}
extension LayoutKit.UILink {
  public var action: LayoutKitInterface.UserInterfaceAction? {
    get
  }
}
extension LayoutKit.UILink : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func removeFrom(_ view: UIKit.UIView)
}
public protocol UIViewRenderable : LayoutKit.PathIdentifiable {
  static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?)
  func isBestViewForReuse(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
}
extension LayoutKit.UIViewRenderable {
  public func makeBlockView(observer: (any LayoutKit.ElementStateObserver)? = nil, overscrollDelegate: (any VGSLUI.ScrollDelegate)? = nil, renderingDelegate: (any LayoutKit.RenderingDelegate)? = nil) -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  public func isBestViewForReuse(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol)
  public func reuse(_ view: (any UIKit.UIView & LayoutKit.BlockViewProtocol)?, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate: (any VGSLUI.ScrollDelegate)?, renderingDelegate: (any LayoutKit.RenderingDelegate)?, superview: UIKit.UIView?, subviewPosition: LayoutKit.SubviewPosition = .trailing) -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  public func reusePreservingSuperview(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)? = nil, overscrollDelegate: (any VGSLUI.ScrollDelegate)? = nil, renderingDelegate: (any LayoutKit.RenderingDelegate)? = nil) -> any UIKit.UIView & LayoutKit.BlockViewProtocol
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == any LayoutKit.UIViewRenderable {
  public func reuse(_ view: (any UIKit.UIView & LayoutKit.BlockViewProtocol)?, observer: (any LayoutKit.ElementStateObserver)? = nil, overscrollDelegate: (any VGSLUI.ScrollDelegate)? = nil, renderingDelegate: (any LayoutKit.RenderingDelegate)? = nil, superview: UIKit.UIView) -> (any UIKit.UIView & LayoutKit.BlockViewProtocol)?
}
#else
extension Swift.Optional where Wrapped == any LayoutKit.UIViewRenderable {
  public func reuse(_ view: (any UIKit.UIView & LayoutKit.BlockViewProtocol)?, observer: (any LayoutKit.ElementStateObserver)? = nil, overscrollDelegate: (any VGSLUI.ScrollDelegate)? = nil, renderingDelegate: (any LayoutKit.RenderingDelegate)? = nil, superview: UIKit.UIView) -> (any UIKit.UIView & LayoutKit.BlockViewProtocol)?
}
#endif
public enum SubviewPosition {
  case trailing
  case index(Swift.Int)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class URLActionHandlingView : UIKit.UIView, LayoutKit.UIActionEventPerforming {
  @_Concurrency.MainActor @preconcurrency public init(handler: @escaping VGSLFundamentals.UrlOpener)
  @_Concurrency.MainActor @preconcurrency final public func perform(uiActionEvent event: LayoutKit.UIActionEvent, from _: Swift.AnyObject)
  @objc deinit
}
final public class VideoBlock : LayoutKit.BlockWithTraits {
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  final public let model: LayoutKit.VideoBlockViewModel
  final public let state: LayoutKit.VideoBlockViewState
  final public let playerFactory: any LayoutKit.PlayerFactory
  final public var path: LayoutKitInterface.UIElementPath? {
    get
  }
  public init(widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait, model: LayoutKit.VideoBlockViewModel, state: LayoutKit.VideoBlockViewState, playerFactory: any LayoutKit.PlayerFactory)
  final public var intrinsicContentWidth: CoreFoundation.CGFloat {
    get
  }
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  final public var debugDescription: Swift.String
  @objc deinit
}
extension LayoutKit.VideoBlock : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.VideoBlock : LayoutKit.ElementStateUpdating {
  final public func updated(withStates states: LayoutKit.BlocksState) throws -> Self
}
extension LayoutKit.VideoBlock {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
}
final public class VideoBlockLegacy : LayoutKit.BlockWithTraits {
  public struct VideoAssetHolder {
    public init(url: Foundation.URL, playerItem: VGSLFundamentals.Future<AVFoundation.AVPlayerItem>)
  }
  final public var debugDescription: Swift.String {
    get
  }
  final public let videoAssetHolder: LayoutKit.VideoBlockLegacy.VideoAssetHolder
  final public let widthTrait: LayoutKit.LayoutTrait
  final public let heightTrait: LayoutKit.LayoutTrait
  public init(videoAssetHolder: LayoutKit.VideoBlockLegacy.VideoAssetHolder, widthTrait: LayoutKit.LayoutTrait, heightTrait: LayoutKit.LayoutTrait, autoplayAllowed: VGSLFundamentals.ObservableVariable<Swift.Bool>)
  final public let intrinsicContentWidth: CoreFoundation.CGFloat
  final public func intrinsicContentHeight(forWidth _: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public func getImageHolders() -> [any VGSLUI.ImageHolder]
  final public func equals(_ other: any LayoutKit.Block) -> Swift.Bool
  @objc deinit
}
extension LayoutKit.VideoBlockLegacy : LayoutKit.LayoutCachingDefaultImpl {
}
extension LayoutKit.VideoBlockLegacy : LayoutKit.ElementStateUpdatingDefaultImpl {
}
public func == (rhs: LayoutKit.VideoBlockLegacy, lhs: LayoutKit.VideoBlockLegacy) -> Swift.Bool
extension LayoutKit.VideoBlockLegacy {
  public static func makeBlockView() -> any UIKit.UIView & LayoutKit.BlockViewProtocol
  final public func canConfigureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol) -> Swift.Bool
  final public func configureBlockView(_ view: any UIKit.UIView & LayoutKit.BlockViewProtocol, observer _: (any LayoutKit.ElementStateObserver)?, overscrollDelegate _: (any VGSLUI.ScrollDelegate)?, renderingDelegate _: (any LayoutKit.RenderingDelegate)?)
}
public struct VideoBlockViewModel : Swift.Equatable {
  public let videoData: LayoutKit.VideoData
  public let playbackConfig: LayoutKit.PlaybackConfig
  public var elapsedTime: LayoutKit.Binding<Swift.Int>?
  public var duration: LayoutKit.Binding<Swift.Int>?
  public let preview: VGSLUI.Image?
  public let resumeActions: [LayoutKitInterface.UserInterfaceAction]
  public let pauseActions: [LayoutKitInterface.UserInterfaceAction]
  public let bufferingActions: [LayoutKitInterface.UserInterfaceAction]
  public let endActions: [LayoutKitInterface.UserInterfaceAction]
  public let fatalActions: [LayoutKitInterface.UserInterfaceAction]
  public let path: LayoutKitInterface.UIElementPath
  public let scale: LayoutKit.VideoScale
  public init(videoData: LayoutKit.VideoData, playbackConfig: LayoutKit.PlaybackConfig, preview: VGSLUI.Image? = nil, elapsedTime: LayoutKit.Binding<Swift.Int>? = nil, duration: LayoutKit.Binding<Swift.Int>? = nil, resumeActions: [LayoutKitInterface.UserInterfaceAction] = [], pauseActions: [LayoutKitInterface.UserInterfaceAction] = [], bufferingActions: [LayoutKitInterface.UserInterfaceAction] = [], endActions: [LayoutKitInterface.UserInterfaceAction] = [], fatalActions: [LayoutKitInterface.UserInterfaceAction] = [], path: LayoutKitInterface.UIElementPath, scale: LayoutKit.VideoScale = .fit)
  public static func == (lhs: LayoutKit.VideoBlockViewModel, rhs: LayoutKit.VideoBlockViewModel) -> Swift.Bool
}
public struct VideoBlockViewState : LayoutKit.ElementState, Swift.Equatable {
  public enum State {
    case paused
    case playing
    public static func == (a: LayoutKit.VideoBlockViewState.State, b: LayoutKit.VideoBlockViewState.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let state: LayoutKit.VideoBlockViewState.State
  public init(state: LayoutKit.VideoBlockViewState.State)
  public static func == (a: LayoutKit.VideoBlockViewState, b: LayoutKit.VideoBlockViewState) -> Swift.Bool
}
public struct VideoData : Swift.Equatable {
  public let videos: [LayoutKit.Video]
  public init(videos: [LayoutKit.Video] = [])
  public static func == (a: LayoutKit.VideoData, b: LayoutKit.VideoData) -> Swift.Bool
}
public struct Video : Swift.Equatable {
  public let url: Foundation.URL
  public let resolution: CoreFoundation.CGSize?
  public let bitrate: Swift.Double?
  public let mimeType: Swift.String
  public init(url: Foundation.URL, resolution: CoreFoundation.CGSize? = nil, bitrate: Swift.Double? = nil, mimeType: Swift.String? = nil)
  public static func == (a: LayoutKit.Video, b: LayoutKit.Video) -> Swift.Bool
}
public enum VideoScale {
  case fill
  case noScale
  case fit
  public static func == (a: LayoutKit.VideoScale, b: LayoutKit.VideoScale) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias ViewType = UIKit.UIView
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class ViewWithShadow : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public var contentView: UIKit.UIView {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shadow: LayoutKit.BlockShadow? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @available(*, unavailable)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder _: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
public enum Visibility {
  case visible
  case notVisible
  public static func == (a: LayoutKit.Visibility, b: LayoutKit.Visibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LayoutKit.Visibility {
  public var isVisible: Swift.Bool {
    get
  }
}
public struct VisibilityAction {
  public let logId: Swift.String?
  public init(logId: Swift.String? = nil, uiAction: LayoutKitInterface.UserInterfaceAction, requiredDuration: Foundation.TimeInterval, targetPercentage: Swift.Int, limiter: LayoutKit.ActionLimiter, actionType: LayoutKit.VisibilityActionType)
}
extension LayoutKit.VisibilityAction : Swift.Equatable {
  public static func == (lhs: LayoutKit.VisibilityAction, rhs: LayoutKit.VisibilityAction) -> Swift.Bool
}
public enum VisibilityActionType : Swift.String {
  case appear
  case disappear
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VisibilityParams : Swift.Equatable {
  public let actions: [LayoutKit.VisibilityAction]
  public let isVisible: Swift.Bool
  public let lastVisibleArea: VGSLFundamentals.Property<Swift.Int>
  public let scheduler: any VGSLFundamentals.Scheduling
  public init(actions: [LayoutKit.VisibilityAction], isVisible: Swift.Bool, lastVisibleArea: VGSLFundamentals.Property<Swift.Int>, scheduler: any VGSLFundamentals.Scheduling)
  public static func == (lhs: LayoutKit.VisibilityParams, rhs: LayoutKit.VisibilityParams) -> Swift.Bool
}
public struct VisibilityState : Swift.Equatable {
  public var maximumVisibleSize: CoreFoundation.CGSize
  public var visibleFrame: CoreFoundation.CGRect
  public init(visibleFrame: CoreFoundation.CGRect)
  public init(maximumVisibleSize: CoreFoundation.CGSize, visibleFrame: CoreFoundation.CGRect)
  public mutating func formIntersection(with visibleBounds: CoreFoundation.CGRect)
  public func intersected(with visibleBounds: CoreFoundation.CGRect) -> LayoutKit.VisibilityState
  public var visibility: CoreFoundation.CGFloat {
    get
  }
  public static func == (a: LayoutKit.VisibilityState, b: LayoutKit.VisibilityState) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class VisibleBoundsTrackingCollectionView : LayoutKit.NoContentTouchDelaysCollectionView, VGSLUI.VisibleBoundsTrackingContainer {
  @_Concurrency.MainActor @preconcurrency final public var visibleBoundsTrackingSubviews: [any UIKit.UIView & VGSLUI.VisibleBoundsTracking] {
    get
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect, collectionViewLayout layout: UIKit.UICollectionViewLayout)
  @objc deinit
}
extension LayoutKit.VisibleBoundsTrackingCollectionView : VGSLUI.VisibleBoundsTracking {
  @_Concurrency.MainActor @preconcurrency final public func onVisibleBoundsChanged(from: CoreFoundation.CGRect, to: CoreFoundation.CGRect)
}
public protocol WrapperBlock : LayoutKit.SizeForwardingBlock {
  var child: any LayoutKit.Block { get }
  func makeCopy(wrapping: any LayoutKit.Block) -> Self
}
extension LayoutKit.WrapperBlock {
  public var sizeProvider: any LayoutKit.Block {
    get
  }
  public var reuseId: Swift.String {
    get
  }
  public func getImageHolders() -> [any VGSLUI.ImageHolder]
  public func updated(withStates states: LayoutKit.BlocksState) throws -> Self
  public func updated(path: LayoutKitInterface.UIElementPath, isFocused: Swift.Bool) throws -> Self
}
extension LayoutKit.AnalyticsTouchEvent.TouchType : Swift.Equatable {}
extension LayoutKit.AnalyticsTouchEvent.TouchType : Swift.Hashable {}
extension LayoutKit.ContainerBlock.LayoutDirection : Swift.Equatable {}
extension LayoutKit.ContainerBlock.LayoutDirection : Swift.Hashable {}
extension LayoutKit.ContainerBlock.LayoutDirection : Swift.Sendable {}
extension LayoutKit.ContainerBlock.LayoutDirection : Swift.BitwiseCopyable {}
extension LayoutKit.BlockBorder.Style : Swift.Equatable {}
extension LayoutKit.BlockBorder.Style : Swift.Hashable {}
extension LayoutKit.BlockTooltip.Position : Swift.Equatable {}
extension LayoutKit.BlockTooltip.Position : Swift.Hashable {}
extension LayoutKit.BlockTooltip.Position : Swift.RawRepresentable {}
extension LayoutKit.BlockTooltip.Mode : Swift.Hashable {}
extension LayoutKit.BlurEffect : Swift.Equatable {}
extension LayoutKit.BlurEffect : Swift.Hashable {}
extension LayoutKit.ContainerBlock.LayoutMode : Swift.Equatable {}
extension LayoutKit.ContainerBlock.LayoutMode : Swift.Hashable {}
extension LayoutKit.ContainerBlock.CrossAlignment : Swift.Equatable {}
extension LayoutKit.ContainerBlock.CrossAlignment : Swift.Hashable {}
extension LayoutKit.ContainerBlock.AxialAlignment : Swift.Equatable {}
extension LayoutKit.ContainerBlock.AxialAlignment : Swift.Hashable {}
extension LayoutKit.VideoScale : Swift.Equatable {}
extension LayoutKit.VideoScale : Swift.Hashable {}
extension LayoutKit.ElementsTransformation.Style : Swift.Equatable {}
extension LayoutKit.ElementsTransformation.Style : Swift.Hashable {}
extension LayoutKit.GalleryScrollEvent.Direction : Swift.Equatable {}
extension LayoutKit.GalleryScrollEvent.Direction : Swift.Hashable {}
extension LayoutKit.GalleryViewModel.Scrollbar : Swift.Hashable {}
extension LayoutKit.GalleryViewState.Position : Swift.Sendable {}
extension LayoutKit.GalleryViewState.Position : Swift.BitwiseCopyable {}
extension LayoutKit.GenericCollectionViewDataSource : Swift.Sendable {}
extension LayoutKit.GridBlock.Direction : Swift.Equatable {}
extension LayoutKit.GridBlock.Direction : Swift.Hashable {}
extension LayoutKit.GridBlock.Direction : Swift.RawRepresentable {}
extension LayoutKit.PageIndicatorConfiguration.Animation : Swift.Equatable {}
extension LayoutKit.PageIndicatorConfiguration.Animation : Swift.Hashable {}
extension LayoutKit.PlayerStatus : Swift.Equatable {}
extension LayoutKit.PlayerStatus : Swift.Hashable {}
extension LayoutKit.ScrollDirection : Swift.Hashable {}
extension LayoutKit.ScrollDirection : Swift.Sendable {}
extension LayoutKit.ScrollDirection : Swift.BitwiseCopyable {}
extension LayoutKit.SeparatorBlock.Direction : Swift.Equatable {}
extension LayoutKit.SeparatorBlock.Direction : Swift.Hashable {}
extension LayoutKit.SliderThumbNumber : Swift.Equatable {}
extension LayoutKit.SliderThumbNumber : Swift.Hashable {}
extension LayoutKit.SwipeContainerBlock.State : Swift.Equatable {}
extension LayoutKit.SwipeContainerBlock.State : Swift.Hashable {}
extension LayoutKit.SwitchableContainerBlock.Selection : Swift.Hashable {}
extension LayoutKit.SwitchableContainerBlock.Selection : Swift.RawRepresentable {}
extension LayoutKit.TabbedPagesHeightMode : Swift.Hashable {}
extension LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position : Swift.Equatable {}
extension LayoutKit.TextFieldBlock.Placeholders.Separate.Field.Position : Swift.Hashable {}
extension LayoutKit.TextFieldBlock.TextAutocapitalizationType : Swift.Equatable {}
extension LayoutKit.TextFieldBlock.TextAutocapitalizationType : Swift.Hashable {}
extension LayoutKit.TextFieldBlock.TextAutocorrectionType : Swift.Equatable {}
extension LayoutKit.TextFieldBlock.TextAutocorrectionType : Swift.Hashable {}
extension LayoutKit.TextFieldBlock.KeyboardType : Swift.Equatable {}
extension LayoutKit.TextFieldBlock.KeyboardType : Swift.Hashable {}
extension LayoutKit.TextFieldBlock.KeyboardAppearance : Swift.Equatable {}
extension LayoutKit.TextFieldBlock.KeyboardAppearance : Swift.Hashable {}
extension LayoutKit.TextInputBlock.InputType.KeyboardType : Swift.Hashable {}
extension LayoutKit.TextInputBlock.AutocapitalizationType : Swift.Equatable {}
extension LayoutKit.TextInputBlock.AutocapitalizationType : Swift.Hashable {}
extension LayoutKit.TextInputBlock.TextAlignmentHorizontal : Swift.Hashable {}
extension LayoutKit.TextInputBlock.TextAlignmentVertical : Swift.Hashable {}
extension LayoutKit.TextInputBlock.EnterKeyType : Swift.Hashable {}
extension LayoutKit.TimingFunction : Swift.Equatable {}
extension LayoutKit.TimingFunction : Swift.Hashable {}
extension LayoutKit.TransitioningAnimation.Kind : Swift.Hashable {}
extension LayoutKit.TransitioningAnimation.Kind : Swift.RawRepresentable {}
extension LayoutKit.TransitioningAnimation.Kind : Swift.Sendable {}
extension LayoutKit.TransitioningAnimation.Kind : Swift.BitwiseCopyable {}
extension LayoutKit.VideoBlockViewState.State : Swift.Equatable {}
extension LayoutKit.VideoBlockViewState.State : Swift.Hashable {}
extension LayoutKit.Visibility : Swift.Equatable {}
extension LayoutKit.Visibility : Swift.Hashable {}
extension LayoutKit.VisibilityActionType : Swift.Equatable {}
extension LayoutKit.VisibilityActionType : Swift.Hashable {}
extension LayoutKit.VisibilityActionType : Swift.RawRepresentable {}
