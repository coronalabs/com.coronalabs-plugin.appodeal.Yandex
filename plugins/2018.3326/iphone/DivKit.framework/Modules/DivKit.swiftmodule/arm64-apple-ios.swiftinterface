// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 effective-5.10 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name DivKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import CoreFoundation
import CoreGraphics
import CoreMedia
import CoreText
@_exported import DivKit
import Foundation
import LayoutKit
import LayoutKitInterface
import Serialization
import Swift
import SwiftUI
import UIKit
import VGSL
import VGSLFundamentals
import VGSLUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_hasMissingDesignatedInitializers final public class ArrayValue : @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<[Any]>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> [Any]?
  @objc deinit
}
extension DivKit.ArrayValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ArrayValueTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<[Any]>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ArrayValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ArrayValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ArrayValueTemplate
  public typealias ResolvedValue = DivKit.ArrayValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ArrayVariable : @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<[Any]>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> [Any]?
  @objc deinit
}
extension DivKit.ArrayVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ArrayVariableTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<[Any]>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ArrayVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ArrayVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ArrayVariableTemplate
  public typealias ResolvedValue = DivKit.ArrayVariable
  @objc deinit
}
public typealias TemplateName = Swift.String
@_hasMissingDesignatedInitializers final public class BooleanValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Bool>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  @objc deinit
}
extension DivKit.BooleanValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class BooleanValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.BooleanValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.BooleanValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.BooleanValueTemplate
  public typealias ResolvedValue = DivKit.BooleanValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class BooleanVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<Swift.Bool>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  @objc deinit
}
extension DivKit.BooleanVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class BooleanVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.BooleanVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.BooleanVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.BooleanVariableTemplate
  public typealias ResolvedValue = DivKit.BooleanVariable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ColorValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<VGSLUI.Color>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.ColorValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ColorValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ColorValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ColorValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ColorValueTemplate
  public typealias ResolvedValue = DivKit.ColorValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ColorVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<VGSLUI.Color>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.ColorVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ColorVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ColorVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ColorVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ColorVariableTemplate
  public typealias ResolvedValue = DivKit.ColorVariable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ContentText : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.String>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.ContentText : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ContentTextTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ContentTextTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ContentText>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ContentTextTemplate
  public typealias ResolvedValue = DivKit.ContentText
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ContentUrl : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Foundation.URL>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.ContentUrl : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class ContentUrlTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.ContentUrlTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.ContentUrl>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.ContentUrlTemplate
  public typealias ResolvedValue = DivKit.ContentUrl
  @objc deinit
}
public struct TemplatesContext {
  @usableFromInline
  internal let templates: [DivKit.TemplateName : Any]
  @usableFromInline
  internal let templateToType: [DivKit.TemplateName : Swift.String]
  @usableFromInline
  internal var templateData: [Swift.String : Any]
}
public struct DebugParams {
  public struct Measurements : Swift.Sendable {
    public let divDataParsingTime: DivKit.TimeMeasure
    public let renderTime: DivKit.TimeMeasure
    public let templateParsingTime: DivKit.TimeMeasure
    public init(divDataParsingTime: DivKit.TimeMeasure, renderTime: DivKit.TimeMeasure, templateParsingTime: DivKit.TimeMeasure)
  }
  public let isDebugInfoEnabled: Swift.Bool
  public let processMeasurements: VGSLFundamentals.ResultAction<(cardId: DivKit.DivCardID, measurements: DivKit.DebugParams.Measurements)>
  public let showDebugInfo: (VGSLUI.ViewType) -> Swift.Void
  public let errorCounterInsets: VGSLUI.EdgeInsets
  public let widcardExtensionHandlers: [any DivKit.DivExtensionHandler]
  public init(isDebugInfoEnabled: Swift.Bool = false, processMeasurements: @escaping VGSLFundamentals.ResultAction<(cardId: DivKit.DivCardID, measurements: DivKit.DebugParams.Measurements)> = { _ in }, showDebugInfo: @escaping (VGSLUI.ViewType) -> Swift.Void = DebugParams.showDebugInfo(_:), errorCounterInsets: VGSLUI.EdgeInsets = .zero, widcardExtensionHandlers: [any DivKit.DivExtensionHandler] = [])
}
extension DivKit.DebugParams {
  public static func showDebugInfo(_ view: VGSLUI.ViewType)
}
extension Serialization.DeserializationResult {
  public func asCardResult(cardId: DivKit.DivCardID) -> Serialization.DeserializationResult<T>
}
@_hasMissingDesignatedInitializers final public class DictValue : @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<[Swift.String : Any]>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
  @objc deinit
}
extension DivKit.DictValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DictValueTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DictValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DictValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DictValueTemplate
  public typealias ResolvedValue = DivKit.DictValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DictVariable : @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<[Swift.String : Any]>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
  @objc deinit
}
extension DivKit.DictVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DictVariableTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DictVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DictVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DictVariableTemplate
  public typealias ResolvedValue = DivKit.DictVariable
  @objc deinit
}
@frozen public enum Div : Swift.Sendable {
  case divImage(DivKit.DivImage)
  case divGifImage(DivKit.DivGifImage)
  case divText(DivKit.DivText)
  case divSeparator(DivKit.DivSeparator)
  case divContainer(DivKit.DivContainer)
  case divGrid(DivKit.DivGrid)
  case divGallery(DivKit.DivGallery)
  case divPager(DivKit.DivPager)
  case divTabs(DivKit.DivTabs)
  case divState(DivKit.DivState)
  case divCustom(DivKit.DivCustom)
  case divIndicator(DivKit.DivIndicator)
  case divSlider(DivKit.DivSlider)
  case divSwitch(DivKit.DivSwitch)
  case divInput(DivKit.DivInput)
  case divSelect(DivKit.DivSelect)
  case divVideo(DivKit.DivVideo)
  public var value: any DivKit.DivBase & Serialization.Serializable {
    get
  }
  public var id: Swift.String? {
    get
  }
}
extension DivKit.Div : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivAbsoluteEdgeInsets : Swift.Sendable {
  final public let bottom: DivKit.Expression<Swift.Int>
  final public let left: DivKit.Expression<Swift.Int>
  final public let right: DivKit.Expression<Swift.Int>
  final public let top: DivKit.Expression<Swift.Int>
  final public func resolveBottom(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveLeft(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveRight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveTop(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivAbsoluteEdgeInsets : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivAbsoluteEdgeInsetsTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let bottom: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let left: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let right: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let top: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAbsoluteEdgeInsetsTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAbsoluteEdgeInsets>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAbsoluteEdgeInsetsTemplate
  public typealias ResolvedValue = DivKit.DivAbsoluteEdgeInsets
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivAccessibility : Swift.Sendable {
  @frozen public enum Kind : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case none
    case button
    case image
    case text
    case editText
    case header
    case tabBar
    case list
    case select
    case checkbox
    case radio
    case auto
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivAccessibility.Kind]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivAccessibility.Kind] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Mode : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case `default`
    case merge
    case exclude
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivAccessibility.Mode]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivAccessibility.Mode] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  final public let description: DivKit.Expression<Swift.String>?
  final public let hint: DivKit.Expression<Swift.String>?
  final public let isChecked: DivKit.Expression<Swift.Bool>?
  final public let mode: DivKit.Expression<DivKit.DivAccessibility.Mode>
  final public let muteAfterAction: DivKit.Expression<Swift.Bool>
  final public let stateDescription: DivKit.Expression<Swift.String>?
  final public let type: DivKit.DivAccessibility.Kind
  final public func resolveDescription(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveHint(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveIsChecked(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  final public func resolveMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAccessibility.Mode
  final public func resolveMuteAfterAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveStateDescription(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivAccessibility : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivAccessibilityTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Kind = DivKit.DivAccessibility.Kind
  public typealias Mode = DivKit.DivAccessibility.Mode
  final public let description: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let hint: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let isChecked: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let mode: DivKit.Field<DivKit.Expression<DivKit.DivAccessibilityTemplate.Mode>>?
  final public let muteAfterAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let stateDescription: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let type: DivKit.Field<DivKit.DivAccessibilityTemplate.Kind>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAccessibilityTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAccessibility>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAccessibilityTemplate
  public typealias ResolvedValue = DivKit.DivAccessibility
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivAction : @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class MenuItem : Swift.Sendable {
    final public let action: DivKit.DivAction?
    final public let actions: [DivKit.DivAction]?
    final public let text: DivKit.Expression<Swift.String>
    final public func resolveText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  final public let downloadCallbacks: DivKit.DivDownloadCallbacks?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let logId: DivKit.Expression<Swift.String>
  final public let logUrl: DivKit.Expression<Foundation.URL>?
  final public let menuItems: [DivKit.DivAction.MenuItem]?
  final public let payload: [Swift.String : Any]?
  final public let referer: DivKit.Expression<Foundation.URL>?
  final public let scopeId: Swift.String?
  final public let typed: DivKit.DivActionTyped?
  final public let url: DivKit.Expression<Foundation.URL>?
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveLogId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveLogUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveReferer(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.DivAction : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivAction.MenuItem : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionAnimatorStart : Swift.Sendable {
  public static let type: Swift.String
  final public let animatorId: Swift.String
  final public let direction: DivKit.Expression<DivKit.DivAnimationDirection>?
  final public let duration: DivKit.Expression<Swift.Int>?
  final public let endValue: DivKit.DivTypedValue?
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>?
  final public let repeatCount: DivKit.DivCount?
  final public let startDelay: DivKit.Expression<Swift.Int>?
  final public let startValue: DivKit.DivTypedValue?
  final public func resolveDirection(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationDirection?
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator?
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivActionAnimatorStart : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionAnimatorStartTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let animatorId: DivKit.Field<Swift.String>?
  final public let direction: DivKit.Field<DivKit.Expression<DivKit.DivAnimationDirection>>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let endValue: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let repeatCount: DivKit.Field<DivKit.DivCountTemplate>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let startValue: DivKit.Field<DivKit.DivTypedValueTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionAnimatorStartTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionAnimatorStart>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionAnimatorStartTemplate
  public typealias ResolvedValue = DivKit.DivActionAnimatorStart
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionAnimatorStop : Swift.Sendable {
  public static let type: Swift.String
  final public let animatorId: Swift.String
  @objc deinit
}
extension DivKit.DivActionAnimatorStop : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionAnimatorStopTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let animatorId: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionAnimatorStopTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionAnimatorStop>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionAnimatorStopTemplate
  public typealias ResolvedValue = DivKit.DivActionAnimatorStop
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionArrayInsertValue : Swift.Sendable {
  public static let type: Swift.String
  final public let index: DivKit.Expression<Swift.Int>?
  final public let value: DivKit.DivTypedValue
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolveIndex(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionArrayInsertValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionArrayInsertValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let index: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionArrayInsertValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionArrayInsertValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionArrayInsertValueTemplate
  public typealias ResolvedValue = DivKit.DivActionArrayInsertValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionArrayRemoveValue : Swift.Sendable {
  public static let type: Swift.String
  final public let index: DivKit.Expression<Swift.Int>
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolveIndex(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionArrayRemoveValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionArrayRemoveValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let index: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionArrayRemoveValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionArrayRemoveValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionArrayRemoveValueTemplate
  public typealias ResolvedValue = DivKit.DivActionArrayRemoveValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionArraySetValue : Swift.Sendable {
  public static let type: Swift.String
  final public let index: DivKit.Expression<Swift.Int>
  final public let value: DivKit.DivTypedValue
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolveIndex(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionArraySetValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionArraySetValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let index: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionArraySetValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionArraySetValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionArraySetValueTemplate
  public typealias ResolvedValue = DivKit.DivActionArraySetValue
  @objc deinit
}
public protocol DivActionBase : Serialization.Serializable {
  var downloadCallbacks: DivKit.DivDownloadCallbacks? { get }
  var payload: [Swift.String : Any]? { get }
  var typed: DivKit.DivActionTyped? { get }
  var url: DivKit.Expression<Foundation.URL>? { get }
  var scopeId: Swift.String? { get }
  var isEnabled: DivKit.Expression<Swift.Bool> { get }
  func resolveLogId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  func resolveLogUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  func resolveReferer(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class DivActionClearFocus : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivActionClearFocus : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionClearFocusTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionClearFocusTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionClearFocus>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionClearFocusTemplate
  public typealias ResolvedValue = DivKit.DivActionClearFocus
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionCopyToClipboard : Swift.Sendable {
  public static let type: Swift.String
  final public let content: DivKit.DivActionCopyToClipboardContent
  @objc deinit
}
extension DivKit.DivActionCopyToClipboard : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivActionCopyToClipboardContent : Swift.Sendable {
  case contentText(DivKit.ContentText)
  case contentUrl(DivKit.ContentUrl)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivActionCopyToClipboardContent : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivActionCopyToClipboardContentTemplate : DivKit.TemplateValue, Swift.Sendable {
  case contentTextTemplate(DivKit.ContentTextTemplate)
  case contentUrlTemplate(DivKit.ContentUrlTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionCopyToClipboardContentTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionCopyToClipboardContentTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionCopyToClipboardContent>
  public typealias ResolvedValue = DivKit.DivActionCopyToClipboardContent
}
extension DivKit.DivActionCopyToClipboardContentTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivActionCopyToClipboardTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let content: DivKit.Field<DivKit.DivActionCopyToClipboardContentTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionCopyToClipboardTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionCopyToClipboard>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionCopyToClipboardTemplate
  public typealias ResolvedValue = DivKit.DivActionCopyToClipboard
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionDictSetValue : Swift.Sendable {
  public static let type: Swift.String
  final public let key: DivKit.Expression<Swift.String>
  final public let value: DivKit.DivTypedValue?
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolveKey(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionDictSetValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionDictSetValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let key: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionDictSetValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionDictSetValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionDictSetValueTemplate
  public typealias ResolvedValue = DivKit.DivActionDictSetValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionDownload : Swift.Sendable {
  public static let type: Swift.String
  final public let onFailActions: [DivKit.DivAction]?
  final public let onSuccessActions: [DivKit.DivAction]?
  final public let url: DivKit.Expression<Foundation.URL>
  final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.DivActionDownload : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionDownloadTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let onFailActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let onSuccessActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionDownloadTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionDownload>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionDownloadTemplate
  public typealias ResolvedValue = DivKit.DivActionDownload
  @objc deinit
}
extension DivKit.DivAction : DivKit.DivActionBase {
}
extension DivKit.DivAction {
  final public func uiAction(context: DivKit.DivBlockModelingContext) -> LayoutKitInterface.UserInterfaceAction?
}
extension Swift.Array where Element == DivKit.DivAction {
  public func uiActions(context: DivKit.DivBlockModelingContext) -> [LayoutKitInterface.UserInterfaceAction]
}
@_hasMissingDesignatedInitializers final public class DivActionFocusElement : Swift.Sendable {
  public static let type: Swift.String
  final public let elementId: DivKit.Expression<Swift.String>
  final public func resolveElementId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionFocusElement : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionFocusElementTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let elementId: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionFocusElementTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionFocusElement>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionFocusElementTemplate
  public typealias ResolvedValue = DivKit.DivActionFocusElement
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionHandler {
  public typealias ShowTooltipAction = (LayoutKit.TooltipInfo) -> Swift.Void
  public typealias TrackVisibility = (_ logId: Swift.String, _ cardId: DivKit.DivCardID) -> Swift.Void
  final public func handle(params: LayoutKitInterface.UserInterfaceAction.DivActionParams, sender: Swift.AnyObject?)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionHideTooltip : Swift.Sendable {
  public static let type: Swift.String
  final public let id: DivKit.Expression<Swift.String>
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionHideTooltip : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionHideTooltipTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionHideTooltipTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionHideTooltip>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionHideTooltipTemplate
  public typealias ResolvedValue = DivKit.DivActionHideTooltip
  @objc deinit
}
public struct DivActionInfo {
  public let path: LayoutKitInterface.UIElementPath
  public let logId: Swift.String
  public let url: Foundation.URL?
  public let logUrl: Foundation.URL?
  public let referer: Foundation.URL?
  public let source: LayoutKitInterface.UserInterfaceAction.DivActionSource
  public let payload: [Swift.String : Any]?
  public var cardId: DivKit.DivCardID {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivActionScrollBy : Swift.Sendable {
  @frozen public enum Overflow : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case clamp
    case ring
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivActionScrollBy.Overflow]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivActionScrollBy.Overflow] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let animated: DivKit.Expression<Swift.Bool>
  final public let id: DivKit.Expression<Swift.String>
  final public let itemCount: DivKit.Expression<Swift.Int>
  final public let offset: DivKit.Expression<Swift.Int>
  final public let overflow: DivKit.Expression<DivKit.DivActionScrollBy.Overflow>
  final public func resolveAnimated(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveItemCount(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveOffset(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveOverflow(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivActionScrollBy.Overflow
  @objc deinit
}
extension DivKit.DivActionScrollBy : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionScrollByTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Overflow = DivKit.DivActionScrollBy.Overflow
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let animated: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let itemCount: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let offset: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let overflow: DivKit.Field<DivKit.Expression<DivKit.DivActionScrollByTemplate.Overflow>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionScrollByTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionScrollBy>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionScrollByTemplate
  public typealias ResolvedValue = DivKit.DivActionScrollBy
  @objc deinit
}
@frozen public enum DivActionScrollDestination : Swift.Sendable {
  case offsetDestination(DivKit.OffsetDestination)
  case indexDestination(DivKit.IndexDestination)
  case startDestination(DivKit.StartDestination)
  case endDestination(DivKit.EndDestination)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivActionScrollDestination : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivActionScrollDestinationTemplate : DivKit.TemplateValue, Swift.Sendable {
  case offsetDestinationTemplate(DivKit.OffsetDestinationTemplate)
  case indexDestinationTemplate(DivKit.IndexDestinationTemplate)
  case startDestinationTemplate(DivKit.StartDestinationTemplate)
  case endDestinationTemplate(DivKit.EndDestinationTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionScrollDestinationTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionScrollDestinationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionScrollDestination>
  public typealias ResolvedValue = DivKit.DivActionScrollDestination
}
extension DivKit.DivActionScrollDestinationTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivActionScrollTo : Swift.Sendable {
  public static let type: Swift.String
  final public let animated: DivKit.Expression<Swift.Bool>
  final public let destination: DivKit.DivActionScrollDestination
  final public let id: DivKit.Expression<Swift.String>
  final public func resolveAnimated(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionScrollTo : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionScrollToTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let animated: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let destination: DivKit.Field<DivKit.DivActionScrollDestinationTemplate>?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionScrollToTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionScrollTo>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionScrollToTemplate
  public typealias ResolvedValue = DivKit.DivActionScrollTo
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionSetState : Swift.Sendable {
  public static let type: Swift.String
  final public let stateId: DivKit.Expression<Swift.String>
  final public let temporary: DivKit.Expression<Swift.Bool>
  final public func resolveStateId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveTemporary(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivActionSetState : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionSetStateTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let stateId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let temporary: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSetStateTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSetState>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSetStateTemplate
  public typealias ResolvedValue = DivKit.DivActionSetState
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionSetStoredValue : Swift.Sendable {
  public static let type: Swift.String
  final public let lifetime: DivKit.Expression<Swift.Int>
  final public let name: DivKit.Expression<Swift.String>
  final public let value: DivKit.DivTypedValue
  final public func resolveLifetime(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionSetStoredValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionSetStoredValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let lifetime: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let name: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSetStoredValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSetStoredValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSetStoredValueTemplate
  public typealias ResolvedValue = DivKit.DivActionSetStoredValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionSetVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.DivTypedValue
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionSetVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionSetVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSetVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSetVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSetVariableTemplate
  public typealias ResolvedValue = DivKit.DivActionSetVariable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionShowTooltip : Swift.Sendable {
  public static let type: Swift.String
  final public let id: DivKit.Expression<Swift.String>
  final public let multiple: DivKit.Expression<Swift.Bool>?
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveMultiple(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  @objc deinit
}
extension DivKit.DivActionShowTooltip : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionShowTooltipTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let multiple: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionShowTooltipTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionShowTooltip>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionShowTooltipTemplate
  public typealias ResolvedValue = DivKit.DivActionShowTooltip
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionSubmit : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Request : Swift.Sendable {
    @frozen public enum Method : Swift.String, Swift.CaseIterable, Swift.Sendable {
      case get
      case post
      case put
      case patch
      case delete
      case head
      case options
      public init?(rawValue: Swift.String)
      public typealias AllCases = [DivKit.DivActionSubmit.Request.Method]
      public typealias RawValue = Swift.String
      nonisolated public static var allCases: [DivKit.DivActionSubmit.Request.Method] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
    @_hasMissingDesignatedInitializers final public class Header : Swift.Sendable {
      final public let name: DivKit.Expression<Swift.String>
      final public let value: DivKit.Expression<Swift.String>
      final public func resolveName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
      final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
      @objc deinit
    }
    final public let headers: [DivKit.DivActionSubmit.Request.Header]?
    final public let method: DivKit.Expression<DivKit.DivActionSubmit.Request.Method>
    final public let url: DivKit.Expression<Foundation.URL>
    final public func resolveMethod(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivActionSubmit.Request.Method
    final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
    @objc deinit
  }
  public static let type: Swift.String
  final public let containerId: DivKit.Expression<Swift.String>
  final public let onFailActions: [DivKit.DivAction]?
  final public let onSuccessActions: [DivKit.DivAction]?
  final public let request: DivKit.DivActionSubmit.Request
  final public func resolveContainerId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionSubmit : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivActionSubmit.Request.Header : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivActionSubmit.Request : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionSubmitTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class RequestTemplate : DivKit.TemplateValue, Swift.Sendable {
    @_hasMissingDesignatedInitializers final public class HeaderTemplate : DivKit.TemplateValue, Swift.Sendable {
      final public let name: DivKit.Field<DivKit.Expression<Swift.String>>?
      final public let value: DivKit.Field<DivKit.Expression<Swift.String>>?
      convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
      public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSubmitTemplate.RequestTemplate.HeaderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSubmit.Request.Header>
      final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSubmitTemplate.RequestTemplate.HeaderTemplate
      public typealias ResolvedValue = DivKit.DivActionSubmit.Request.Header
      @objc deinit
    }
    public typealias Method = DivKit.DivActionSubmit.Request.Method
    final public let headers: DivKit.Field<[DivKit.DivActionSubmitTemplate.RequestTemplate.HeaderTemplate]>?
    final public let method: DivKit.Field<DivKit.Expression<DivKit.DivActionSubmitTemplate.RequestTemplate.Method>>?
    final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSubmitTemplate.RequestTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSubmit.Request>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSubmitTemplate.RequestTemplate
    public typealias ResolvedValue = DivKit.DivActionSubmit.Request
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let containerId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let onFailActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let onSuccessActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let request: DivKit.Field<DivKit.DivActionSubmitTemplate.RequestTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionSubmitTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionSubmit>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionSubmitTemplate
  public typealias ResolvedValue = DivKit.DivActionSubmit
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class MenuItemTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let action: DivKit.Field<DivKit.DivActionTemplate>?
    final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
    final public let text: DivKit.Field<DivKit.Expression<Swift.String>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionTemplate.MenuItemTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAction.MenuItem>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionTemplate.MenuItemTemplate
    public typealias ResolvedValue = DivKit.DivAction.MenuItem
    @objc deinit
  }
  final public let downloadCallbacks: DivKit.Field<DivKit.DivDownloadCallbacksTemplate>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let logId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let logUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let menuItems: DivKit.Field<[DivKit.DivActionTemplate.MenuItemTemplate]>?
  final public let payload: DivKit.Field<[Swift.String : Any]>?
  final public let referer: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let scopeId: DivKit.Field<Swift.String>?
  final public let typed: DivKit.Field<DivKit.DivActionTypedTemplate>?
  final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAction>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionTemplate
  public typealias ResolvedValue = DivKit.DivAction
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivActionTimer : Swift.Sendable {
  @frozen public enum Action : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case start
    case stop
    case pause
    case resume
    case cancel
    case reset
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivActionTimer.Action]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivActionTimer.Action] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let action: DivKit.Expression<DivKit.DivActionTimer.Action>
  final public let id: DivKit.Expression<Swift.String>
  final public func resolveAction(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivActionTimer.Action?
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionTimer : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionTimerTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Action = DivKit.DivActionTimer.Action
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let action: DivKit.Field<DivKit.Expression<DivKit.DivActionTimerTemplate.Action>>?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionTimerTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionTimer>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionTimerTemplate
  public typealias ResolvedValue = DivKit.DivActionTimer
  @objc deinit
}
@frozen public enum DivActionTyped : Swift.Sendable {
  case divActionAnimatorStart(DivKit.DivActionAnimatorStart)
  case divActionAnimatorStop(DivKit.DivActionAnimatorStop)
  case divActionArrayInsertValue(DivKit.DivActionArrayInsertValue)
  case divActionArrayRemoveValue(DivKit.DivActionArrayRemoveValue)
  case divActionArraySetValue(DivKit.DivActionArraySetValue)
  case divActionClearFocus(DivKit.DivActionClearFocus)
  case divActionCopyToClipboard(DivKit.DivActionCopyToClipboard)
  case divActionDictSetValue(DivKit.DivActionDictSetValue)
  case divActionDownload(DivKit.DivActionDownload)
  case divActionFocusElement(DivKit.DivActionFocusElement)
  case divActionHideTooltip(DivKit.DivActionHideTooltip)
  case divActionScrollBy(DivKit.DivActionScrollBy)
  case divActionScrollTo(DivKit.DivActionScrollTo)
  case divActionSetState(DivKit.DivActionSetState)
  case divActionSetStoredValue(DivKit.DivActionSetStoredValue)
  case divActionSetVariable(DivKit.DivActionSetVariable)
  case divActionShowTooltip(DivKit.DivActionShowTooltip)
  case divActionSubmit(DivKit.DivActionSubmit)
  case divActionTimer(DivKit.DivActionTimer)
  case divActionUpdateStructure(DivKit.DivActionUpdateStructure)
  case divActionVideo(DivKit.DivActionVideo)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivActionTyped : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivActionTypedTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divActionAnimatorStartTemplate(DivKit.DivActionAnimatorStartTemplate)
  case divActionAnimatorStopTemplate(DivKit.DivActionAnimatorStopTemplate)
  case divActionArrayInsertValueTemplate(DivKit.DivActionArrayInsertValueTemplate)
  case divActionArrayRemoveValueTemplate(DivKit.DivActionArrayRemoveValueTemplate)
  case divActionArraySetValueTemplate(DivKit.DivActionArraySetValueTemplate)
  case divActionClearFocusTemplate(DivKit.DivActionClearFocusTemplate)
  case divActionCopyToClipboardTemplate(DivKit.DivActionCopyToClipboardTemplate)
  case divActionDictSetValueTemplate(DivKit.DivActionDictSetValueTemplate)
  case divActionDownloadTemplate(DivKit.DivActionDownloadTemplate)
  case divActionFocusElementTemplate(DivKit.DivActionFocusElementTemplate)
  case divActionHideTooltipTemplate(DivKit.DivActionHideTooltipTemplate)
  case divActionScrollByTemplate(DivKit.DivActionScrollByTemplate)
  case divActionScrollToTemplate(DivKit.DivActionScrollToTemplate)
  case divActionSetStateTemplate(DivKit.DivActionSetStateTemplate)
  case divActionSetStoredValueTemplate(DivKit.DivActionSetStoredValueTemplate)
  case divActionSetVariableTemplate(DivKit.DivActionSetVariableTemplate)
  case divActionShowTooltipTemplate(DivKit.DivActionShowTooltipTemplate)
  case divActionSubmitTemplate(DivKit.DivActionSubmitTemplate)
  case divActionTimerTemplate(DivKit.DivActionTimerTemplate)
  case divActionUpdateStructureTemplate(DivKit.DivActionUpdateStructureTemplate)
  case divActionVideoTemplate(DivKit.DivActionVideoTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionTypedTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionTypedTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionTyped>
  public typealias ResolvedValue = DivKit.DivActionTyped
}
extension DivKit.DivActionTypedTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivActionUpdateStructure : Swift.Sendable {
  public static let type: Swift.String
  final public let path: DivKit.Expression<Swift.String>
  final public let value: DivKit.DivTypedValue
  final public let variableName: DivKit.Expression<Swift.String>
  final public func resolvePath(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveVariableName(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionUpdateStructure : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionUpdateStructureTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let path: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let value: DivKit.Field<DivKit.DivTypedValueTemplate>?
  final public let variableName: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionUpdateStructureTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionUpdateStructure>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionUpdateStructureTemplate
  public typealias ResolvedValue = DivKit.DivActionUpdateStructure
  @objc deinit
}
public enum DivActionURLHandler {
  @frozen public enum UpdateReason {
    case patch(DivKit.DivCardID, DivKit.DivPatch)
    case timer(DivKit.DivCardID)
    case state(DivKit.DivCardID)
    case variable([DivKit.DivCardID : Swift.Set<DivKit.DivVariableName>])
    case external
  }
}
@_hasMissingDesignatedInitializers final public class DivActionVideo : Swift.Sendable {
  @frozen public enum Action : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case start
    case pause
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivActionVideo.Action]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivActionVideo.Action] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let action: DivKit.Expression<DivKit.DivActionVideo.Action>
  final public let id: DivKit.Expression<Swift.String>
  final public func resolveAction(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivActionVideo.Action?
  final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivActionVideo : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivActionVideoTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Action = DivKit.DivActionVideo.Action
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let action: DivKit.Field<DivKit.Expression<DivKit.DivActionVideoTemplate.Action>>?
  final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivActionVideoTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivActionVideo>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivActionVideoTemplate
  public typealias ResolvedValue = DivKit.DivActionVideo
  @objc deinit
}
@frozen public enum DivAlignmentHorizontal : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case left
  case center
  case right
  case start
  case end
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivAlignmentHorizontal]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivAlignmentHorizontal] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@frozen public enum DivAlignmentVertical : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case top
  case center
  case bottom
  case baseline
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivAlignmentVertical]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivAlignmentVertical] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivAnimation : Swift.Sendable {
  @frozen public enum Name : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case fade
    case translate
    case scale
    case native
    case set
    case noAnimation
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivAnimation.Name]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivAnimation.Name] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  final public let duration: DivKit.Expression<Swift.Int>
  final public let endValue: DivKit.Expression<Swift.Double>?
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let items: [DivKit.DivAnimation]?
  final public let name: DivKit.Expression<DivKit.DivAnimation.Name>
  final public let repeatCount: DivKit.DivCount
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public let startValue: DivKit.Expression<Swift.Double>?
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveEndValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveName(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimation.Name?
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveStartValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivAnimation : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivAnimationDirection : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case normal
  case reverse
  case alternate
  case alternateReverse
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivAnimationDirection]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivAnimationDirection] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@frozen public enum DivAnimationInterpolator : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case linear
  case ease
  case easeIn
  case easeOut
  case easeInOut
  case spring
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivAnimationInterpolator]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivAnimationInterpolator] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivAnimationTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Name = DivKit.DivAnimation.Name
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let endValue: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let items: DivKit.Field<[DivKit.DivAnimationTemplate]>?
  final public let name: DivKit.Field<DivKit.Expression<DivKit.DivAnimationTemplate.Name>>?
  final public let repeatCount: DivKit.Field<DivKit.DivCountTemplate>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let startValue: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAnimationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAnimation>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAnimationTemplate
  public typealias ResolvedValue = DivKit.DivAnimation
  @objc deinit
}
@frozen public enum DivAnimator : Swift.Sendable {
  case divColorAnimator(DivKit.DivColorAnimator)
  case divNumberAnimator(DivKit.DivNumberAnimator)
  public var value: any DivKit.DivAnimatorBase & Serialization.Serializable {
    get
  }
  public var id: Swift.String {
    get
  }
}
extension DivKit.DivAnimator : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public protocol DivAnimatorBase {
  var cancelActions: [DivKit.DivAction]? { get }
  var direction: DivKit.Expression<DivKit.DivAnimationDirection> { get }
  var duration: DivKit.Expression<Swift.Int> { get }
  var endActions: [DivKit.DivAction]? { get }
  var id: Swift.String { get }
  var interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator> { get }
  var repeatCount: DivKit.DivCount { get }
  var startDelay: DivKit.Expression<Swift.Int> { get }
  var variableName: Swift.String { get }
  func resolveDirection(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationDirection
  func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
}
@frozen public enum DivAnimatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divColorAnimatorTemplate(DivKit.DivColorAnimatorTemplate)
  case divNumberAnimatorTemplate(DivKit.DivNumberAnimatorTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAnimatorTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAnimatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAnimator>
  public typealias ResolvedValue = DivKit.DivAnimator
}
extension DivKit.DivAnimatorTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivAppearanceSetTransition : Swift.Sendable {
  public static let type: Swift.String
  final public let items: [DivKit.DivAppearanceTransition]
  @objc deinit
}
extension DivKit.DivAppearanceSetTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivAppearanceSetTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let items: DivKit.Field<[DivKit.DivAppearanceTransitionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAppearanceSetTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAppearanceSetTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAppearanceSetTransitionTemplate
  public typealias ResolvedValue = DivKit.DivAppearanceSetTransition
  @objc deinit
}
@frozen public enum DivAppearanceTransition : Swift.Sendable {
  case divAppearanceSetTransition(DivKit.DivAppearanceSetTransition)
  case divFadeTransition(DivKit.DivFadeTransition)
  case divScaleTransition(DivKit.DivScaleTransition)
  case divSlideTransition(DivKit.DivSlideTransition)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivAppearanceTransition : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivAppearanceTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divAppearanceSetTransitionTemplate(DivKit.DivAppearanceSetTransitionTemplate)
  case divFadeTransitionTemplate(DivKit.DivFadeTransitionTemplate)
  case divScaleTransitionTemplate(DivKit.DivScaleTransitionTemplate)
  case divSlideTransitionTemplate(DivKit.DivSlideTransitionTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAppearanceTransitionTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAppearanceTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAppearanceTransition>
  public typealias ResolvedValue = DivKit.DivAppearanceTransition
}
extension DivKit.DivAppearanceTransitionTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivAspect : Swift.Sendable {
  final public let ratio: DivKit.Expression<Swift.Double>
  final public func resolveRatio(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivAspect : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivAspectTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let ratio: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivAspectTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivAspect>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivAspectTemplate
  public typealias ResolvedValue = DivKit.DivAspect
  @objc deinit
}
@frozen public enum DivBackground : Swift.Sendable {
  case divLinearGradient(DivKit.DivLinearGradient)
  case divRadialGradient(DivKit.DivRadialGradient)
  case divImageBackground(DivKit.DivImageBackground)
  case divSolidBackground(DivKit.DivSolidBackground)
  case divNinePatchBackground(DivKit.DivNinePatchBackground)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivBackground : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divLinearGradientTemplate(DivKit.DivLinearGradientTemplate)
  case divRadialGradientTemplate(DivKit.DivRadialGradientTemplate)
  case divImageBackgroundTemplate(DivKit.DivImageBackgroundTemplate)
  case divSolidBackgroundTemplate(DivKit.DivSolidBackgroundTemplate)
  case divNinePatchBackgroundTemplate(DivKit.DivNinePatchBackgroundTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivBackgroundTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivBackground>
  public typealias ResolvedValue = DivKit.DivBackground
}
extension DivKit.DivBackgroundTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
public protocol DivBase : DivKit.DivBlockModeling {
  var accessibility: DivKit.DivAccessibility? { get }
  var alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>? { get }
  var alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>? { get }
  var alpha: DivKit.Expression<Swift.Double> { get }
  var animators: [DivKit.DivAnimator]? { get }
  var background: [DivKit.DivBackground]? { get }
  var border: DivKit.DivBorder? { get }
  var columnSpan: DivKit.Expression<Swift.Int>? { get }
  var disappearActions: [DivKit.DivDisappearAction]? { get }
  var extensions: [DivKit.DivExtension]? { get }
  var focus: DivKit.DivFocus? { get }
  var functions: [DivKit.DivFunction]? { get }
  var height: DivKit.DivSize { get }
  var id: Swift.String? { get }
  var layoutProvider: DivKit.DivLayoutProvider? { get }
  var margins: DivKit.DivEdgeInsets? { get }
  var paddings: DivKit.DivEdgeInsets? { get }
  var reuseId: DivKit.Expression<Swift.String>? { get }
  var rowSpan: DivKit.Expression<Swift.Int>? { get }
  var selectedActions: [DivKit.DivAction]? { get }
  var tooltips: [DivKit.DivTooltip]? { get }
  var transform: DivKit.DivTransform? { get }
  var transitionChange: DivKit.DivChangeTransition? { get }
  var transitionIn: DivKit.DivAppearanceTransition? { get }
  var transitionOut: DivKit.DivAppearanceTransition? { get }
  var transitionTriggers: [DivKit.DivTransitionTrigger]? { get }
  var variableTriggers: [DivKit.DivTrigger]? { get }
  var variables: [DivKit.DivVariable]? { get }
  var visibility: DivKit.Expression<DivKit.DivVisibility> { get }
  var visibilityAction: DivKit.DivVisibilityAction? { get }
  var visibilityActions: [DivKit.DivVisibilityAction]? { get }
  var width: DivKit.DivSize { get }
  func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
}
@frozen public enum DivBlendMode : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case sourceIn
  case sourceAtop
  case darken
  case lighten
  case multiply
  case screen
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivBlendMode]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivBlendMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public protocol DivBlockModeling {
  var id: Swift.String? { get }
  static var type: Swift.String { get }
  func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
public struct DivBlockModelingContext {
  public let actionHandler: DivKit.DivActionHandler?
  public let blockStateStorage: DivKit.DivBlockStateStorage
  public let imageHolderFactory: any DivKit.DivImageHolderFactory
  public let fontProvider: any DivKit.DivFontProvider
  public var errorsStorage: DivKit.DivErrorsStorage {
    get
  }
  public let variablesStorage: DivKit.DivVariablesStorage
  public var expressionResolver: DivKit.ExpressionResolver {
    get
  }
  public let variableTracker: DivKit.DivVariableTracker?
  public var path: LayoutKitInterface.UIElementPath {
    get
  }
  public var currentDivId: Swift.String? {
    get
  }
  public var parentPath: LayoutKitInterface.UIElementPath {
    get
  }
  public var cardId: DivKit.DivCardID {
    get
  }
  public func getExtensionHandlers(for div: any DivKit.DivBase) -> [any DivKit.DivExtensionHandler]
  public func addError(message: Swift.String)
  public func addWarning(message: Swift.String)
}
final public class DivBlockStateStorage {
  final public var states: LayoutKit.BlocksState {
    get
  }
  public init(states: LayoutKit.BlocksState = [:])
  @inlinable final public func getState<T>(_ path: LayoutKitInterface.UIElementPath) -> T? where T : LayoutKit.ElementState {
    getStateUntyped(path) as? T
  }
  final public func getStateUntyped(_ path: LayoutKitInterface.UIElementPath) -> (any LayoutKit.ElementState)?
  @inlinable final public func getState<T>(_ id: Swift.String, cardId: DivKit.DivCardID) -> T? where T : LayoutKit.ElementState {
    getStateUntyped(id, cardId: cardId) as? T
  }
  final public func getStateUntyped(_ id: Swift.String, cardId: DivKit.DivCardID) -> (any LayoutKit.ElementState)?
  final public func setState(path: LayoutKitInterface.UIElementPath, state: any LayoutKit.ElementState)
  final public func setState(id: Swift.String, cardId: DivKit.DivCardID, state: any LayoutKit.ElementState)
  final public func setFocused(isFocused: Swift.Bool, path: LayoutKitInterface.UIElementPath)
  final public func clearFocus()
  final public func isFocused(path: LayoutKitInterface.UIElementPath) -> Swift.Bool
  final public func reset()
  final public func reset(cardId: DivKit.DivCardID)
  @objc deinit
}
extension DivKit.DivBlockStateStorage : LayoutKit.ElementStateObserver {
  final public func elementStateChanged(_ state: any LayoutKit.ElementState, forPath path: LayoutKitInterface.UIElementPath)
  final public func focusedElementChanged(isFocused: Swift.Bool, forPath path: LayoutKitInterface.UIElementPath)
}
@_hasMissingDesignatedInitializers final public class DivBlur : Swift.Sendable {
  public static let type: Swift.String
  final public let radius: DivKit.Expression<Swift.Int>
  final public func resolveRadius(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivBlur : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivBlurTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let radius: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivBlurTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivBlur>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivBlurTemplate
  public typealias ResolvedValue = DivKit.DivBlur
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivBorder : Swift.Sendable {
  final public let cornerRadius: DivKit.Expression<Swift.Int>?
  final public let cornersRadius: DivKit.DivCornersRadius?
  final public let hasShadow: DivKit.Expression<Swift.Bool>
  final public let shadow: DivKit.DivShadow?
  final public let stroke: DivKit.DivStroke?
  final public func resolveCornerRadius(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveHasShadow(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivBorder : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivBorderTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let cornerRadius: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let cornersRadius: DivKit.Field<DivKit.DivCornersRadiusTemplate>?
  final public let hasShadow: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let shadow: DivKit.Field<DivKit.DivShadowTemplate>?
  final public let stroke: DivKit.Field<DivKit.DivStrokeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivBorderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivBorder>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivBorderTemplate
  public typealias ResolvedValue = DivKit.DivBorder
  @objc deinit
}
public enum CardIDTag {
}
public typealias DivCardID = VGSLFundamentals.Tagged<DivKit.CardIDTag, Swift.String>
public typealias DivCardUpdateReason = DivKit.DivActionURLHandler.UpdateReason
@_hasMissingDesignatedInitializers final public class DivChangeBoundsTransition : DivKit.DivTransitionBase, Swift.Sendable {
  public static let type: Swift.String
  final public let duration: DivKit.Expression<Swift.Int>
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivChangeBoundsTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivChangeBoundsTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivChangeBoundsTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivChangeBoundsTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivChangeBoundsTransitionTemplate
  public typealias ResolvedValue = DivKit.DivChangeBoundsTransition
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivChangeSetTransition : Swift.Sendable {
  public static let type: Swift.String
  final public let items: [DivKit.DivChangeTransition]
  @objc deinit
}
extension DivKit.DivChangeSetTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivChangeSetTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let items: DivKit.Field<[DivKit.DivChangeTransitionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivChangeSetTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivChangeSetTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivChangeSetTransitionTemplate
  public typealias ResolvedValue = DivKit.DivChangeSetTransition
  @objc deinit
}
@frozen public enum DivChangeTransition : Swift.Sendable {
  case divChangeSetTransition(DivKit.DivChangeSetTransition)
  case divChangeBoundsTransition(DivKit.DivChangeBoundsTransition)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivChangeTransition : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivChangeTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divChangeSetTransitionTemplate(DivKit.DivChangeSetTransitionTemplate)
  case divChangeBoundsTransitionTemplate(DivKit.DivChangeBoundsTransitionTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivChangeTransitionTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivChangeTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivChangeTransition>
  public typealias ResolvedValue = DivKit.DivChangeTransition
}
extension DivKit.DivChangeTransitionTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivCircleShape : Swift.Sendable {
  public static let type: Swift.String
  final public let backgroundColor: DivKit.Expression<VGSLUI.Color>?
  final public let radius: DivKit.DivFixedSize
  final public let stroke: DivKit.DivStroke?
  final public func resolveBackgroundColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.DivCircleShape : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivCircleShapeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let backgroundColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let radius: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let stroke: DivKit.Field<DivKit.DivStrokeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCircleShapeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCircleShape>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCircleShapeTemplate
  public typealias ResolvedValue = DivKit.DivCircleShape
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivCloudBackground : Swift.Sendable {
  public static let type: Swift.String
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let cornerRadius: DivKit.Expression<Swift.Int>
  final public let paddings: DivKit.DivEdgeInsets?
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveCornerRadius(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivCloudBackground : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivCloudBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let cornerRadius: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCloudBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCloudBackground>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCloudBackgroundTemplate
  public typealias ResolvedValue = DivKit.DivCloudBackground
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivCollectionItemBuilder : @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Prototype : Swift.Sendable {
    final public let div: DivKit.Div
    final public let id: DivKit.Expression<Swift.String>?
    final public let selector: DivKit.Expression<Swift.Bool>
    final public func resolveId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveSelector(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
    @objc deinit
  }
  final public let data: DivKit.Expression<[Any]>
  final public let dataElementName: Swift.String
  final public let prototypes: [DivKit.DivCollectionItemBuilder.Prototype]
  final public func resolveData(_ resolver: DivKit.ExpressionResolver) -> [Any]?
  @objc deinit
}
extension DivKit.DivCollectionItemBuilder : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivCollectionItemBuilder.Prototype : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivCollectionItemBuilderTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class PrototypeTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let div: DivKit.Field<DivKit.DivTemplate>?
    final public let id: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let selector: DivKit.Field<DivKit.Expression<Swift.Bool>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCollectionItemBuilderTemplate.PrototypeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCollectionItemBuilder.Prototype>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCollectionItemBuilderTemplate.PrototypeTemplate
    public typealias ResolvedValue = DivKit.DivCollectionItemBuilder.Prototype
    @objc deinit
  }
  final public let data: DivKit.Field<DivKit.Expression<[Any]>>?
  final public let dataElementName: DivKit.Field<Swift.String>?
  final public let prototypes: DivKit.Field<[DivKit.DivCollectionItemBuilderTemplate.PrototypeTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCollectionItemBuilderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCollectionItemBuilder>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCollectionItemBuilderTemplate
  public typealias ResolvedValue = DivKit.DivCollectionItemBuilder
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivColorAnimator : DivKit.DivAnimatorBase, Swift.Sendable {
  public static let type: Swift.String
  final public let cancelActions: [DivKit.DivAction]?
  final public let direction: DivKit.Expression<DivKit.DivAnimationDirection>
  final public let duration: DivKit.Expression<Swift.Int>
  final public let endActions: [DivKit.DivAction]?
  final public let endValue: DivKit.Expression<VGSLUI.Color>
  final public let id: Swift.String
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let repeatCount: DivKit.DivCount
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public let startValue: DivKit.Expression<VGSLUI.Color>?
  final public let variableName: Swift.String
  final public func resolveDirection(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationDirection
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveEndValue(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveStartValue(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.DivColorAnimator : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivColorAnimatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let cancelActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let direction: DivKit.Field<DivKit.Expression<DivKit.DivAnimationDirection>>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let endActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let endValue: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let id: DivKit.Field<Swift.String>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let repeatCount: DivKit.Field<DivKit.DivCountTemplate>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let startValue: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let variableName: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivColorAnimatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivColorAnimator>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivColorAnimatorTemplate
  public typealias ResolvedValue = DivKit.DivColorAnimator
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivContainer : DivKit.DivBase, Swift.Sendable {
  @frozen public enum LayoutMode : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case noWrap
    case wrap
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivContainer.LayoutMode]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivContainer.LayoutMode] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Orientation : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case vertical
    case horizontal
    case overlap
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivContainer.Orientation]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivContainer.Orientation] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class Separator : Swift.Sendable {
    final public let margins: DivKit.DivEdgeInsets?
    final public let showAtEnd: DivKit.Expression<Swift.Bool>
    final public let showAtStart: DivKit.Expression<Swift.Bool>
    final public let showBetween: DivKit.Expression<Swift.Bool>
    final public let style: DivKit.DivDrawable
    final public func resolveShowAtEnd(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
    final public func resolveShowAtStart(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
    final public func resolveShowBetween(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let aspect: DivKit.DivAspect?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let clipToBounds: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let contentAlignmentHorizontal: DivKit.Expression<DivKit.DivContentAlignmentHorizontal>
  final public let contentAlignmentVertical: DivKit.Expression<DivKit.DivContentAlignmentVertical>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let itemBuilder: DivKit.DivCollectionItemBuilder?
  final public let items: [DivKit.Div]?
  final public let layoutMode: DivKit.Expression<DivKit.DivContainer.LayoutMode>
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let lineSeparator: DivKit.DivContainer.Separator?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let orientation: DivKit.Expression<DivKit.DivContainer.Orientation>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let separator: DivKit.DivContainer.Separator?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveClipToBounds(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveContentAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivContentAlignmentHorizontal
  final public func resolveContentAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivContentAlignmentVertical
  final public func resolveLayoutMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivContainer.LayoutMode
  final public func resolveOrientation(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivContainer.Orientation
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivContainer : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivContainer.Separator : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivContainer : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivContainerTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class SeparatorTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
    final public let showAtEnd: DivKit.Field<DivKit.Expression<Swift.Bool>>?
    final public let showAtStart: DivKit.Field<DivKit.Expression<Swift.Bool>>?
    final public let showBetween: DivKit.Field<DivKit.Expression<Swift.Bool>>?
    final public let style: DivKit.Field<DivKit.DivDrawableTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivContainerTemplate.SeparatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivContainer.Separator>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivContainerTemplate.SeparatorTemplate
    public typealias ResolvedValue = DivKit.DivContainer.Separator
    @objc deinit
  }
  public typealias LayoutMode = DivKit.DivContainer.LayoutMode
  public typealias Orientation = DivKit.DivContainer.Orientation
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let aspect: DivKit.Field<DivKit.DivAspectTemplate>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let clipToBounds: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let contentAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivContentAlignmentHorizontal>>?
  final public let contentAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivContentAlignmentVertical>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let itemBuilder: DivKit.Field<DivKit.DivCollectionItemBuilderTemplate>?
  final public let items: DivKit.Field<[DivKit.DivTemplate]>?
  final public let layoutMode: DivKit.Field<DivKit.Expression<DivKit.DivContainerTemplate.LayoutMode>>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let lineSeparator: DivKit.Field<DivKit.DivContainerTemplate.SeparatorTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let orientation: DivKit.Field<DivKit.Expression<DivKit.DivContainerTemplate.Orientation>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let separator: DivKit.Field<DivKit.DivContainerTemplate.SeparatorTemplate>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivContainerTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivContainer>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivContainerTemplate
  public typealias ResolvedValue = DivKit.DivContainer
  @objc deinit
}
@frozen public enum DivContentAlignmentHorizontal : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case left
  case center
  case right
  case start
  case end
  case spaceBetween
  case spaceAround
  case spaceEvenly
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivContentAlignmentHorizontal]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivContentAlignmentHorizontal] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@frozen public enum DivContentAlignmentVertical : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case top
  case center
  case bottom
  case baseline
  case spaceBetween
  case spaceAround
  case spaceEvenly
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivContentAlignmentVertical]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivContentAlignmentVertical] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivCornersRadius : Swift.Sendable {
  final public let bottomLeft: DivKit.Expression<Swift.Int>?
  final public let bottomRight: DivKit.Expression<Swift.Int>?
  final public let topLeft: DivKit.Expression<Swift.Int>?
  final public let topRight: DivKit.Expression<Swift.Int>?
  final public func resolveBottomLeft(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveBottomRight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveTopLeft(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveTopRight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivCornersRadius : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivCornersRadiusTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let bottomLeft: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let bottomRight: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let topLeft: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let topRight: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCornersRadiusTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCornersRadius>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCornersRadiusTemplate
  public typealias ResolvedValue = DivKit.DivCornersRadius
  @objc deinit
}
@frozen public enum DivCount : Swift.Sendable {
  case divInfinityCount(DivKit.DivInfinityCount)
  case divFixedCount(DivKit.DivFixedCount)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivCount : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivCountTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divInfinityCountTemplate(DivKit.DivInfinityCountTemplate)
  case divFixedCountTemplate(DivKit.DivFixedCountTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCountTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCountTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCount>
  public typealias ResolvedValue = DivKit.DivCount
}
extension DivKit.DivCountTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivCurrencyInputMask : DivKit.DivInputMaskBase, Swift.Sendable {
  public static let type: Swift.String
  final public let locale: DivKit.Expression<Swift.String>?
  final public let rawTextVariable: Swift.String
  final public func resolveLocale(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivCurrencyInputMask : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivCurrencyInputMaskTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let locale: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rawTextVariable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCurrencyInputMaskTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCurrencyInputMask>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCurrencyInputMaskTemplate
  public typealias ResolvedValue = DivKit.DivCurrencyInputMask
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivCustom : DivKit.DivBase, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let customProps: [Swift.String : Any]?
  final public let customType: Swift.String
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let items: [DivKit.Div]?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivCustom : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public protocol DivCustomBlockFactory {
  func makeBlock(data: DivKit.DivCustomData, context: DivKit.DivBlockModelingContext) -> any LayoutKit.Block
}
public struct DivCustomData {
  public let name: Swift.String
  public let data: [Swift.String : Any]
  public let children: [any LayoutKit.Block]
  public let widthTrait: LayoutKit.LayoutTrait
  public let heightTrait: LayoutKit.LayoutTrait
}
extension DivKit.DivCustom : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivCustomTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let customProps: DivKit.Field<[Swift.String : Any]>?
  final public let customType: DivKit.Field<Swift.String>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let items: DivKit.Field<[DivKit.DivTemplate]>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivCustomTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivCustom>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivCustomTemplate
  public typealias ResolvedValue = DivKit.DivCustom
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivData : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class State : Swift.Sendable {
    final public let div: DivKit.Div
    final public let stateId: Swift.Int
    @objc deinit
  }
  final public let functions: [DivKit.DivFunction]?
  final public let logId: Swift.String
  final public let states: [DivKit.DivData.State]
  final public let timers: [DivKit.DivTimer]?
  final public let transitionAnimationSelector: DivKit.Expression<DivKit.DivTransitionSelector>
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public func resolveTransitionAnimationSelector(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTransitionSelector
  @objc deinit
}
extension DivKit.DivData : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivData.State : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivData : DivKit.DivBlockModeling {
  final public var id: Swift.String? {
    get
  }
  public static var type: Swift.String {
    get
  }
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
extension DivKit.DivData {
  public static func resolve(card cardDict: [Swift.String : Any], templates templatesDict: [Swift.String : Any]?) -> Serialization.DeserializationResult<DivKit.DivData>
}
extension DivKit.DivData {
  final public func flatMap<T>(_ transform: (DivKit.Div) -> T) -> [T]
}
extension DivKit.DivData {
  final public func applyPatch(_ patch: DivKit.DivPatch) -> DivKit.DivData
  final public func applyPatchWithActions(_ patch: DivKit.DivPatch, context: DivKit.DivBlockModelingContext) -> DivKit.DivData
}
public enum ResourcePreloadFilter {
  case all, onlyRequired
  public static func == (a: DivKit.ResourcePreloadFilter, b: DivKit.ResourcePreloadFilter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class DivDataResourcesPreloader {
  public init(resourceRequester: any VGSLFundamentals.URLResourceRequesting)
  final public func downloadResources(for divData: DivKit.DivData, filter: DivKit.ResourcePreloadFilter, context: DivKit.DivBlockModelingContext, completion: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivDataTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class StateTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let div: DivKit.Field<DivKit.DivTemplate>?
    final public let stateId: DivKit.Field<Swift.Int>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDataTemplate.StateTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivData.State>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDataTemplate.StateTemplate
    public typealias ResolvedValue = DivKit.DivData.State
    @objc deinit
  }
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let logId: DivKit.Field<Swift.String>?
  final public let states: DivKit.Field<[DivKit.DivDataTemplate.StateTemplate]>?
  final public let timers: DivKit.Field<[DivKit.DivTimerTemplate]>?
  final public let transitionAnimationSelector: DivKit.Field<DivKit.Expression<DivKit.DivTransitionSelector>>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDataTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivData>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDataTemplate
  public typealias ResolvedValue = DivKit.DivData
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivDefaultIndicatorItemPlacement : Swift.Sendable {
  public static let type: Swift.String
  final public let spaceBetweenCenters: DivKit.DivFixedSize
  @objc deinit
}
extension DivKit.DivDefaultIndicatorItemPlacement : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivDefaultIndicatorItemPlacementTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let spaceBetweenCenters: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDefaultIndicatorItemPlacementTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivDefaultIndicatorItemPlacement>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDefaultIndicatorItemPlacementTemplate
  public typealias ResolvedValue = DivKit.DivDefaultIndicatorItemPlacement
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivDimension : Swift.Sendable {
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivDimension : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivDimensionTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDimensionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivDimension>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDimensionTemplate
  public typealias ResolvedValue = DivKit.DivDimension
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivDisappearAction : DivKit.DivSightAction, @unchecked Swift.Sendable {
  final public let disappearDuration: DivKit.Expression<Swift.Int>
  final public let downloadCallbacks: DivKit.DivDownloadCallbacks?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let logId: DivKit.Expression<Swift.String>
  final public let logLimit: DivKit.Expression<Swift.Int>
  final public let payload: [Swift.String : Any]?
  final public let referer: DivKit.Expression<Foundation.URL>?
  final public let scopeId: Swift.String?
  final public let typed: DivKit.DivActionTyped?
  final public let url: DivKit.Expression<Foundation.URL>?
  final public let visibilityPercentage: DivKit.Expression<Swift.Int>
  final public func resolveDisappearDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveLogId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveLogLimit(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveReferer(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveVisibilityPercentage(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivDisappearAction : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivDisappearActionTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  final public let disappearDuration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let downloadCallbacks: DivKit.Field<DivKit.DivDownloadCallbacksTemplate>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let logId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let logLimit: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let payload: DivKit.Field<[Swift.String : Any]>?
  final public let referer: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let scopeId: DivKit.Field<Swift.String>?
  final public let typed: DivKit.Field<DivKit.DivActionTypedTemplate>?
  final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let visibilityPercentage: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDisappearActionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivDisappearAction>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDisappearActionTemplate
  public typealias ResolvedValue = DivKit.DivDisappearAction
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivDownloadCallbacks : Swift.Sendable {
  final public let onFailActions: [DivKit.DivAction]?
  final public let onSuccessActions: [DivKit.DivAction]?
  @objc deinit
}
extension DivKit.DivDownloadCallbacks : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivDownloadCallbacksTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let onFailActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let onSuccessActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDownloadCallbacksTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivDownloadCallbacks>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDownloadCallbacksTemplate
  public typealias ResolvedValue = DivKit.DivDownloadCallbacks
  @objc deinit
}
@frozen public enum DivDrawable : Swift.Sendable {
  case divShapeDrawable(DivKit.DivShapeDrawable)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivDrawable : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivDrawableTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divShapeDrawableTemplate(DivKit.DivShapeDrawableTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivDrawableTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivDrawableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivDrawable>
  public typealias ResolvedValue = DivKit.DivDrawable
}
extension DivKit.DivDrawableTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivEdgeInsets : Swift.Sendable {
  final public let bottom: DivKit.Expression<Swift.Int>
  final public let end: DivKit.Expression<Swift.Int>?
  final public let left: DivKit.Expression<Swift.Int>
  final public let right: DivKit.Expression<Swift.Int>
  final public let start: DivKit.Expression<Swift.Int>?
  final public let top: DivKit.Expression<Swift.Int>
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public func resolveBottom(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveEnd(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveLeft(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveRight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveStart(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveTop(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  @objc deinit
}
extension DivKit.DivEdgeInsets : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivEdgeInsetsTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let bottom: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let end: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let left: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let right: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let start: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let top: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivEdgeInsetsTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivEdgeInsets>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivEdgeInsetsTemplate
  public typealias ResolvedValue = DivKit.DivEdgeInsets
  @objc deinit
}
public protocol DivError : Swift.CustomStringConvertible {
  var kind: DivKit.DivErrorKind { get }
  var message: Swift.String { get }
  var path: LayoutKitInterface.UIElementPath { get }
  var causes: [any DivKit.DivError] { get }
  var level: DivKit.DivErrorLevel { get }
}
public enum DivErrorKind : Swift.String {
  case deserialization
  case blockModeling
  case layout
  case expression
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension DivKit.DivError {
  public var causes: [any DivKit.DivError] {
    get
  }
}
extension DivKit.DivError {
  public var rootCauses: [any DivKit.DivError] {
    get
  }
}
extension DivKit.DivError {
  public var description: Swift.String {
    get
  }
}
extension DivKit.DivError {
  public var prettyMessage: Swift.String {
    get
  }
}
public enum DivErrorLevel {
  case warning
  case error
  public static func == (a: DivKit.DivErrorLevel, b: DivKit.DivErrorLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Serialization.DeserializationError : DivKit.DivError {
  public var message: Swift.String {
    get
  }
  public var path: LayoutKitInterface.UIElementPath {
    get
  }
  public var kind: DivKit.DivErrorKind {
    get
  }
  public var level: DivKit.DivErrorLevel {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivErrorsStorage {
  final public var errors: [any DivKit.DivError] {
    get
  }
  @objc deinit
}
@frozen public enum DivEvaluableType : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case string
  case integer
  case number
  case boolean
  case datetime
  case color
  case url
  case dict
  case array
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivEvaluableType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivEvaluableType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivExtension : @unchecked Swift.Sendable {
  final public let id: Swift.String
  final public let params: [Swift.String : Any]?
  @objc deinit
}
extension DivKit.DivExtension : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public protocol DivExtensionHandler : LayoutKit.AccessibilityContaining {
  var id: Swift.String { get }
  func accept(div: any DivKit.DivBase, context: DivKit.DivBlockModelingContext)
  func applyBeforeBaseProperties(to block: any LayoutKit.Block, div: any DivKit.DivBase, context: DivKit.DivBlockModelingContext) -> any LayoutKit.Block
  func applyAfterBaseProperties(to block: any LayoutKit.Block, div: any DivKit.DivBase, context: DivKit.DivBlockModelingContext) -> any LayoutKit.Block
  func getPreloadURLs(div: any DivKit.DivBase, expressionResolver: DivKit.ExpressionResolver) -> [Foundation.URL]
}
extension DivKit.DivExtensionHandler {
  public func accept(div _: any DivKit.DivBase, context _: DivKit.DivBlockModelingContext)
  public func applyBeforeBaseProperties(to block: any LayoutKit.Block, div _: any DivKit.DivBase, context _: DivKit.DivBlockModelingContext) -> any LayoutKit.Block
  public func applyAfterBaseProperties(to block: any LayoutKit.Block, div _: any DivKit.DivBase, context _: DivKit.DivBlockModelingContext) -> any LayoutKit.Block
  public func getPreloadURLs(div _: any DivKit.DivBase, expressionResolver _: DivKit.ExpressionResolver) -> [Foundation.URL]
  public func getExtensionParams(_ div: any DivKit.DivBase) -> [Swift.String : Any]
}
@_hasMissingDesignatedInitializers final public class DivExtensionTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  final public let id: DivKit.Field<Swift.String>?
  final public let params: DivKit.Field<[Swift.String : Any]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivExtensionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivExtension>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivExtensionTemplate
  public typealias ResolvedValue = DivKit.DivExtension
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivFadeTransition : DivKit.DivTransitionBase, Swift.Sendable {
  public static let type: Swift.String
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let duration: DivKit.Expression<Swift.Int>
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivFadeTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFadeTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFadeTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFadeTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFadeTransitionTemplate
  public typealias ResolvedValue = DivKit.DivFadeTransition
  @objc deinit
}
@frozen public enum DivFilter : Swift.Sendable {
  case divBlur(DivKit.DivBlur)
  case divFilterRtlMirror(DivKit.DivFilterRtlMirror)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivFilter : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFilterRtlMirror : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivFilterRtlMirror : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFilterRtlMirrorTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFilterRtlMirrorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFilterRtlMirror>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFilterRtlMirrorTemplate
  public typealias ResolvedValue = DivKit.DivFilterRtlMirror
  @objc deinit
}
@frozen public enum DivFilterTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divBlurTemplate(DivKit.DivBlurTemplate)
  case divFilterRtlMirrorTemplate(DivKit.DivFilterRtlMirrorTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFilterTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFilterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFilter>
  public typealias ResolvedValue = DivKit.DivFilter
}
extension DivKit.DivFilterTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivFixedCount : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivFixedCount : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFixedCountTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFixedCountTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFixedCount>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFixedCountTemplate
  public typealias ResolvedValue = DivKit.DivFixedCount
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivFixedLengthInputMask : DivKit.DivInputMaskBase, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class PatternElement : Swift.Sendable {
    final public let key: DivKit.Expression<Swift.String>
    final public let placeholder: DivKit.Expression<Swift.String>
    final public let regex: DivKit.Expression<Swift.String>?
    final public func resolveKey(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolvePlaceholder(_ resolver: DivKit.ExpressionResolver) -> Swift.String
    final public func resolveRegex(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  public static let type: Swift.String
  final public let alwaysVisible: DivKit.Expression<Swift.Bool>
  final public let pattern: DivKit.Expression<Swift.String>
  final public let patternElements: [DivKit.DivFixedLengthInputMask.PatternElement]
  final public let rawTextVariable: Swift.String
  final public func resolveAlwaysVisible(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolvePattern(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivFixedLengthInputMask : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivFixedLengthInputMask.PatternElement : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFixedLengthInputMaskTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class PatternElementTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let key: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let placeholder: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let regex: DivKit.Field<DivKit.Expression<Swift.String>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFixedLengthInputMaskTemplate.PatternElementTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFixedLengthInputMask.PatternElement>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFixedLengthInputMaskTemplate.PatternElementTemplate
    public typealias ResolvedValue = DivKit.DivFixedLengthInputMask.PatternElement
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let alwaysVisible: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let pattern: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let patternElements: DivKit.Field<[DivKit.DivFixedLengthInputMaskTemplate.PatternElementTemplate]>?
  final public let rawTextVariable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFixedLengthInputMaskTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFixedLengthInputMask>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFixedLengthInputMaskTemplate
  public typealias ResolvedValue = DivKit.DivFixedLengthInputMask
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivFixedSize : Swift.Sendable {
  public static let type: Swift.String
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivFixedSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFixedSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFixedSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFixedSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFixedSizeTemplate
  public typealias ResolvedValue = DivKit.DivFixedSize
  @objc deinit
}
public struct DivFlagsInfo {
  public let useUrlHandlerForVisibilityActions: Swift.Bool
  public let imageBlurPreferMetal: Swift.Bool
  public let imageTintPreferMetal: Swift.Bool
  public let useTooltipLegacyWidth: Swift.Bool
  public let defaultTextAutoEllipsize: Swift.Bool
  public let initializeTriggerOnSet: Swift.Bool
  public let fontCacheEnabled: Swift.Bool
  public init(useUrlHandlerForVisibilityActions: Swift.Bool = false, imageBlurPreferMetal: Swift.Bool = true, imageTintPreferMetal: Swift.Bool = true, useTooltipLegacyWidth: Swift.Bool = false, initializeTriggerOnSet: Swift.Bool = true, defaultTextAutoEllipsize: Swift.Bool = true, fontCacheEnabled: Swift.Bool = true)
  public static let `default`: DivKit.DivFlagsInfo
}
@_hasMissingDesignatedInitializers final public class DivFocus : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class NextFocusIds : Swift.Sendable {
    final public let down: DivKit.Expression<Swift.String>?
    final public let forward: DivKit.Expression<Swift.String>?
    final public let left: DivKit.Expression<Swift.String>?
    final public let right: DivKit.Expression<Swift.String>?
    final public let up: DivKit.Expression<Swift.String>?
    final public func resolveDown(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveForward(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveLeft(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveRight(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveUp(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let nextFocusIds: DivKit.DivFocus.NextFocusIds?
  final public let onBlur: [DivKit.DivAction]?
  final public let onFocus: [DivKit.DivAction]?
  @objc deinit
}
extension DivKit.DivFocus : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivFocus.NextFocusIds : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFocusTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class NextFocusIdsTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let down: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let forward: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let left: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let right: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let up: DivKit.Field<DivKit.Expression<Swift.String>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFocusTemplate.NextFocusIdsTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFocus.NextFocusIds>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFocusTemplate.NextFocusIdsTemplate
    public typealias ResolvedValue = DivKit.DivFocus.NextFocusIds
    @objc deinit
  }
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let nextFocusIds: DivKit.Field<DivKit.DivFocusTemplate.NextFocusIdsTemplate>?
  final public let onBlur: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let onFocus: DivKit.Field<[DivKit.DivActionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFocusTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFocus>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFocusTemplate
  public typealias ResolvedValue = DivKit.DivFocus
  @objc deinit
}
public protocol DivFontProvider {
  func font(family: Swift.String, weight: DivKit.DivFontWeight, size: CoreFoundation.CGFloat) -> VGSLUI.Font
  func font(family: Swift.String, weight: Swift.Int, size: CoreFoundation.CGFloat) -> VGSLUI.Font
}
extension DivKit.DivFontProvider {
  public func font(weight: DivKit.DivFontWeight = .regular, size: CoreFoundation.CGFloat) -> VGSLUI.Font
  public func font(family: Swift.String, weight: Swift.Int, size: CoreFoundation.CGFloat) -> VGSLUI.Font
}
@frozen public enum DivFontWeight : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case light
  case medium
  case regular
  case bold
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivFontWeight]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivFontWeight] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivFunction : Swift.Sendable {
  final public let arguments: [DivKit.DivFunctionArgument]
  final public let body: Swift.String
  final public let name: Swift.String
  final public let returnType: DivKit.DivEvaluableType
  @objc deinit
}
extension DivKit.DivFunction : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFunctionArgument : Swift.Sendable {
  final public let name: Swift.String
  final public let type: DivKit.DivEvaluableType
  @objc deinit
}
extension DivKit.DivFunctionArgument : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivFunctionArgumentTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let name: DivKit.Field<Swift.String>?
  final public let type: DivKit.Field<DivKit.DivEvaluableType>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFunctionArgumentTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFunctionArgument>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFunctionArgumentTemplate
  public typealias ResolvedValue = DivKit.DivFunctionArgument
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivFunctionTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let arguments: DivKit.Field<[DivKit.DivFunctionArgumentTemplate]>?
  final public let body: DivKit.Field<Swift.String>?
  final public let name: DivKit.Field<Swift.String>?
  final public let returnType: DivKit.Field<DivKit.DivEvaluableType>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivFunctionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivFunction>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivFunctionTemplate
  public typealias ResolvedValue = DivKit.DivFunction
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivGallery : DivKit.DivBase, Swift.Sendable {
  @frozen public enum CrossContentAlignment : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case start
    case center
    case end
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivGallery.CrossContentAlignment]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivGallery.CrossContentAlignment] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Orientation : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case horizontal
    case vertical
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivGallery.Orientation]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivGallery.Orientation] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum ScrollMode : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case paging
    case `default`
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivGallery.ScrollMode]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivGallery.ScrollMode] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Scrollbar : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case none
    case auto
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivGallery.Scrollbar]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivGallery.Scrollbar] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnCount: DivKit.Expression<Swift.Int>?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let crossContentAlignment: DivKit.Expression<DivKit.DivGallery.CrossContentAlignment>
  final public let crossSpacing: DivKit.Expression<Swift.Int>?
  final public let defaultItem: DivKit.Expression<Swift.Int>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let itemBuilder: DivKit.DivCollectionItemBuilder?
  final public let itemSpacing: DivKit.Expression<Swift.Int>
  final public let items: [DivKit.Div]?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let orientation: DivKit.Expression<DivKit.DivGallery.Orientation>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let restrictParentScroll: DivKit.Expression<Swift.Bool>
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let scrollMode: DivKit.Expression<DivKit.DivGallery.ScrollMode>
  final public let scrollbar: DivKit.Expression<DivKit.DivGallery.Scrollbar>
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnCount(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveCrossContentAlignment(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivGallery.CrossContentAlignment
  final public func resolveCrossSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveDefaultItem(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveItemSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveOrientation(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivGallery.Orientation
  final public func resolveRestrictParentScroll(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveScrollMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivGallery.ScrollMode
  final public func resolveScrollbar(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivGallery.Scrollbar
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivGallery : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivGallery : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivGalleryTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias CrossContentAlignment = DivKit.DivGallery.CrossContentAlignment
  public typealias Orientation = DivKit.DivGallery.Orientation
  public typealias ScrollMode = DivKit.DivGallery.ScrollMode
  public typealias Scrollbar = DivKit.DivGallery.Scrollbar
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnCount: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let crossContentAlignment: DivKit.Field<DivKit.Expression<DivKit.DivGalleryTemplate.CrossContentAlignment>>?
  final public let crossSpacing: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let defaultItem: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let itemBuilder: DivKit.Field<DivKit.DivCollectionItemBuilderTemplate>?
  final public let itemSpacing: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let items: DivKit.Field<[DivKit.DivTemplate]>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let orientation: DivKit.Field<DivKit.Expression<DivKit.DivGalleryTemplate.Orientation>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let restrictParentScroll: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let scrollMode: DivKit.Field<DivKit.Expression<DivKit.DivGalleryTemplate.ScrollMode>>?
  final public let scrollbar: DivKit.Field<DivKit.Expression<DivKit.DivGalleryTemplate.Scrollbar>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivGalleryTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivGallery>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivGalleryTemplate
  public typealias ResolvedValue = DivKit.DivGallery
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivGifImage : DivKit.DivBase, Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let aspect: DivKit.DivAspect?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let contentAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let contentAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let gifUrl: DivKit.Expression<Foundation.URL>
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let placeholderColor: DivKit.Expression<VGSLUI.Color>
  final public let preloadRequired: DivKit.Expression<Swift.Bool>
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let preview: DivKit.Expression<Swift.String>?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let scale: DivKit.Expression<DivKit.DivImageScale>
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveContentAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveContentAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveGifUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolvePlaceholderColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolvePreloadRequired(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolvePreview(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveScale(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivImageScale
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivGifImage : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivGifImage : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivGifImageTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let aspect: DivKit.Field<DivKit.DivAspectTemplate>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let contentAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let contentAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let gifUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let placeholderColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let preloadRequired: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let preview: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let scale: DivKit.Field<DivKit.Expression<DivKit.DivImageScale>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivGifImageTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivGifImage>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivGifImageTemplate
  public typealias ResolvedValue = DivKit.DivGifImage
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivGrid : DivKit.DivBase, Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let columnCount: DivKit.Expression<Swift.Int>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let contentAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let contentAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let items: [DivKit.Div]?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnCount(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveContentAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveContentAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivGrid : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivGrid : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivGridTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnCount: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let contentAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let contentAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let items: DivKit.Field<[DivKit.DivTemplate]>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivGridTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivGrid>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivGridTemplate
  public typealias ResolvedValue = DivKit.DivGrid
  @objc deinit
}
@_Concurrency.MainActor @preconcurrency public struct DivHostingView : SwiftUI.UIViewRepresentable {
  @_Concurrency.MainActor @preconcurrency public init(divkitComponents: DivKit.DivKitComponents = DivKitComponents(), divViewPreloader: DivKit.DivViewPreloader? = nil, source: DivKit.DivViewSource, debugParams: DivKit.DebugParams = DebugParams(), shouldResetPreviousCardData: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency public func makeUIView(context _: DivKit.DivHostingView.Context) -> UIKit.UIView
  @_Concurrency.MainActor @preconcurrency public func updateUIView(_ uiView: UIKit.UIView, context _: DivKit.DivHostingView.Context)
  public typealias Body = Swift.Never
  public typealias Coordinator = Swift.Void
  public typealias UIViewType = UIKit.UIView
}
@_hasMissingDesignatedInitializers final public class DivImage : DivKit.DivBase, Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let appearanceAnimation: DivKit.DivFadeTransition?
  final public let aspect: DivKit.DivAspect?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let contentAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let contentAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let filters: [DivKit.DivFilter]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let highPriorityPreviewShow: DivKit.Expression<Swift.Bool>
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let imageUrl: DivKit.Expression<Foundation.URL>
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let placeholderColor: DivKit.Expression<VGSLUI.Color>
  final public let preloadRequired: DivKit.Expression<Swift.Bool>
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let preview: DivKit.Expression<Swift.String>?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let scale: DivKit.Expression<DivKit.DivImageScale>
  final public let selectedActions: [DivKit.DivAction]?
  final public let tintColor: DivKit.Expression<VGSLUI.Color>?
  final public let tintMode: DivKit.Expression<DivKit.DivBlendMode>
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveContentAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveContentAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveHighPriorityPreviewShow(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveImageUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolvePlaceholderColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolvePreloadRequired(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolvePreview(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveScale(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivImageScale
  final public func resolveTintColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveTintMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivBlendMode
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivImage : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivImageBackground : Swift.Sendable {
  public static let type: Swift.String
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let contentAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let contentAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let filters: [DivKit.DivFilter]?
  final public let imageUrl: DivKit.Expression<Foundation.URL>
  final public let preloadRequired: DivKit.Expression<Swift.Bool>
  final public let scale: DivKit.Expression<DivKit.DivImageScale>
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveContentAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveContentAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveImageUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolvePreloadRequired(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveScale(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivImageScale
  @objc deinit
}
extension DivKit.DivImageBackground : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivImageBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let contentAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let contentAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let filters: DivKit.Field<[DivKit.DivFilterTemplate]>?
  final public let imageUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let preloadRequired: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let scale: DivKit.Field<DivKit.Expression<DivKit.DivImageScale>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivImageBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivImageBackground>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivImageBackgroundTemplate
  public typealias ResolvedValue = DivKit.DivImageBackground
  @objc deinit
}
extension DivKit.DivImage : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
public protocol DivImageHolderFactory {
  func make(_ url: Foundation.URL?, _ placeholder: VGSLUI.ImagePlaceholder?) -> any VGSLUI.ImageHolder
}
extension DivKit.DivImageHolderFactory {
  public func make(_ url: Foundation.URL?) -> any VGSLUI.ImageHolder
  public func withCache(_ cachedImageHolders: [any VGSLUI.ImageHolder]) -> any DivKit.DivImageHolderFactory
  public func withAssets() -> any DivKit.DivImageHolderFactory
}
extension VGSLNetworking.ImageHolderFactory : DivKit.DivImageHolderFactory {
}
@frozen public enum DivImageScale : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case fill
  case noScale
  case fit
  case stretch
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivImageScale]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivImageScale] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivImageTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let appearanceAnimation: DivKit.Field<DivKit.DivFadeTransitionTemplate>?
  final public let aspect: DivKit.Field<DivKit.DivAspectTemplate>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let contentAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let contentAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let filters: DivKit.Field<[DivKit.DivFilterTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let highPriorityPreviewShow: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let imageUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let placeholderColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let preloadRequired: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let preview: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let scale: DivKit.Field<DivKit.Expression<DivKit.DivImageScale>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tintColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let tintMode: DivKit.Field<DivKit.Expression<DivKit.DivBlendMode>>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivImageTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivImage>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivImageTemplate
  public typealias ResolvedValue = DivKit.DivImage
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivIndicator : DivKit.DivBase, Swift.Sendable {
  @frozen public enum Animation : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case scale
    case worm
    case slider
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivIndicator.Animation]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivIndicator.Animation] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let activeItemColor: DivKit.Expression<VGSLUI.Color>
  final public let activeItemSize: DivKit.Expression<Swift.Double>
  final public let activeShape: DivKit.DivRoundedRectangleShape?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animation: DivKit.Expression<DivKit.DivIndicator.Animation>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let inactiveItemColor: DivKit.Expression<VGSLUI.Color>
  final public let inactiveMinimumShape: DivKit.DivRoundedRectangleShape?
  final public let inactiveShape: DivKit.DivRoundedRectangleShape?
  final public let itemsPlacement: DivKit.DivIndicatorItemPlacement?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let minimumItemSize: DivKit.Expression<Swift.Double>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pagerId: Swift.String?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let shape: DivKit.DivShape
  final public let spaceBetweenCenters: DivKit.DivFixedSize
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveActiveItemColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveActiveItemSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveAnimation(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivIndicator.Animation
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveInactiveItemColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveMinimumItemSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivIndicator : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivIndicator : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@frozen public enum DivIndicatorItemPlacement : Swift.Sendable {
  case divDefaultIndicatorItemPlacement(DivKit.DivDefaultIndicatorItemPlacement)
  case divStretchIndicatorItemPlacement(DivKit.DivStretchIndicatorItemPlacement)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivIndicatorItemPlacement : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivIndicatorItemPlacementTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divDefaultIndicatorItemPlacementTemplate(DivKit.DivDefaultIndicatorItemPlacementTemplate)
  case divStretchIndicatorItemPlacementTemplate(DivKit.DivStretchIndicatorItemPlacementTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivIndicatorItemPlacementTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivIndicatorItemPlacementTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivIndicatorItemPlacement>
  public typealias ResolvedValue = DivKit.DivIndicatorItemPlacement
}
extension DivKit.DivIndicatorItemPlacementTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivIndicatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Animation = DivKit.DivIndicator.Animation
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let activeItemColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let activeItemSize: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let activeShape: DivKit.Field<DivKit.DivRoundedRectangleShapeTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animation: DivKit.Field<DivKit.Expression<DivKit.DivIndicatorTemplate.Animation>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let inactiveItemColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let inactiveMinimumShape: DivKit.Field<DivKit.DivRoundedRectangleShapeTemplate>?
  final public let inactiveShape: DivKit.Field<DivKit.DivRoundedRectangleShapeTemplate>?
  final public let itemsPlacement: DivKit.Field<DivKit.DivIndicatorItemPlacementTemplate>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let minimumItemSize: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pagerId: DivKit.Field<Swift.String>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let shape: DivKit.Field<DivKit.DivShapeTemplate>?
  final public let spaceBetweenCenters: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivIndicatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivIndicator>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivIndicatorTemplate
  public typealias ResolvedValue = DivKit.DivIndicator
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivInfinityCount : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivInfinityCount : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInfinityCountTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInfinityCountTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInfinityCount>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInfinityCountTemplate
  public typealias ResolvedValue = DivKit.DivInfinityCount
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivInput : DivKit.DivBase, @unchecked Swift.Sendable {
  @frozen public enum Autocapitalization : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case auto
    case none
    case words
    case sentences
    case allCharacters
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivInput.Autocapitalization]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivInput.Autocapitalization] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum EnterKeyType : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case `default`
    case go
    case search
    case send
    case done
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivInput.EnterKeyType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivInput.EnterKeyType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum KeyboardType : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case singleLineText
    case multiLineText
    case phone
    case number
    case email
    case uri
    case password
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivInput.KeyboardType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivInput.KeyboardType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class NativeInterface : Swift.Sendable {
    final public let color: DivKit.Expression<VGSLUI.Color>
    final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let autocapitalization: DivKit.Expression<DivKit.DivInput.Autocapitalization>
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let enterKeyActions: [DivKit.DivAction]?
  final public let enterKeyType: DivKit.Expression<DivKit.DivInput.EnterKeyType>
  final public let extensions: [DivKit.DivExtension]?
  final public let filters: [DivKit.DivInputFilter]?
  final public let focus: DivKit.DivFocus?
  final public let fontFamily: DivKit.Expression<Swift.String>?
  final public let fontSize: DivKit.Expression<Swift.Int>
  final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let fontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
  final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>
  final public let fontWeightValue: DivKit.Expression<Swift.Int>?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let highlightColor: DivKit.Expression<VGSLUI.Color>?
  final public let hintColor: DivKit.Expression<VGSLUI.Color>
  final public let hintText: DivKit.Expression<Swift.String>?
  final public let id: Swift.String?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let keyboardType: DivKit.Expression<DivKit.DivInput.KeyboardType>
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let letterSpacing: DivKit.Expression<Swift.Double>
  final public let lineHeight: DivKit.Expression<Swift.Int>?
  final public let margins: DivKit.DivEdgeInsets?
  final public let mask: DivKit.DivInputMask?
  final public let maxLength: DivKit.Expression<Swift.Int>?
  final public let maxVisibleLines: DivKit.Expression<Swift.Int>?
  final public let nativeInterface: DivKit.DivInput.NativeInterface?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectAllOnFocus: DivKit.Expression<Swift.Bool>
  final public let selectedActions: [DivKit.DivAction]?
  final public let textAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let textAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let textColor: DivKit.Expression<VGSLUI.Color>
  final public let textVariable: Swift.String
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let validators: [DivKit.DivInputValidator]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveAutocapitalization(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivInput.Autocapitalization
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveEnterKeyType(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivInput.EnterKeyType
  final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
  final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
  final public func resolveFontWeightValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveHighlightColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveHintColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveHintText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveKeyboardType(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivInput.KeyboardType
  final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveLineHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMaxLength(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMaxVisibleLines(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveSelectAllOnFocus(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveTextAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveTextAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivInput : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivInput.NativeInterface : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivInput : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
extension DivKit.DivInput : DivKit.FontParamsProvider {
}
@frozen public enum DivInputFilter : Swift.Sendable {
  case divInputFilterRegex(DivKit.DivInputFilterRegex)
  case divInputFilterExpression(DivKit.DivInputFilterExpression)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivInputFilter : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputFilterExpression : Swift.Sendable {
  public static let type: Swift.String
  final public let condition: DivKit.Expression<Swift.Bool>
  final public func resolveCondition(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  @objc deinit
}
extension DivKit.DivInputFilterExpression : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputFilterExpressionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let condition: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputFilterExpressionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputFilterExpression>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputFilterExpressionTemplate
  public typealias ResolvedValue = DivKit.DivInputFilterExpression
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivInputFilterRegex : Swift.Sendable {
  public static let type: Swift.String
  final public let pattern: DivKit.Expression<Swift.String>
  final public func resolvePattern(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivInputFilterRegex : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputFilterRegexTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let pattern: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputFilterRegexTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputFilterRegex>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputFilterRegexTemplate
  public typealias ResolvedValue = DivKit.DivInputFilterRegex
  @objc deinit
}
@frozen public enum DivInputFilterTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divInputFilterRegexTemplate(DivKit.DivInputFilterRegexTemplate)
  case divInputFilterExpressionTemplate(DivKit.DivInputFilterExpressionTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputFilterTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputFilterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputFilter>
  public typealias ResolvedValue = DivKit.DivInputFilter
}
extension DivKit.DivInputFilterTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@frozen public enum DivInputMask : Swift.Sendable {
  case divFixedLengthInputMask(DivKit.DivFixedLengthInputMask)
  case divCurrencyInputMask(DivKit.DivCurrencyInputMask)
  case divPhoneInputMask(DivKit.DivPhoneInputMask)
  public var value: any DivKit.DivInputMaskBase & Serialization.Serializable {
    get
  }
}
extension DivKit.DivInputMask : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public protocol DivInputMaskBase {
  var rawTextVariable: Swift.String { get }
}
@frozen public enum DivInputMaskTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divFixedLengthInputMaskTemplate(DivKit.DivFixedLengthInputMaskTemplate)
  case divCurrencyInputMaskTemplate(DivKit.DivCurrencyInputMaskTemplate)
  case divPhoneInputMaskTemplate(DivKit.DivPhoneInputMaskTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputMaskTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputMaskTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputMask>
  public typealias ResolvedValue = DivKit.DivInputMask
}
extension DivKit.DivInputMaskTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivInputTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class NativeInterfaceTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputTemplate.NativeInterfaceTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInput.NativeInterface>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputTemplate.NativeInterfaceTemplate
    public typealias ResolvedValue = DivKit.DivInput.NativeInterface
    @objc deinit
  }
  public typealias Autocapitalization = DivKit.DivInput.Autocapitalization
  public typealias EnterKeyType = DivKit.DivInput.EnterKeyType
  public typealias KeyboardType = DivKit.DivInput.KeyboardType
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let autocapitalization: DivKit.Field<DivKit.Expression<DivKit.DivInputTemplate.Autocapitalization>>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let enterKeyActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let enterKeyType: DivKit.Field<DivKit.Expression<DivKit.DivInputTemplate.EnterKeyType>>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let filters: DivKit.Field<[DivKit.DivInputFilterTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let fontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
  final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
  final public let fontWeightValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let highlightColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let hintColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let hintText: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let id: DivKit.Field<Swift.String>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let keyboardType: DivKit.Field<DivKit.Expression<DivKit.DivInputTemplate.KeyboardType>>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let lineHeight: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let mask: DivKit.Field<DivKit.DivInputMaskTemplate>?
  final public let maxLength: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let maxVisibleLines: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let nativeInterface: DivKit.Field<DivKit.DivInputTemplate.NativeInterfaceTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectAllOnFocus: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let textAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let textAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let textColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let textVariable: DivKit.Field<Swift.String>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let validators: DivKit.Field<[DivKit.DivInputValidatorTemplate]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInput>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputTemplate
  public typealias ResolvedValue = DivKit.DivInput
  @objc deinit
}
@frozen public enum DivInputValidator : Swift.Sendable {
  case divInputValidatorRegex(DivKit.DivInputValidatorRegex)
  case divInputValidatorExpression(DivKit.DivInputValidatorExpression)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivInputValidator : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorBase : Swift.Sendable {
  final public let allowEmpty: DivKit.Expression<Swift.Bool>
  final public let labelId: DivKit.Expression<Swift.String>?
  final public let variable: Swift.String?
  final public func resolveAllowEmpty(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveLabelId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivInputValidatorBase : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorBaseTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let allowEmpty: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let labelId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let variable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputValidatorBaseTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputValidatorBase>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputValidatorBaseTemplate
  public typealias ResolvedValue = DivKit.DivInputValidatorBase
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorExpression : Swift.Sendable {
  public static let type: Swift.String
  final public let allowEmpty: DivKit.Expression<Swift.Bool>
  final public let condition: DivKit.Expression<Swift.Bool>
  final public let labelId: DivKit.Expression<Swift.String>
  final public let variable: Swift.String
  final public func resolveAllowEmpty(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveCondition(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  final public func resolveLabelId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivInputValidatorExpression : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorExpressionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let allowEmpty: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let condition: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let labelId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let variable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputValidatorExpressionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputValidatorExpression>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputValidatorExpressionTemplate
  public typealias ResolvedValue = DivKit.DivInputValidatorExpression
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorRegex : Swift.Sendable {
  public static let type: Swift.String
  final public let allowEmpty: DivKit.Expression<Swift.Bool>
  final public let labelId: DivKit.Expression<Swift.String>
  final public let pattern: DivKit.Expression<Swift.String>
  final public let variable: Swift.String
  final public func resolveAllowEmpty(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveLabelId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolvePattern(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.DivInputValidatorRegex : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivInputValidatorRegexTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let allowEmpty: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let labelId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let pattern: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let variable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputValidatorRegexTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputValidatorRegex>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputValidatorRegexTemplate
  public typealias ResolvedValue = DivKit.DivInputValidatorRegex
  @objc deinit
}
@frozen public enum DivInputValidatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divInputValidatorRegexTemplate(DivKit.DivInputValidatorRegexTemplate)
  case divInputValidatorExpressionTemplate(DivKit.DivInputValidatorExpressionTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivInputValidatorTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivInputValidatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivInputValidator>
  public typealias ResolvedValue = DivKit.DivInputValidator
}
extension DivKit.DivInputValidatorTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
final public class DivKitComponents {
  final public let actionHandler: DivKit.DivActionHandler
  final public let blockStateStorage: DivKit.DivBlockStateStorage
  final public let divCustomBlockFactory: any DivKit.DivCustomBlockFactory
  final public var extensionHandlers: [any DivKit.DivExtensionHandler]
  final public let flagsInfo: DivKit.DivFlagsInfo
  final public let fontProvider: any DivKit.DivFontProvider
  final public let imageHolderFactory: any DivKit.DivImageHolderFactory
  final public let layoutDirection: VGSLUI.UserInterfaceLayoutDirection
  final public let patchProvider: any DivKit.DivPatchProvider
  final public let playerFactory: (any LayoutKit.PlayerFactory)?
  final public let reporter: any DivKit.DivReporter
  final public let safeAreaManager: DivKit.DivSafeAreaManager
  final public let stateManagement: any DivKit.DivStateManagement
  final public let submitter: any DivKit.DivSubmitter
  final public let tooltipManager: any LayoutKit.TooltipManager
  final public let triggersStorage: DivKit.DivTriggersStorage
  final public let urlHandler: any DivKit.DivUrlHandler
  final public let variablesStorage: DivKit.DivVariablesStorage
  final public let resourcesPreloader: DivKit.DivDataResourcesPreloader?
  final public var updateCardSignal: VGSLFundamentals.Signal<[DivKit.DivCardUpdateReason]> {
    get
  }
  public init(divCustomBlockFactory: (any DivKit.DivCustomBlockFactory)? = nil, extensionHandlers: [any DivKit.DivExtensionHandler] = [], flagsInfo: DivKit.DivFlagsInfo = .default, fontProvider: (any DivKit.DivFontProvider)? = nil, imageHolderFactory: (any DivKit.DivImageHolderFactory)? = nil, layoutDirection: VGSLUI.UserInterfaceLayoutDirection = .leftToRight, patchProvider: (any DivKit.DivPatchProvider)? = nil, requestPerformer: (any VGSLNetworking.URLRequestPerforming)? = nil, reporter: (any DivKit.DivReporter)? = nil, resourcesPreloader: DivKit.DivDataResourcesPreloader? = nil, showTooltip: DivKit.DivActionHandler.ShowTooltipAction? = nil, stateManagement: any DivKit.DivStateManagement = DefaultDivStateManagement(), submitter: (any DivKit.DivSubmitter)? = nil, tooltipManager: (any LayoutKit.TooltipManager)? = nil, trackVisibility: @escaping DivKit.DivActionHandler.TrackVisibility = { _, _ in }, trackDisappear: @escaping DivKit.DivActionHandler.TrackVisibility = { _, _ in }, playerFactory: (any LayoutKit.PlayerFactory)? = nil, urlHandler: any DivKit.DivUrlHandler = DivUrlHandlerDelegate { _ in }, variablesStorage: DivKit.DivVariablesStorage = DivVariablesStorage())
  final public func reset()
  final public func reset(cardId: DivKit.DivCardID)
  final public func parseDivData(_ jsonDict: [Swift.String : Any], cardId: DivKit.DivCardID) throws -> Serialization.DeserializationResult<DivKit.DivData>
  final public func parseDivDataWithTemplates(_ jsonDict: [Swift.String : Any], cardId: DivKit.DivCardID) throws -> Serialization.DeserializationResult<DivKit.DivData>
  final public func parseDivDataWithTemplates(_ jsonData: Foundation.Data, cardId: DivKit.DivCardID) throws -> Serialization.DeserializationResult<DivKit.DivData>
  final public func makeContext(cardId: DivKit.DivCardID, additionalId: Swift.String? = nil, cachedImageHolders: [any VGSLUI.ImageHolder], debugParams: DivKit.DebugParams = DebugParams(), parentScrollView: (any UIKit.UIView & VGSLUI.ScrollViewType)? = nil) -> DivKit.DivBlockModelingContext
  final public func setCardData(divData: DivKit.DivData, cardId: DivKit.DivCardID)
  final public func setVariablesAndTriggers(divData: DivKit.DivData, cardId: DivKit.DivCardID)
  final public func setTimers(divData: DivKit.DivData, cardId: DivKit.DivCardID)
  final public func flushUpdateActions()
  final public func forceUpdate()
  @objc deinit
}
public enum DivKitInfo {
  public static let version: Swift.String
}
public enum DivKitLogger {
  public static var isEnabled: Swift.Bool
  public static func error(_ message: Swift.String)
  public static func warning(_ message: Swift.String)
  public static func setLogger(_ logger: @escaping (DivKit.DivErrorLevel, Swift.String) -> Swift.Void)
  public static func setLogger(_ logger: @escaping (Swift.String) -> Swift.Void)
}
@_hasMissingDesignatedInitializers final public class DivLayoutProvider : Swift.Sendable {
  final public let heightVariableName: Swift.String?
  final public let widthVariableName: Swift.String?
  @objc deinit
}
extension DivKit.DivLayoutProvider : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivLayoutProviderTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let heightVariableName: DivKit.Field<Swift.String>?
  final public let widthVariableName: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivLayoutProviderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivLayoutProvider>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivLayoutProviderTemplate
  public typealias ResolvedValue = DivKit.DivLayoutProvider
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivLinearGradient : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ColorPoint : Swift.Sendable {
    final public let color: DivKit.Expression<VGSLUI.Color>
    final public let position: DivKit.Expression<Swift.Double>
    final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    final public func resolvePosition(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
    @objc deinit
  }
  public static let type: Swift.String
  final public let angle: DivKit.Expression<Swift.Int>
  final public let colorMap: [DivKit.DivLinearGradient.ColorPoint]?
  final public let colors: [DivKit.Expression<VGSLUI.Color>]?
  final public func resolveAngle(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveColors(_ resolver: DivKit.ExpressionResolver) -> [VGSLUI.Color]?
  @objc deinit
}
extension DivKit.DivLinearGradient : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivLinearGradient.ColorPoint : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivLinearGradientTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ColorPointTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let position: DivKit.Field<DivKit.Expression<Swift.Double>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivLinearGradientTemplate.ColorPointTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivLinearGradient.ColorPoint>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivLinearGradientTemplate.ColorPointTemplate
    public typealias ResolvedValue = DivKit.DivLinearGradient.ColorPoint
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let angle: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let colorMap: DivKit.Field<[DivKit.DivLinearGradientTemplate.ColorPointTemplate]>?
  final public let colors: DivKit.Field<[DivKit.Expression<VGSLUI.Color>]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivLinearGradientTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivLinearGradient>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivLinearGradientTemplate
  public typealias ResolvedValue = DivKit.DivLinearGradient
  @objc deinit
}
@frozen public enum DivLineStyle : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case none
  case single
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivLineStyle]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivLineStyle] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivMatchParentSize : Swift.Sendable {
  public static let type: Swift.String
  final public let weight: DivKit.Expression<Swift.Double>?
  final public func resolveWeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivMatchParentSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivMatchParentSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let weight: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivMatchParentSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivMatchParentSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivMatchParentSizeTemplate
  public typealias ResolvedValue = DivKit.DivMatchParentSize
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivNeighbourPageSize : Swift.Sendable {
  public static let type: Swift.String
  final public let neighbourPageWidth: DivKit.DivFixedSize
  @objc deinit
}
extension DivKit.DivNeighbourPageSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivNeighbourPageSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let neighbourPageWidth: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivNeighbourPageSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivNeighbourPageSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivNeighbourPageSizeTemplate
  public typealias ResolvedValue = DivKit.DivNeighbourPageSize
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivNinePatchBackground : Swift.Sendable {
  public static let type: Swift.String
  final public let imageUrl: DivKit.Expression<Foundation.URL>
  final public let insets: DivKit.DivAbsoluteEdgeInsets
  final public func resolveImageUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.DivNinePatchBackground : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivNinePatchBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let imageUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let insets: DivKit.Field<DivKit.DivAbsoluteEdgeInsetsTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivNinePatchBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivNinePatchBackground>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivNinePatchBackgroundTemplate
  public typealias ResolvedValue = DivKit.DivNinePatchBackground
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivNumberAnimator : DivKit.DivAnimatorBase, Swift.Sendable {
  public static let type: Swift.String
  final public let cancelActions: [DivKit.DivAction]?
  final public let direction: DivKit.Expression<DivKit.DivAnimationDirection>
  final public let duration: DivKit.Expression<Swift.Int>
  final public let endActions: [DivKit.DivAction]?
  final public let endValue: DivKit.Expression<Swift.Double>
  final public let id: Swift.String
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let repeatCount: DivKit.DivCount
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public let startValue: DivKit.Expression<Swift.Double>?
  final public let variableName: Swift.String
  final public func resolveDirection(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationDirection
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveEndValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveStartValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivNumberAnimator : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivNumberAnimatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let cancelActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let direction: DivKit.Field<DivKit.Expression<DivKit.DivAnimationDirection>>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let endActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let endValue: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let id: DivKit.Field<Swift.String>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let repeatCount: DivKit.Field<DivKit.DivCountTemplate>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let startValue: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let variableName: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivNumberAnimatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivNumberAnimator>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivNumberAnimatorTemplate
  public typealias ResolvedValue = DivKit.DivNumberAnimator
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPageContentSize : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivPageContentSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPageContentSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPageContentSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPageContentSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPageContentSizeTemplate
  public typealias ResolvedValue = DivKit.DivPageContentSize
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPager : DivKit.DivBase, Swift.Sendable {
  @frozen public enum ItemAlignment : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case start
    case center
    case end
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivPager.ItemAlignment]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivPager.ItemAlignment] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Orientation : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case horizontal
    case vertical
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivPager.Orientation]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivPager.Orientation] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let crossAxisAlignment: DivKit.Expression<DivKit.DivPager.ItemAlignment>
  final public let defaultItem: DivKit.Expression<Swift.Int>
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let infiniteScroll: DivKit.Expression<Swift.Bool>
  final public let itemBuilder: DivKit.DivCollectionItemBuilder?
  final public let itemSpacing: DivKit.DivFixedSize
  final public let items: [DivKit.Div]?
  final public let layoutMode: DivKit.DivPagerLayoutMode
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let orientation: DivKit.Expression<DivKit.DivPager.Orientation>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pageTransformation: DivKit.DivPageTransformation?
  final public let restrictParentScroll: DivKit.Expression<Swift.Bool>
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let scrollAxisAlignment: DivKit.Expression<DivKit.DivPager.ItemAlignment>
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveCrossAxisAlignment(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivPager.ItemAlignment
  final public func resolveDefaultItem(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveInfiniteScroll(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveOrientation(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivPager.Orientation
  final public func resolveRestrictParentScroll(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveScrollAxisAlignment(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivPager.ItemAlignment
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivPager : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivPager : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@frozen public enum DivPagerLayoutMode : Swift.Sendable {
  case divPageSize(DivKit.DivPageSize)
  case divNeighbourPageSize(DivKit.DivNeighbourPageSize)
  case divPageContentSize(DivKit.DivPageContentSize)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivPagerLayoutMode : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivPagerLayoutModeTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divPageSizeTemplate(DivKit.DivPageSizeTemplate)
  case divNeighbourPageSizeTemplate(DivKit.DivNeighbourPageSizeTemplate)
  case divPageContentSizeTemplate(DivKit.DivPageContentSizeTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPagerLayoutModeTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPagerLayoutModeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPagerLayoutMode>
  public typealias ResolvedValue = DivKit.DivPagerLayoutMode
}
extension DivKit.DivPagerLayoutModeTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivPagerTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias ItemAlignment = DivKit.DivPager.ItemAlignment
  public typealias Orientation = DivKit.DivPager.Orientation
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let crossAxisAlignment: DivKit.Field<DivKit.Expression<DivKit.DivPagerTemplate.ItemAlignment>>?
  final public let defaultItem: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let infiniteScroll: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let itemBuilder: DivKit.Field<DivKit.DivCollectionItemBuilderTemplate>?
  final public let itemSpacing: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let items: DivKit.Field<[DivKit.DivTemplate]>?
  final public let layoutMode: DivKit.Field<DivKit.DivPagerLayoutModeTemplate>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let orientation: DivKit.Field<DivKit.Expression<DivKit.DivPagerTemplate.Orientation>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pageTransformation: DivKit.Field<DivKit.DivPageTransformationTemplate>?
  final public let restrictParentScroll: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let scrollAxisAlignment: DivKit.Field<DivKit.Expression<DivKit.DivPagerTemplate.ItemAlignment>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPagerTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPager>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPagerTemplate
  public typealias ResolvedValue = DivKit.DivPager
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPageSize : Swift.Sendable {
  public static let type: Swift.String
  final public let pageWidth: DivKit.DivPercentageSize
  @objc deinit
}
extension DivKit.DivPageSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPageSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let pageWidth: DivKit.Field<DivKit.DivPercentageSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPageSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPageSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPageSizeTemplate
  public typealias ResolvedValue = DivKit.DivPageSize
  @objc deinit
}
@frozen public enum DivPageTransformation : Swift.Sendable {
  case divPageTransformationSlide(DivKit.DivPageTransformationSlide)
  case divPageTransformationOverlap(DivKit.DivPageTransformationOverlap)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivPageTransformation : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPageTransformationOverlap : Swift.Sendable {
  public static let type: Swift.String
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let nextPageAlpha: DivKit.Expression<Swift.Double>
  final public let nextPageScale: DivKit.Expression<Swift.Double>
  final public let previousPageAlpha: DivKit.Expression<Swift.Double>
  final public let previousPageScale: DivKit.Expression<Swift.Double>
  final public let reversedStackingOrder: DivKit.Expression<Swift.Bool>
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveNextPageAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveNextPageScale(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolvePreviousPageAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolvePreviousPageScale(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveReversedStackingOrder(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivPageTransformationOverlap : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPageTransformationOverlapTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let nextPageAlpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let nextPageScale: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let previousPageAlpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let previousPageScale: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let reversedStackingOrder: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPageTransformationOverlapTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPageTransformationOverlap>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPageTransformationOverlapTemplate
  public typealias ResolvedValue = DivKit.DivPageTransformationOverlap
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPageTransformationSlide : Swift.Sendable {
  public static let type: Swift.String
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let nextPageAlpha: DivKit.Expression<Swift.Double>
  final public let nextPageScale: DivKit.Expression<Swift.Double>
  final public let previousPageAlpha: DivKit.Expression<Swift.Double>
  final public let previousPageScale: DivKit.Expression<Swift.Double>
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveNextPageAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveNextPageScale(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolvePreviousPageAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolvePreviousPageScale(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  @objc deinit
}
extension DivKit.DivPageTransformationSlide : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPageTransformationSlideTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let nextPageAlpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let nextPageScale: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let previousPageAlpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let previousPageScale: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPageTransformationSlideTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPageTransformationSlide>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPageTransformationSlideTemplate
  public typealias ResolvedValue = DivKit.DivPageTransformationSlide
  @objc deinit
}
@frozen public enum DivPageTransformationTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divPageTransformationSlideTemplate(DivKit.DivPageTransformationSlideTemplate)
  case divPageTransformationOverlapTemplate(DivKit.DivPageTransformationOverlapTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPageTransformationTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPageTransformationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPageTransformation>
  public typealias ResolvedValue = DivKit.DivPageTransformation
}
extension DivKit.DivPageTransformationTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivPatch : Swift.Sendable {
  @frozen public enum Mode : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case transactional
    case partial
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivPatch.Mode]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivPatch.Mode] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class Change : Swift.Sendable {
    final public let id: Swift.String
    final public let items: [DivKit.Div]?
    @objc deinit
  }
  final public let changes: [DivKit.DivPatch.Change]
  final public let mode: DivKit.Expression<DivKit.DivPatch.Mode>
  final public let onAppliedActions: [DivKit.DivAction]?
  final public let onFailedActions: [DivKit.DivAction]?
  final public func resolveMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivPatch.Mode
  @objc deinit
}
extension DivKit.DivPatch : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivPatch.Change : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public class DivPatchDownloader : DivKit.DivPatchProvider {
  public init(requestPerformer: any VGSLNetworking.URLRequestPerforming)
  public func getPatch(url: Foundation.URL, completion: @escaping DivKit.DivPatchProviderCompletion)
  public func cancelRequests()
  @objc deinit
}
public protocol DivPatchProvider {
  func getPatch(url: Foundation.URL, completion: @escaping DivKit.DivPatchProviderCompletion)
  func getPatch(url: Foundation.URL, info: DivKit.DivActionInfo, completion: @escaping DivKit.DivPatchProviderCompletion)
  func cancelRequests()
}
extension DivKit.DivPatchProvider {
  public func getPatch(url: Foundation.URL, info _: DivKit.DivActionInfo, completion: @escaping DivKit.DivPatchProviderCompletion)
}
public typealias DivPatchProviderCompletion = (Swift.Result<DivKit.DivPatch, any Swift.Error>) -> Swift.Void
public func parseDivPatch(_ data: Foundation.Data) throws -> DivKit.DivPatch
@_hasMissingDesignatedInitializers final public class DivPatchTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ChangeTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let id: DivKit.Field<Swift.String>?
    final public let items: DivKit.Field<[DivKit.DivTemplate]>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPatchTemplate.ChangeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPatch.Change>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPatchTemplate.ChangeTemplate
    public typealias ResolvedValue = DivKit.DivPatch.Change
    @objc deinit
  }
  public typealias Mode = DivKit.DivPatch.Mode
  final public let changes: DivKit.Field<[DivKit.DivPatchTemplate.ChangeTemplate]>?
  final public let mode: DivKit.Field<DivKit.Expression<DivKit.DivPatchTemplate.Mode>>?
  final public let onAppliedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let onFailedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPatchTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPatch>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPatchTemplate
  public typealias ResolvedValue = DivKit.DivPatch
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPercentageSize : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivPercentageSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPercentageSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPercentageSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPercentageSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPercentageSizeTemplate
  public typealias ResolvedValue = DivKit.DivPercentageSize
  @objc deinit
}
final public class DivPersistentValuesStorage {
  public init(timestampProvider: VGSLFundamentals.Variable<VGSLFundamentals.Milliseconds> = Variable {
      Date().timeIntervalSince1970.milliseconds
    })
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPhoneInputMask : DivKit.DivInputMaskBase, Swift.Sendable {
  public static let type: Swift.String
  final public let rawTextVariable: Swift.String
  @objc deinit
}
extension DivKit.DivPhoneInputMask : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPhoneInputMaskTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let rawTextVariable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPhoneInputMaskTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPhoneInputMask>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPhoneInputMaskTemplate
  public typealias ResolvedValue = DivKit.DivPhoneInputMask
  @objc deinit
}
@frozen public enum DivPivot : Swift.Sendable {
  case divPivotFixed(DivKit.DivPivotFixed)
  case divPivotPercentage(DivKit.DivPivotPercentage)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivPivot : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPivotFixed : Swift.Sendable {
  public static let type: Swift.String
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let value: DivKit.Expression<Swift.Int>?
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivPivotFixed : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPivotFixedTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPivotFixedTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPivotFixed>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPivotFixedTemplate
  public typealias ResolvedValue = DivKit.DivPivotFixed
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivPivotPercentage : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivPivotPercentage : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPivotPercentageTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPivotPercentageTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPivotPercentage>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPivotPercentageTemplate
  public typealias ResolvedValue = DivKit.DivPivotPercentage
  @objc deinit
}
@frozen public enum DivPivotTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divPivotFixedTemplate(DivKit.DivPivotFixedTemplate)
  case divPivotPercentageTemplate(DivKit.DivPivotPercentageTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPivotTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPivotTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPivot>
  public typealias ResolvedValue = DivKit.DivPivot
}
extension DivKit.DivPivotTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivPoint : Swift.Sendable {
  final public let x: DivKit.DivDimension
  final public let y: DivKit.DivDimension
  @objc deinit
}
extension DivKit.DivPoint : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivPointTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let x: DivKit.Field<DivKit.DivDimensionTemplate>?
  final public let y: DivKit.Field<DivKit.DivDimensionTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivPointTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivPoint>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivPointTemplate
  public typealias ResolvedValue = DivKit.DivPoint
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivRadialGradient : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ColorPoint : Swift.Sendable {
    final public let color: DivKit.Expression<VGSLUI.Color>
    final public let position: DivKit.Expression<Swift.Double>
    final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    final public func resolvePosition(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
    @objc deinit
  }
  public static let type: Swift.String
  final public let centerX: DivKit.DivRadialGradientCenter
  final public let centerY: DivKit.DivRadialGradientCenter
  final public let colorMap: [DivKit.DivRadialGradient.ColorPoint]?
  final public let colors: [DivKit.Expression<VGSLUI.Color>]?
  final public let radius: DivKit.DivRadialGradientRadius
  final public func resolveColors(_ resolver: DivKit.ExpressionResolver) -> [VGSLUI.Color]?
  @objc deinit
}
extension DivKit.DivRadialGradient : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivRadialGradient.ColorPoint : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivRadialGradientCenter : Swift.Sendable {
  case divRadialGradientFixedCenter(DivKit.DivRadialGradientFixedCenter)
  case divRadialGradientRelativeCenter(DivKit.DivRadialGradientRelativeCenter)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivRadialGradientCenter : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivRadialGradientCenterTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divRadialGradientFixedCenterTemplate(DivKit.DivRadialGradientFixedCenterTemplate)
  case divRadialGradientRelativeCenterTemplate(DivKit.DivRadialGradientRelativeCenterTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientCenterTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientCenterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradientCenter>
  public typealias ResolvedValue = DivKit.DivRadialGradientCenter
}
extension DivKit.DivRadialGradientCenterTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientFixedCenter : Swift.Sendable {
  public static let type: Swift.String
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivRadialGradientFixedCenter : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientFixedCenterTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientFixedCenterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradientFixedCenter>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientFixedCenterTemplate
  public typealias ResolvedValue = DivKit.DivRadialGradientFixedCenter
  @objc deinit
}
@frozen public enum DivRadialGradientRadius : Swift.Sendable {
  case divFixedSize(DivKit.DivFixedSize)
  case divRadialGradientRelativeRadius(DivKit.DivRadialGradientRelativeRadius)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivRadialGradientRadius : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivRadialGradientRadiusTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divFixedSizeTemplate(DivKit.DivFixedSizeTemplate)
  case divRadialGradientRelativeRadiusTemplate(DivKit.DivRadialGradientRelativeRadiusTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientRadiusTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientRadiusTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradientRadius>
  public typealias ResolvedValue = DivKit.DivRadialGradientRadius
}
extension DivKit.DivRadialGradientRadiusTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientRelativeCenter : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivRadialGradientRelativeCenter : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientRelativeCenterTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientRelativeCenterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradientRelativeCenter>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientRelativeCenterTemplate
  public typealias ResolvedValue = DivKit.DivRadialGradientRelativeCenter
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientRelativeRadius : Swift.Sendable {
  @frozen public enum Value : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case nearestCorner
    case farthestCorner
    case nearestSide
    case farthestSide
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivRadialGradientRelativeRadius.Value]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivRadialGradientRelativeRadius.Value] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let value: DivKit.Expression<DivKit.DivRadialGradientRelativeRadius.Value>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivRadialGradientRelativeRadius.Value?
  @objc deinit
}
extension DivKit.DivRadialGradientRelativeRadius : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientRelativeRadiusTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Value = DivKit.DivRadialGradientRelativeRadius.Value
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<DivKit.DivRadialGradientRelativeRadiusTemplate.Value>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientRelativeRadiusTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradientRelativeRadius>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientRelativeRadiusTemplate
  public typealias ResolvedValue = DivKit.DivRadialGradientRelativeRadius
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivRadialGradientTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ColorPointTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let position: DivKit.Field<DivKit.Expression<Swift.Double>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientTemplate.ColorPointTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradient.ColorPoint>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientTemplate.ColorPointTemplate
    public typealias ResolvedValue = DivKit.DivRadialGradient.ColorPoint
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let centerX: DivKit.Field<DivKit.DivRadialGradientCenterTemplate>?
  final public let centerY: DivKit.Field<DivKit.DivRadialGradientCenterTemplate>?
  final public let colorMap: DivKit.Field<[DivKit.DivRadialGradientTemplate.ColorPointTemplate]>?
  final public let colors: DivKit.Field<[DivKit.Expression<VGSLUI.Color>]>?
  final public let radius: DivKit.Field<DivKit.DivRadialGradientRadiusTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRadialGradientTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRadialGradient>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRadialGradientTemplate
  public typealias ResolvedValue = DivKit.DivRadialGradient
  @objc deinit
}
public protocol DivReporter {
  func reportError(cardId: DivKit.DivCardID, error: any DivKit.DivError)
  func reportAction(cardId: DivKit.DivCardID, info: DivKit.DivActionInfo)
}
extension DivKit.DivReporter {
  public func reportViewWasCreated(cardId _: DivKit.DivCardID)
  public func reportBlockWillConfigure(path _: LayoutKitInterface.UIElementPath)
  public func reportBlockDidConfigure(path _: LayoutKitInterface.UIElementPath)
  public func reportViewWillLayout(path _: LayoutKitInterface.UIElementPath)
  public func reportViewDidLayout(path _: LayoutKitInterface.UIElementPath)
  public func reportAction(cardId _: DivKit.DivCardID, info _: DivKit.DivActionInfo)
}
@_hasMissingDesignatedInitializers final public class DivRoundedRectangleShape : Swift.Sendable {
  public static let type: Swift.String
  final public let backgroundColor: DivKit.Expression<VGSLUI.Color>?
  final public let cornerRadius: DivKit.DivFixedSize
  final public let itemHeight: DivKit.DivFixedSize
  final public let itemWidth: DivKit.DivFixedSize
  final public let stroke: DivKit.DivStroke?
  final public func resolveBackgroundColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.DivRoundedRectangleShape : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivRoundedRectangleShapeTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let backgroundColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let cornerRadius: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let itemHeight: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let itemWidth: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let stroke: DivKit.Field<DivKit.DivStrokeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivRoundedRectangleShapeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivRoundedRectangleShape>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivRoundedRectangleShapeTemplate
  public typealias ResolvedValue = DivKit.DivRoundedRectangleShape
  @objc deinit
}
final public class DivSafeAreaManager {
  public init(storage: DivKit.DivVariablesStorage)
  final public func setEdgeInsets(_ insets: VGSLUI.EdgeInsets)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivScaleTransition : DivKit.DivTransitionBase, Swift.Sendable {
  public static let type: Swift.String
  final public let duration: DivKit.Expression<Swift.Int>
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let pivotX: DivKit.Expression<Swift.Double>
  final public let pivotY: DivKit.Expression<Swift.Double>
  final public let scale: DivKit.Expression<Swift.Double>
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolvePivotX(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolvePivotY(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveScale(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivScaleTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivScaleTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let pivotX: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let pivotY: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let scale: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivScaleTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivScaleTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivScaleTransitionTemplate
  public typealias ResolvedValue = DivKit.DivScaleTransition
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivSelect : DivKit.DivBase, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Option : Swift.Sendable {
    final public let text: DivKit.Expression<Swift.String>?
    final public let value: DivKit.Expression<Swift.String>
    final public func resolveText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let fontFamily: DivKit.Expression<Swift.String>?
  final public let fontSize: DivKit.Expression<Swift.Int>
  final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let fontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
  final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>
  final public let fontWeightValue: DivKit.Expression<Swift.Int>?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hintColor: DivKit.Expression<VGSLUI.Color>
  final public let hintText: DivKit.Expression<Swift.String>?
  final public let id: Swift.String?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let letterSpacing: DivKit.Expression<Swift.Double>
  final public let lineHeight: DivKit.Expression<Swift.Int>?
  final public let margins: DivKit.DivEdgeInsets?
  final public let options: [DivKit.DivSelect.Option]
  final public let paddings: DivKit.DivEdgeInsets?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let textColor: DivKit.Expression<VGSLUI.Color>
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let valueVariable: Swift.String
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
  final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
  final public func resolveFontWeightValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveHintColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveHintText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveLineHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivSelect : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSelect.Option : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSelect : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
extension DivKit.DivSelect : DivKit.FontParamsProvider {
}
@_hasMissingDesignatedInitializers final public class DivSelectTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class OptionTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let text: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let value: DivKit.Field<DivKit.Expression<Swift.String>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSelectTemplate.OptionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSelect.Option>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSelectTemplate.OptionTemplate
    public typealias ResolvedValue = DivKit.DivSelect.Option
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let fontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
  final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
  final public let fontWeightValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hintColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let hintText: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let id: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let lineHeight: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let options: DivKit.Field<[DivKit.DivSelectTemplate.OptionTemplate]>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let textColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let valueVariable: DivKit.Field<Swift.String>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSelectTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSelect>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSelectTemplate
  public typealias ResolvedValue = DivKit.DivSelect
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivSeparator : DivKit.DivBase, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class DelimiterStyle : Swift.Sendable {
    @frozen public enum Orientation : Swift.String, Swift.CaseIterable, Swift.Sendable {
      case vertical
      case horizontal
      public init?(rawValue: Swift.String)
      public typealias AllCases = [DivKit.DivSeparator.DelimiterStyle.Orientation]
      public typealias RawValue = Swift.String
      nonisolated public static var allCases: [DivKit.DivSeparator.DelimiterStyle.Orientation] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
    final public let color: DivKit.Expression<VGSLUI.Color>
    final public let orientation: DivKit.Expression<DivKit.DivSeparator.DelimiterStyle.Orientation>
    final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
    final public func resolveOrientation(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSeparator.DelimiterStyle.Orientation
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let delimiterStyle: DivKit.DivSeparator.DelimiterStyle?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivSeparator : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSeparator.DelimiterStyle : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSeparator : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivSeparatorTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class DelimiterStyleTemplate : DivKit.TemplateValue, Swift.Sendable {
    public typealias Orientation = DivKit.DivSeparator.DelimiterStyle.Orientation
    final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let orientation: DivKit.Field<DivKit.Expression<DivKit.DivSeparatorTemplate.DelimiterStyleTemplate.Orientation>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSeparatorTemplate.DelimiterStyleTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSeparator.DelimiterStyle>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSeparatorTemplate.DelimiterStyleTemplate
    public typealias ResolvedValue = DivKit.DivSeparator.DelimiterStyle
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let delimiterStyle: DivKit.Field<DivKit.DivSeparatorTemplate.DelimiterStyleTemplate>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSeparatorTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSeparator>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSeparatorTemplate
  public typealias ResolvedValue = DivKit.DivSeparator
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivShadow : Swift.Sendable {
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let blur: DivKit.Expression<Swift.Int>
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let offset: DivKit.DivPoint
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveBlur(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  @objc deinit
}
extension DivKit.DivShadow : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivShadowTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let blur: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let offset: DivKit.Field<DivKit.DivPointTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivShadowTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivShadow>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivShadowTemplate
  public typealias ResolvedValue = DivKit.DivShadow
  @objc deinit
}
@frozen public enum DivShape : Swift.Sendable {
  case divRoundedRectangleShape(DivKit.DivRoundedRectangleShape)
  case divCircleShape(DivKit.DivCircleShape)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivShape : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivShapeDrawable : Swift.Sendable {
  public static let type: Swift.String
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let shape: DivKit.DivShape
  final public let stroke: DivKit.DivStroke?
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.DivShapeDrawable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivShapeDrawableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let shape: DivKit.Field<DivKit.DivShapeTemplate>?
  final public let stroke: DivKit.Field<DivKit.DivStrokeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivShapeDrawableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivShapeDrawable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivShapeDrawableTemplate
  public typealias ResolvedValue = DivKit.DivShapeDrawable
  @objc deinit
}
@frozen public enum DivShapeTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divRoundedRectangleShapeTemplate(DivKit.DivRoundedRectangleShapeTemplate)
  case divCircleShapeTemplate(DivKit.DivCircleShapeTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivShapeTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivShapeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivShape>
  public typealias ResolvedValue = DivKit.DivShape
}
extension DivKit.DivShapeTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
public protocol DivSightAction {
  var downloadCallbacks: DivKit.DivDownloadCallbacks? { get }
  var isEnabled: DivKit.Expression<Swift.Bool> { get }
  var logId: DivKit.Expression<Swift.String> { get }
  var logLimit: DivKit.Expression<Swift.Int> { get }
  var payload: [Swift.String : Any]? { get }
  var referer: DivKit.Expression<Foundation.URL>? { get }
  var scopeId: Swift.String? { get }
  var typed: DivKit.DivActionTyped? { get }
  var url: DivKit.Expression<Foundation.URL>? { get }
  func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  func resolveLogId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  func resolveLogLimit(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  func resolveReferer(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
}
@frozen public enum DivSize : Swift.Sendable {
  case divFixedSize(DivKit.DivFixedSize)
  case divMatchParentSize(DivKit.DivMatchParentSize)
  case divWrapContentSize(DivKit.DivWrapContentSize)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivSize : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSize : Swift.Equatable {
  public static func == (lhs: DivKit.DivSize, rhs: DivKit.DivSize) -> Swift.Bool
}
extension DivKit.DivFixedSize : Swift.Equatable {
  public static func == (lhs: DivKit.DivFixedSize, rhs: DivKit.DivFixedSize) -> Swift.Bool
}
extension DivKit.DivMatchParentSize : Swift.Equatable {
  public static func == (lhs: DivKit.DivMatchParentSize, rhs: DivKit.DivMatchParentSize) -> Swift.Bool
}
extension DivKit.DivWrapContentSize : Swift.Equatable {
  public static func == (lhs: DivKit.DivWrapContentSize, rhs: DivKit.DivWrapContentSize) -> Swift.Bool
}
@frozen public enum DivSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divFixedSizeTemplate(DivKit.DivFixedSizeTemplate)
  case divMatchParentSizeTemplate(DivKit.DivMatchParentSizeTemplate)
  case divWrapContentSizeTemplate(DivKit.DivWrapContentSizeTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSizeTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSize>
  public typealias ResolvedValue = DivKit.DivSize
}
extension DivKit.DivSizeTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@frozen public enum DivSizeUnit : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case dp
  case sp
  case px
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivSizeUnit]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivSizeUnit] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivSlider : DivKit.DivBase, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Range : Swift.Sendable {
    final public let end: DivKit.Expression<Swift.Int>?
    final public let margins: DivKit.DivEdgeInsets?
    final public let start: DivKit.Expression<Swift.Int>?
    final public let trackActiveStyle: DivKit.DivDrawable?
    final public let trackInactiveStyle: DivKit.DivDrawable?
    final public func resolveEnd(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveStart(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TextStyle : @unchecked Swift.Sendable {
    final public let fontFamily: DivKit.Expression<Swift.String>?
    final public let fontSize: DivKit.Expression<Swift.Int>
    final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
    final public let fontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
    final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>
    final public let fontWeightValue: DivKit.Expression<Swift.Int>?
    final public let letterSpacing: DivKit.Expression<Swift.Double>
    final public let offset: DivKit.DivPoint?
    final public let textColor: DivKit.Expression<VGSLUI.Color>
    final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
    final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
    final public func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
    final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
    final public func resolveFontWeightValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
    final public func resolveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let maxValue: DivKit.Expression<Swift.Int>
  final public let minValue: DivKit.Expression<Swift.Int>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let ranges: [DivKit.DivSlider.Range]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let secondaryValueAccessibility: DivKit.DivAccessibility?
  final public let selectedActions: [DivKit.DivAction]?
  final public let thumbSecondaryStyle: DivKit.DivDrawable?
  final public let thumbSecondaryTextStyle: DivKit.DivSlider.TextStyle?
  final public let thumbSecondaryValueVariable: Swift.String?
  final public let thumbStyle: DivKit.DivDrawable
  final public let thumbTextStyle: DivKit.DivSlider.TextStyle?
  final public let thumbValueVariable: Swift.String?
  final public let tickMarkActiveStyle: DivKit.DivDrawable?
  final public let tickMarkInactiveStyle: DivKit.DivDrawable?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let trackActiveStyle: DivKit.DivDrawable
  final public let trackInactiveStyle: DivKit.DivDrawable
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveMaxValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveMinValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivSlider : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSlider.Range : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSlider.TextStyle : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSlider : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivSliderTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class RangeTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let end: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
    final public let start: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let trackActiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
    final public let trackInactiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSliderTemplate.RangeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSlider.Range>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSliderTemplate.RangeTemplate
    public typealias ResolvedValue = DivKit.DivSlider.Range
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TextStyleTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
    final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
    final public let fontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
    final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
    final public let fontWeightValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
    final public let offset: DivKit.Field<DivKit.DivPointTemplate>?
    final public let textColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSliderTemplate.TextStyleTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSlider.TextStyle>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSliderTemplate.TextStyleTemplate
    public typealias ResolvedValue = DivKit.DivSlider.TextStyle
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let maxValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let minValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let ranges: DivKit.Field<[DivKit.DivSliderTemplate.RangeTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let secondaryValueAccessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let thumbSecondaryStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let thumbSecondaryTextStyle: DivKit.Field<DivKit.DivSliderTemplate.TextStyleTemplate>?
  final public let thumbSecondaryValueVariable: DivKit.Field<Swift.String>?
  final public let thumbStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let thumbTextStyle: DivKit.Field<DivKit.DivSliderTemplate.TextStyleTemplate>?
  final public let thumbValueVariable: DivKit.Field<Swift.String>?
  final public let tickMarkActiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let tickMarkInactiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let trackActiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let trackInactiveStyle: DivKit.Field<DivKit.DivDrawableTemplate>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSliderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSlider>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSliderTemplate
  public typealias ResolvedValue = DivKit.DivSlider
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivSlideTransition : DivKit.DivTransitionBase, Swift.Sendable {
  @frozen public enum Edge : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case left
    case top
    case right
    case bottom
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivSlideTransition.Edge]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivSlideTransition.Edge] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let type: Swift.String
  final public let distance: DivKit.DivDimension?
  final public let duration: DivKit.Expression<Swift.Int>
  final public let edge: DivKit.Expression<DivKit.DivSlideTransition.Edge>
  final public let interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator>
  final public let startDelay: DivKit.Expression<Swift.Int>
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveEdge(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSlideTransition.Edge
  final public func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  final public func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivSlideTransition : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivSlideTransitionTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Edge = DivKit.DivSlideTransition.Edge
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let distance: DivKit.Field<DivKit.DivDimensionTemplate>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let edge: DivKit.Field<DivKit.Expression<DivKit.DivSlideTransitionTemplate.Edge>>?
  final public let interpolator: DivKit.Field<DivKit.Expression<DivKit.DivAnimationInterpolator>>?
  final public let startDelay: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSlideTransitionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSlideTransition>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSlideTransitionTemplate
  public typealias ResolvedValue = DivKit.DivSlideTransition
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivSolidBackground : Swift.Sendable {
  public static let type: Swift.String
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  @objc deinit
}
extension DivKit.DivSolidBackground : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivSolidBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSolidBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSolidBackground>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSolidBackgroundTemplate
  public typealias ResolvedValue = DivKit.DivSolidBackground
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivState : DivKit.DivBase, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class State : Swift.Sendable {
    final public let animationIn: DivKit.DivAnimation?
    final public let animationOut: DivKit.DivAnimation?
    final public let div: DivKit.Div?
    final public let stateId: Swift.String
    final public let swipeOutActions: [DivKit.DivAction]?
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let clipToBounds: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let defaultStateId: DivKit.Expression<Swift.String>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let divId: Swift.String?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let stateIdVariable: Swift.String?
  final public let states: [DivKit.DivState.State]
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionAnimationSelector: DivKit.Expression<DivKit.DivTransitionSelector>
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveClipToBounds(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveDefaultStateId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveTransitionAnimationSelector(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTransitionSelector
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivState : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivState.State : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivState : DivKit.DivBlockModeling {
  final public func makeBlock(context parentContext: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
public enum DivStateLifetime {
  case long
  case short
  public static func == (a: DivKit.DivStateLifetime, b: DivKit.DivStateLifetime) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DivStateManagement : DivKit.DivStateUpdater {
  func getStateManagerForCard(cardId: DivKit.DivCardID) -> DivKit.DivStateManager
  func reset()
  func reset(cardId: DivKit.DivCardID)
}
public class DefaultDivStateManagement : DivKit.DivStateManagement {
  public init(timestampProvider: VGSLFundamentals.Variable<VGSLFundamentals.Milliseconds> = Variable {
      Date().timeIntervalSince1970.milliseconds
    })
  public func set(path: DivKit.DivStatePath, cardId: DivKit.DivCardID, lifetime: DivKit.DivStateLifetime)
  public func getStateManagerForCard(cardId: DivKit.DivCardID) -> DivKit.DivStateManager
  public func reset()
  public func reset(cardId: DivKit.DivCardID)
  @objc deinit
}
public class DivStateManager {
  public struct Item : Swift.Equatable {
    public let currentStateID: DivKit.DivStateID
    public let previousState: DivKit.DivStateManager.PreviousState
    public init(currentStateID: DivKit.DivStateID, previousState: DivKit.DivStateManager.PreviousState)
    public static func == (a: DivKit.DivStateManager.Item, b: DivKit.DivStateManager.Item) -> Swift.Bool
  }
  public enum PreviousState : Swift.Equatable {
    case empty
    case initial
    case withID(DivKit.DivStateID)
    public static func == (a: DivKit.DivStateManager.PreviousState, b: DivKit.DivStateManager.PreviousState) -> Swift.Bool
  }
  public var items: [DivKit.DivStatePath : DivKit.DivStateManager.Item] {
    get
  }
  public var blockIds: [DivKit.DivStatePath : Swift.Set<Swift.String>] {
    get
  }
  public var blockVisibility: [DivKit.DivBlockPath : Swift.Bool] {
    get
  }
  public init()
  public init(items: [DivKit.DivStatePath : DivKit.DivStateManager.Item])
  public func setState(stateBlockPath: DivKit.DivStatePath, stateID: DivKit.DivStateID)
  public func setStateWithHistory(path: DivKit.DivStatePath, stateID: DivKit.DivStateID)
  public func removeState(path: DivKit.DivStatePath)
  public func isBlockAdded(_ id: Swift.String, stateBlockPath: DivKit.DivStatePath) -> Swift.Bool
  public func updateBlockIdsWithStateChangeTransition(statePath: DivKit.DivStatePath, div: DivKit.Div)
  public func getVisibleIds(statePath: DivKit.DivStatePath) -> Swift.Set<Swift.String>
  public func shouldBlockAppearWithTransition(path: DivKit.DivBlockPath) -> Swift.Bool
  public func setBlockVisibility(statePath: DivKit.DivStatePath, div: any DivKit.DivBase, isVisible: Swift.Bool)
  public func reset()
  @objc deinit
}
extension DivKit.DivStateManager : Swift.Equatable {
  public static func == (lhs: DivKit.DivStateManager, rhs: DivKit.DivStateManager) -> Swift.Bool
}
public enum DivDataStateIDTag {
}
public typealias DivDataStateID = VGSLFundamentals.Tagged<DivKit.DivDataStateIDTag, Swift.Int>
public enum DivStateIDTag {
}
public typealias DivStateID = VGSLFundamentals.Tagged<DivKit.DivStateIDTag, Swift.String>
public enum DivStatePathTag {
}
public typealias DivStatePath = VGSLFundamentals.Tagged<DivKit.DivStatePathTag, LayoutKitInterface.UIElementPath>
public enum DivBlockPathTag {
}
public typealias DivBlockPath = VGSLFundamentals.Tagged<DivKit.DivBlockPathTag, LayoutKitInterface.UIElementPath>
extension VGSLFundamentals.Tagged where Tag == DivKit.DivStatePathTag, RawValue == LayoutKitInterface.UIElementPath {
  public static func makeDivStatePath(from string: Swift.String) -> VGSLFundamentals.Tagged<Tag, RawValue>
  public var stateId: DivKit.DivDataStateID? {
    get
  }
  public var stateBlockPath: DivKit.DivStatePath {
    get
  }
  public func split() -> (parentPath: VGSLFundamentals.Tagged<Tag, RawValue>, stateId: DivKit.DivStateID)?
  public static func + (parent: DivKit.DivStatePath, child: DivKit.DivStateID) -> DivKit.DivStatePath
  public static func + (parent: DivKit.DivStatePath, blockId: Swift.String) -> DivKit.DivBlockPath
}
extension VGSLFundamentals.Tagged where Tag == DivKit.DivDataStateIDTag, RawValue == Swift.Int {
  public func asPath() -> DivKit.DivStatePath
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == VGSLFundamentals.Tagged<DivKit.DivStatePathTag, LayoutKitInterface.UIElementPath> {
  public static func + (parent: Swift.Optional<Wrapped>, child: Swift.String) -> DivKit.DivStatePath
}
#else
extension Swift.Optional where Wrapped == VGSLFundamentals.Tagged<DivKit.DivStatePathTag, LayoutKitInterface.UIElementPath> {
  public static func + (parent: Swift.Optional<Wrapped>, child: Swift.String) -> DivKit.DivStatePath
}
#endif
extension VGSLFundamentals.Tagged where Tag == DivKit.DivBlockPathTag, RawValue == LayoutKitInterface.UIElementPath {
  public var blockId: Swift.String {
    get
  }
  public var statePath: DivKit.DivStatePath? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivStateTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class StateTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let animationIn: DivKit.Field<DivKit.DivAnimationTemplate>?
    final public let animationOut: DivKit.Field<DivKit.DivAnimationTemplate>?
    final public let div: DivKit.Field<DivKit.DivTemplate>?
    final public let stateId: DivKit.Field<Swift.String>?
    final public let swipeOutActions: DivKit.Field<[DivKit.DivActionTemplate]>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStateTemplate.StateTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivState.State>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStateTemplate.StateTemplate
    public typealias ResolvedValue = DivKit.DivState.State
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let clipToBounds: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let defaultStateId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let divId: DivKit.Field<Swift.String>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let stateIdVariable: DivKit.Field<Swift.String>?
  final public let states: DivKit.Field<[DivKit.DivStateTemplate.StateTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionAnimationSelector: DivKit.Field<DivKit.Expression<DivKit.DivTransitionSelector>>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStateTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivState>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStateTemplate
  public typealias ResolvedValue = DivKit.DivState
  @objc deinit
}
public protocol DivStateUpdater : AnyObject {
  func set(path: DivKit.DivStatePath, cardId: DivKit.DivCardID, lifetime: DivKit.DivStateLifetime)
}
@_hasMissingDesignatedInitializers final public class DivStretchIndicatorItemPlacement : Swift.Sendable {
  public static let type: Swift.String
  final public let itemSpacing: DivKit.DivFixedSize
  final public let maxVisibleItems: DivKit.Expression<Swift.Int>
  final public func resolveMaxVisibleItems(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivStretchIndicatorItemPlacement : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivStretchIndicatorItemPlacementTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let itemSpacing: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  final public let maxVisibleItems: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStretchIndicatorItemPlacementTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivStretchIndicatorItemPlacement>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStretchIndicatorItemPlacementTemplate
  public typealias ResolvedValue = DivKit.DivStretchIndicatorItemPlacement
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivStroke : Swift.Sendable {
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let style: DivKit.DivStrokeStyle
  final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let width: DivKit.Expression<Swift.Double>
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveWidth(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  @objc deinit
}
extension DivKit.DivStroke : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivStrokeStyle : Swift.Sendable {
  case divStrokeStyleSolid(DivKit.DivStrokeStyleSolid)
  case divStrokeStyleDashed(DivKit.DivStrokeStyleDashed)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivStrokeStyle : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivStrokeStyleDashed : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivStrokeStyleDashed : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivStrokeStyleDashedTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStrokeStyleDashedTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivStrokeStyleDashed>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStrokeStyleDashedTemplate
  public typealias ResolvedValue = DivKit.DivStrokeStyleDashed
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivStrokeStyleSolid : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivStrokeStyleSolid : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivStrokeStyleSolidTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStrokeStyleSolidTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivStrokeStyleSolid>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStrokeStyleSolidTemplate
  public typealias ResolvedValue = DivKit.DivStrokeStyleSolid
  @objc deinit
}
@frozen public enum DivStrokeStyleTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divStrokeStyleSolidTemplate(DivKit.DivStrokeStyleSolidTemplate)
  case divStrokeStyleDashedTemplate(DivKit.DivStrokeStyleDashedTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStrokeStyleTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStrokeStyleTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivStrokeStyle>
  public typealias ResolvedValue = DivKit.DivStrokeStyle
}
extension DivKit.DivStrokeStyleTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivStrokeTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let style: DivKit.Field<DivKit.DivStrokeStyleTemplate>?
  final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let width: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivStrokeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivStroke>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivStrokeTemplate
  public typealias ResolvedValue = DivKit.DivStroke
  @objc deinit
}
public protocol DivSubmitter {
  func submit(request: DivKit.SubmitRequest, data: [Swift.String : Swift.String], completion: @escaping DivKit.DivSubmitterCompletion)
  func cancelRequests()
}
public typealias DivSubmitterCompletion = (Swift.Result<Swift.Void, Foundation.NSError>) -> Swift.Void
@_hasMissingDesignatedInitializers final public class DivSwitch : DivKit.DivBase, Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let isOnVariable: Swift.String
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let onColor: DivKit.Expression<VGSLUI.Color>?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveOnColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivSwitch : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivSwitch : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivSwitchTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let isOnVariable: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let onColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivSwitchTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivSwitch>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivSwitchTemplate
  public typealias ResolvedValue = DivKit.DivSwitch
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTabs : DivKit.DivBase, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Item : Swift.Sendable {
    final public let div: DivKit.Div
    final public let title: DivKit.Expression<Swift.String>
    final public let titleClickAction: DivKit.DivAction?
    final public func resolveTitle(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TabTitleDelimiter : Swift.Sendable {
    final public let height: DivKit.DivFixedSize
    final public let imageUrl: DivKit.Expression<Foundation.URL>
    final public let width: DivKit.DivFixedSize
    final public func resolveImageUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TabTitleStyle : @unchecked Swift.Sendable {
    @frozen public enum AnimationType : Swift.String, Swift.CaseIterable, Swift.Sendable {
      case slide
      case fade
      case none
      public init?(rawValue: Swift.String)
      public typealias AllCases = [DivKit.DivTabs.TabTitleStyle.AnimationType]
      public typealias RawValue = Swift.String
      nonisolated public static var allCases: [DivKit.DivTabs.TabTitleStyle.AnimationType] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
    final public let activeBackgroundColor: DivKit.Expression<VGSLUI.Color>
    final public let activeFontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
    final public let activeFontWeight: DivKit.Expression<DivKit.DivFontWeight>?
    final public let activeTextColor: DivKit.Expression<VGSLUI.Color>
    final public let animationDuration: DivKit.Expression<Swift.Int>
    final public let animationType: DivKit.Expression<DivKit.DivTabs.TabTitleStyle.AnimationType>
    final public let cornerRadius: DivKit.Expression<Swift.Int>?
    final public let cornersRadius: DivKit.DivCornersRadius?
    final public let fontFamily: DivKit.Expression<Swift.String>?
    final public let fontSize: DivKit.Expression<Swift.Int>
    final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
    final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>
    final public let inactiveBackgroundColor: DivKit.Expression<VGSLUI.Color>?
    final public let inactiveFontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
    final public let inactiveFontWeight: DivKit.Expression<DivKit.DivFontWeight>?
    final public let inactiveTextColor: DivKit.Expression<VGSLUI.Color>
    final public let itemSpacing: DivKit.Expression<Swift.Int>
    final public let letterSpacing: DivKit.Expression<Swift.Double>
    final public let lineHeight: DivKit.Expression<Swift.Int>?
    final public let paddings: DivKit.DivEdgeInsets
    final public func resolveActiveBackgroundColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
    final public func resolveActiveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
    final public func resolveActiveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight?
    final public func resolveActiveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
    final public func resolveAnimationDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
    final public func resolveAnimationType(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTabs.TabTitleStyle.AnimationType
    final public func resolveCornerRadius(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
    final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
    final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
    final public func resolveInactiveBackgroundColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    final public func resolveInactiveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
    final public func resolveInactiveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight?
    final public func resolveInactiveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
    final public func resolveItemSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
    final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
    final public func resolveLineHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let dynamicHeight: DivKit.Expression<Swift.Bool>
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let hasSeparator: DivKit.Expression<Swift.Bool>
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let items: [DivKit.DivTabs.Item]
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let restrictParentScroll: DivKit.Expression<Swift.Bool>
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectedActions: [DivKit.DivAction]?
  final public let selectedTab: DivKit.Expression<Swift.Int>
  final public let separatorColor: DivKit.Expression<VGSLUI.Color>
  final public let separatorPaddings: DivKit.DivEdgeInsets
  final public let switchTabsByContentSwipeEnabled: DivKit.Expression<Swift.Bool>
  final public let tabTitleDelimiter: DivKit.DivTabs.TabTitleDelimiter?
  final public let tabTitleStyle: DivKit.DivTabs.TabTitleStyle?
  final public let titlePaddings: DivKit.DivEdgeInsets
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveDynamicHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveHasSeparator(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveRestrictParentScroll(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveSelectedTab(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveSeparatorColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveSwitchTabsByContentSwipeEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivTabs : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivTabs.Item : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivTabs.TabTitleDelimiter : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivTabs.TabTitleStyle : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivTabs : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
@_hasMissingDesignatedInitializers final public class DivTabsTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ItemTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let div: DivKit.Field<DivKit.DivTemplate>?
    final public let title: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let titleClickAction: DivKit.Field<DivKit.DivActionTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTabsTemplate.ItemTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTabs.Item>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTabsTemplate.ItemTemplate
    public typealias ResolvedValue = DivKit.DivTabs.Item
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TabTitleDelimiterTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let height: DivKit.Field<DivKit.DivFixedSizeTemplate>?
    final public let imageUrl: DivKit.Field<DivKit.Expression<Foundation.URL>>?
    final public let width: DivKit.Field<DivKit.DivFixedSizeTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTabsTemplate.TabTitleDelimiterTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTabs.TabTitleDelimiter>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTabsTemplate.TabTitleDelimiterTemplate
    public typealias ResolvedValue = DivKit.DivTabs.TabTitleDelimiter
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class TabTitleStyleTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
    public typealias AnimationType = DivKit.DivTabs.TabTitleStyle.AnimationType
    final public let activeBackgroundColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let activeFontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
    final public let activeFontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
    final public let activeTextColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let animationDuration: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let animationType: DivKit.Field<DivKit.Expression<DivKit.DivTabsTemplate.TabTitleStyleTemplate.AnimationType>>?
    final public let cornerRadius: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let cornersRadius: DivKit.Field<DivKit.DivCornersRadiusTemplate>?
    final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
    final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
    final public let inactiveBackgroundColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let inactiveFontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
    final public let inactiveFontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
    final public let inactiveTextColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let itemSpacing: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
    final public let lineHeight: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTabsTemplate.TabTitleStyleTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTabs.TabTitleStyle>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTabsTemplate.TabTitleStyleTemplate
    public typealias ResolvedValue = DivKit.DivTabs.TabTitleStyle
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let dynamicHeight: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let hasSeparator: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let items: DivKit.Field<[DivKit.DivTabsTemplate.ItemTemplate]>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let restrictParentScroll: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let selectedTab: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let separatorColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let separatorPaddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let switchTabsByContentSwipeEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let tabTitleDelimiter: DivKit.Field<DivKit.DivTabsTemplate.TabTitleDelimiterTemplate>?
  final public let tabTitleStyle: DivKit.Field<DivKit.DivTabsTemplate.TabTitleStyleTemplate>?
  final public let titlePaddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTabsTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTabs>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTabsTemplate
  public typealias ResolvedValue = DivKit.DivTabs
  @objc deinit
}
@frozen public enum DivTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divImageTemplate(DivKit.DivImageTemplate)
  case divGifImageTemplate(DivKit.DivGifImageTemplate)
  case divTextTemplate(DivKit.DivTextTemplate)
  case divSeparatorTemplate(DivKit.DivSeparatorTemplate)
  case divContainerTemplate(DivKit.DivContainerTemplate)
  case divGridTemplate(DivKit.DivGridTemplate)
  case divGalleryTemplate(DivKit.DivGalleryTemplate)
  case divPagerTemplate(DivKit.DivPagerTemplate)
  case divTabsTemplate(DivKit.DivTabsTemplate)
  case divStateTemplate(DivKit.DivStateTemplate)
  case divCustomTemplate(DivKit.DivCustomTemplate)
  case divIndicatorTemplate(DivKit.DivIndicatorTemplate)
  case divSliderTemplate(DivKit.DivSliderTemplate)
  case divSwitchTemplate(DivKit.DivSwitchTemplate)
  case divInputTemplate(DivKit.DivInputTemplate)
  case divSelectTemplate(DivKit.DivSelectTemplate)
  case divVideoTemplate(DivKit.DivVideoTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.Div>
  public typealias ResolvedValue = DivKit.Div
}
extension DivKit.DivTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
public struct DivTemplates : Serialization.Deserializable, @unchecked Swift.Sendable {
  public let templates: [DivKit.TemplateName : Any]
  public let templateToType: [DivKit.TemplateName : Swift.String]
  public static let empty: DivKit.DivTemplates
  public init(templates: [DivKit.TemplateName : Any], templatesToType: [DivKit.TemplateName : Swift.String])
  public init(dictionary: [Swift.String : Any])
}
extension DivKit.DivTemplates {
  public init(templatesToResolve: [Swift.String : Any], allTemplates: [Swift.String : Any])
  public func parseValue<T>(type _: T.Type, from dict: [Swift.String : Any]) -> Serialization.DeserializationResult<T.ResolvedValue> where T : DivKit.TemplateValue
  public func resolve(newTemplates: [Swift.String : Any]) -> DivKit.DivTemplates
}
@_hasMissingDesignatedInitializers final public class DivText : DivKit.DivBase, @unchecked Swift.Sendable {
  @frozen public enum Truncate : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case none
    case start
    case end
    case middle
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivText.Truncate]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivText.Truncate] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @_hasMissingDesignatedInitializers final public class Ellipsis : Swift.Sendable {
    final public let actions: [DivKit.DivAction]?
    final public let images: [DivKit.DivText.Image]?
    final public let ranges: [DivKit.DivText.Range]?
    final public let text: DivKit.Expression<Swift.String>
    final public func resolveText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class Image : Swift.Sendable {
    @frozen public enum IndexingDirection : Swift.String, Swift.CaseIterable, Swift.Sendable {
      case normal
      case reversed
      public init?(rawValue: Swift.String)
      public typealias AllCases = [DivKit.DivText.Image.IndexingDirection]
      public typealias RawValue = Swift.String
      nonisolated public static var allCases: [DivKit.DivText.Image.IndexingDirection] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
    @_hasMissingDesignatedInitializers final public class Accessibility : Swift.Sendable {
      @frozen public enum Kind : Swift.String, Swift.CaseIterable, Swift.Sendable {
        case none
        case button
        case image
        case text
        case auto
        public init?(rawValue: Swift.String)
        public typealias AllCases = [DivKit.DivText.Image.Accessibility.Kind]
        public typealias RawValue = Swift.String
        nonisolated public static var allCases: [DivKit.DivText.Image.Accessibility.Kind] {
          get
        }
        public var rawValue: Swift.String {
          get
        }
      }
      final public let description: DivKit.Expression<Swift.String>?
      final public let type: DivKit.DivText.Image.Accessibility.Kind
      final public func resolveDescription(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
      @objc deinit
    }
    final public let accessibility: DivKit.DivText.Image.Accessibility?
    final public let alignmentVertical: DivKit.Expression<DivKit.DivTextAlignmentVertical>
    final public let height: DivKit.DivFixedSize
    final public let indexingDirection: DivKit.Expression<DivKit.DivText.Image.IndexingDirection>
    final public let preloadRequired: DivKit.Expression<Swift.Bool>
    final public let start: DivKit.Expression<Swift.Int>
    final public let tintColor: DivKit.Expression<VGSLUI.Color>?
    final public let tintMode: DivKit.Expression<DivKit.DivBlendMode>
    final public let url: DivKit.Expression<Foundation.URL>
    final public let width: DivKit.DivFixedSize
    final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTextAlignmentVertical
    final public func resolveIndexingDirection(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivText.Image.IndexingDirection
    final public func resolvePreloadRequired(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
    final public func resolveStart(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveTintColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    final public func resolveTintMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivBlendMode
    final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class Range : @unchecked Swift.Sendable {
    final public let actions: [DivKit.DivAction]?
    final public let alignmentVertical: DivKit.Expression<DivKit.DivTextAlignmentVertical>?
    final public let background: DivKit.DivTextRangeBackground?
    final public let baselineOffset: DivKit.Expression<Swift.Double>
    final public let border: DivKit.DivTextRangeBorder?
    final public let end: DivKit.Expression<Swift.Int>?
    final public let fontFamily: DivKit.Expression<Swift.String>?
    final public let fontFeatureSettings: DivKit.Expression<Swift.String>?
    final public let fontSize: DivKit.Expression<Swift.Int>?
    final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
    final public let fontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
    final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>?
    final public let fontWeightValue: DivKit.Expression<Swift.Int>?
    final public let letterSpacing: DivKit.Expression<Swift.Double>?
    final public let lineHeight: DivKit.Expression<Swift.Int>?
    final public let mask: DivKit.DivTextRangeMask?
    final public let start: DivKit.Expression<Swift.Int>
    final public let strike: DivKit.Expression<DivKit.DivLineStyle>?
    final public let textColor: DivKit.Expression<VGSLUI.Color>?
    final public let textShadow: DivKit.DivShadow?
    final public let topOffset: DivKit.Expression<Swift.Int>?
    final public let underline: DivKit.Expression<DivKit.DivLineStyle>?
    final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTextAlignmentVertical?
    final public func resolveBaselineOffset(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
    final public func resolveEnd(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveFontFeatureSettings(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
    final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
    final public func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
    final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight?
    final public func resolveFontWeightValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
    final public func resolveLineHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveStart(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
    final public func resolveStrike(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivLineStyle?
    final public func resolveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
    final public func resolveTopOffset(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveUnderline(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivLineStyle?
    @objc deinit
  }
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let action: DivKit.DivAction?
  final public let actionAnimation: DivKit.DivAnimation
  final public let actions: [DivKit.DivAction]?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let autoEllipsize: DivKit.Expression<Swift.Bool>?
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let captureFocusOnAction: DivKit.Expression<Swift.Bool>
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let doubletapActions: [DivKit.DivAction]?
  final public let ellipsis: DivKit.DivText.Ellipsis?
  final public let extensions: [DivKit.DivExtension]?
  final public let focus: DivKit.DivFocus?
  final public let focusedTextColor: DivKit.Expression<VGSLUI.Color>?
  final public let fontFamily: DivKit.Expression<Swift.String>?
  final public let fontFeatureSettings: DivKit.Expression<Swift.String>?
  final public let fontSize: DivKit.Expression<Swift.Int>
  final public let fontSizeUnit: DivKit.Expression<DivKit.DivSizeUnit>
  final public let fontVariationSettings: DivKit.Expression<[Swift.String : Any]>?
  final public let fontWeight: DivKit.Expression<DivKit.DivFontWeight>
  final public let fontWeightValue: DivKit.Expression<Swift.Int>?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let hoverEndActions: [DivKit.DivAction]?
  final public let hoverStartActions: [DivKit.DivAction]?
  final public let id: Swift.String?
  final public let images: [DivKit.DivText.Image]?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let letterSpacing: DivKit.Expression<Swift.Double>
  final public let lineHeight: DivKit.Expression<Swift.Int>?
  final public let longtapActions: [DivKit.DivAction]?
  final public let margins: DivKit.DivEdgeInsets?
  final public let maxLines: DivKit.Expression<Swift.Int>?
  final public let minHiddenLines: DivKit.Expression<Swift.Int>?
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pressEndActions: [DivKit.DivAction]?
  final public let pressStartActions: [DivKit.DivAction]?
  final public let ranges: [DivKit.DivText.Range]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let selectable: DivKit.Expression<Swift.Bool>
  final public let selectedActions: [DivKit.DivAction]?
  final public let strike: DivKit.Expression<DivKit.DivLineStyle>
  final public let text: DivKit.Expression<Swift.String>
  final public let textAlignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>
  final public let textAlignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>
  final public let textColor: DivKit.Expression<VGSLUI.Color>
  final public let textGradient: DivKit.DivTextGradient?
  final public let textShadow: DivKit.DivShadow?
  final public let tightenWidth: DivKit.Expression<Swift.Bool>
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let truncate: DivKit.Expression<DivKit.DivText.Truncate>
  final public let underline: DivKit.Expression<DivKit.DivLineStyle>
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveAutoEllipsize(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  final public func resolveCaptureFocusOnAction(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveFocusedTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveFontFamily(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveFontFeatureSettings(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  final public func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
  final public func resolveFontWeight(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
  final public func resolveFontWeightValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveLetterSpacing(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveLineHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMaxLines(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMinHiddenLines(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveSelectable(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveStrike(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivLineStyle
  final public func resolveText(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveTextAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal
  final public func resolveTextAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical
  final public func resolveTextColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color
  final public func resolveTightenWidth(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveTruncate(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivText.Truncate
  final public func resolveUnderline(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivLineStyle
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivText : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivText.Ellipsis : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivText.Image.Accessibility : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivText.Image : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivText.Range : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivTextAlignmentVertical : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case top
  case center
  case bottom
  case baseline
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivTextAlignmentVertical]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivTextAlignmentVertical] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension DivKit.DivText : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
extension DivKit.DivText : DivKit.FontParamsProvider {
}
@frozen public enum DivTextGradient : Swift.Sendable {
  case divLinearGradient(DivKit.DivLinearGradient)
  case divRadialGradient(DivKit.DivRadialGradient)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivTextGradient : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivTextGradientTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divLinearGradientTemplate(DivKit.DivLinearGradientTemplate)
  case divRadialGradientTemplate(DivKit.DivRadialGradientTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextGradientTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextGradientTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextGradient>
  public typealias ResolvedValue = DivKit.DivTextGradient
}
extension DivKit.DivTextGradientTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@frozen public enum DivTextRangeBackground : Swift.Sendable {
  case divSolidBackground(DivKit.DivSolidBackground)
  case divCloudBackground(DivKit.DivCloudBackground)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivTextRangeBackground : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivTextRangeBackgroundTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divSolidBackgroundTemplate(DivKit.DivSolidBackgroundTemplate)
  case divCloudBackgroundTemplate(DivKit.DivCloudBackgroundTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeBackgroundTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeBackgroundTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeBackground>
  public typealias ResolvedValue = DivKit.DivTextRangeBackground
}
extension DivKit.DivTextRangeBackgroundTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivTextRangeBorder : Swift.Sendable {
  final public let cornerRadius: DivKit.Expression<Swift.Int>?
  final public let stroke: DivKit.DivStroke?
  final public func resolveCornerRadius(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivTextRangeBorder : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTextRangeBorderTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let cornerRadius: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let stroke: DivKit.Field<DivKit.DivStrokeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeBorderTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeBorder>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeBorderTemplate
  public typealias ResolvedValue = DivKit.DivTextRangeBorder
  @objc deinit
}
@frozen public enum DivTextRangeMask : Swift.Sendable {
  case divTextRangeMaskParticles(DivKit.DivTextRangeMaskParticles)
  case divTextRangeMaskSolid(DivKit.DivTextRangeMaskSolid)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivTextRangeMask : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskBase : Swift.Sendable {
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivTextRangeMaskBase : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskBaseTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeMaskBaseTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeMaskBase>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeMaskBaseTemplate
  public typealias ResolvedValue = DivKit.DivTextRangeMaskBase
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskParticles : Swift.Sendable {
  public static let type: Swift.String
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let density: DivKit.Expression<Swift.Double>
  final public let isAnimated: DivKit.Expression<Swift.Bool>
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let particleSize: DivKit.DivFixedSize
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveDensity(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveIsAnimated(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivTextRangeMaskParticles : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskParticlesTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let density: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let isAnimated: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let particleSize: DivKit.Field<DivKit.DivFixedSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeMaskParticlesTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeMaskParticles>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeMaskParticlesTemplate
  public typealias ResolvedValue = DivKit.DivTextRangeMaskParticles
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskSolid : Swift.Sendable {
  public static let type: Swift.String
  final public let color: DivKit.Expression<VGSLUI.Color>
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public func resolveColor(_ resolver: DivKit.ExpressionResolver) -> VGSLUI.Color?
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  @objc deinit
}
extension DivKit.DivTextRangeMaskSolid : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTextRangeMaskSolidTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let color: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeMaskSolidTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeMaskSolid>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeMaskSolidTemplate
  public typealias ResolvedValue = DivKit.DivTextRangeMaskSolid
  @objc deinit
}
@frozen public enum DivTextRangeMaskTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divTextRangeMaskParticlesTemplate(DivKit.DivTextRangeMaskParticlesTemplate)
  case divTextRangeMaskSolidTemplate(DivKit.DivTextRangeMaskSolidTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextRangeMaskTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextRangeMaskTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTextRangeMask>
  public typealias ResolvedValue = DivKit.DivTextRangeMask
}
extension DivKit.DivTextRangeMaskTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivTextTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class EllipsisTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
    final public let images: DivKit.Field<[DivKit.DivTextTemplate.ImageTemplate]>?
    final public let ranges: DivKit.Field<[DivKit.DivTextTemplate.RangeTemplate]>?
    final public let text: DivKit.Field<DivKit.Expression<Swift.String>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextTemplate.EllipsisTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivText.Ellipsis>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextTemplate.EllipsisTemplate
    public typealias ResolvedValue = DivKit.DivText.Ellipsis
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class ImageTemplate : DivKit.TemplateValue, Swift.Sendable {
    @_hasMissingDesignatedInitializers final public class AccessibilityTemplate : DivKit.TemplateValue, Swift.Sendable {
      public typealias Kind = DivKit.DivText.Image.Accessibility.Kind
      final public let description: DivKit.Field<DivKit.Expression<Swift.String>>?
      final public let type: DivKit.Field<DivKit.DivTextTemplate.ImageTemplate.AccessibilityTemplate.Kind>?
      convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
      public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextTemplate.ImageTemplate.AccessibilityTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivText.Image.Accessibility>
      final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextTemplate.ImageTemplate.AccessibilityTemplate
      public typealias ResolvedValue = DivKit.DivText.Image.Accessibility
      @objc deinit
    }
    public typealias IndexingDirection = DivKit.DivText.Image.IndexingDirection
    final public let accessibility: DivKit.Field<DivKit.DivTextTemplate.ImageTemplate.AccessibilityTemplate>?
    final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivTextAlignmentVertical>>?
    final public let height: DivKit.Field<DivKit.DivFixedSizeTemplate>?
    final public let indexingDirection: DivKit.Field<DivKit.Expression<DivKit.DivTextTemplate.ImageTemplate.IndexingDirection>>?
    final public let preloadRequired: DivKit.Field<DivKit.Expression<Swift.Bool>>?
    final public let start: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let tintColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let tintMode: DivKit.Field<DivKit.Expression<DivKit.DivBlendMode>>?
    final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
    final public let width: DivKit.Field<DivKit.DivFixedSizeTemplate>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextTemplate.ImageTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivText.Image>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextTemplate.ImageTemplate
    public typealias ResolvedValue = DivKit.DivText.Image
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class RangeTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
    final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
    final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivTextAlignmentVertical>>?
    final public let background: DivKit.Field<DivKit.DivTextRangeBackgroundTemplate>?
    final public let baselineOffset: DivKit.Field<DivKit.Expression<Swift.Double>>?
    final public let border: DivKit.Field<DivKit.DivTextRangeBorderTemplate>?
    final public let end: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let fontFeatureSettings: DivKit.Field<DivKit.Expression<Swift.String>>?
    final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
    final public let fontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
    final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
    final public let fontWeightValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
    final public let lineHeight: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let mask: DivKit.Field<DivKit.DivTextRangeMaskTemplate>?
    final public let start: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let strike: DivKit.Field<DivKit.Expression<DivKit.DivLineStyle>>?
    final public let textColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
    final public let textShadow: DivKit.Field<DivKit.DivShadowTemplate>?
    final public let topOffset: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let underline: DivKit.Field<DivKit.Expression<DivKit.DivLineStyle>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextTemplate.RangeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivText.Range>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextTemplate.RangeTemplate
    public typealias ResolvedValue = DivKit.DivText.Range
    @objc deinit
  }
  public typealias Truncate = DivKit.DivText.Truncate
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let action: DivKit.Field<DivKit.DivActionTemplate>?
  final public let actionAnimation: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let autoEllipsize: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let captureFocusOnAction: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let doubletapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let ellipsis: DivKit.Field<DivKit.DivTextTemplate.EllipsisTemplate>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let focusedTextColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let fontFamily: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let fontFeatureSettings: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let fontSize: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let fontSizeUnit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
  final public let fontVariationSettings: DivKit.Field<DivKit.Expression<[Swift.String : Any]>>?
  final public let fontWeight: DivKit.Field<DivKit.Expression<DivKit.DivFontWeight>>?
  final public let fontWeightValue: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let hoverEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let hoverStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let images: DivKit.Field<[DivKit.DivTextTemplate.ImageTemplate]>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let letterSpacing: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let lineHeight: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let longtapActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let maxLines: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let minHiddenLines: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pressEndActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let pressStartActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let ranges: DivKit.Field<[DivKit.DivTextTemplate.RangeTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let selectable: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let strike: DivKit.Field<DivKit.Expression<DivKit.DivLineStyle>>?
  final public let text: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let textAlignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let textAlignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let textColor: DivKit.Field<DivKit.Expression<VGSLUI.Color>>?
  final public let textGradient: DivKit.Field<DivKit.DivTextGradientTemplate>?
  final public let textShadow: DivKit.Field<DivKit.DivShadowTemplate>?
  final public let tightenWidth: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let truncate: DivKit.Field<DivKit.Expression<DivKit.DivTextTemplate.Truncate>>?
  final public let underline: DivKit.Field<DivKit.Expression<DivKit.DivLineStyle>>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTextTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivText>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTextTemplate
  public typealias ResolvedValue = DivKit.DivText
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTimer : Swift.Sendable {
  final public let duration: DivKit.Expression<Swift.Int>
  final public let endActions: [DivKit.DivAction]?
  final public let id: Swift.String
  final public let tickActions: [DivKit.DivAction]?
  final public let tickInterval: DivKit.Expression<Swift.Int>?
  final public let valueVariable: Swift.String?
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveTickInterval(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.DivTimer : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public enum DivTimerAction {
  case start
  case stop
  case pause
  case resume
  case cancel
  case reset
  public static func == (a: DivKit.DivTimerAction, b: DivKit.DivTimerAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivTimerTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let endActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let id: DivKit.Field<Swift.String>?
  final public let tickActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tickInterval: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let valueVariable: DivKit.Field<Swift.String>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTimerTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTimer>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTimerTemplate
  public typealias ResolvedValue = DivKit.DivTimer
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTooltip : Swift.Sendable {
  @frozen public enum Position : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case left
    case topLeft
    case top
    case topRight
    case right
    case bottomRight
    case bottom
    case bottomLeft
    case center
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivTooltip.Position]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivTooltip.Position] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  final public let animationIn: DivKit.DivAnimation?
  final public let animationOut: DivKit.DivAnimation?
  final public let backgroundAccessibilityDescription: DivKit.Expression<Swift.String>?
  final public let closeByTapOutside: DivKit.Expression<Swift.Bool>
  final public let div: DivKit.Div
  final public let duration: DivKit.Expression<Swift.Int>
  final public let id: Swift.String
  final public let mode: DivKit.DivTooltipMode
  final public let offset: DivKit.DivPoint?
  final public let position: DivKit.Expression<DivKit.DivTooltip.Position>
  final public let tapOutsideActions: [DivKit.DivAction]?
  final public func resolveBackgroundAccessibilityDescription(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveCloseByTapOutside(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolvePosition(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTooltip.Position?
  @objc deinit
}
extension DivKit.DivTooltip : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivTooltipMode : Swift.Sendable {
  case divTooltipModeNonModal(DivKit.DivTooltipModeNonModal)
  case divTooltipModeModal(DivKit.DivTooltipModeModal)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivTooltipMode : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTooltipModeModal : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivTooltipModeModal : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTooltipModeModalTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTooltipModeModalTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTooltipModeModal>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTooltipModeModalTemplate
  public typealias ResolvedValue = DivKit.DivTooltipModeModal
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTooltipModeNonModal : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.DivTooltipModeNonModal : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTooltipModeNonModalTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTooltipModeNonModalTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTooltipModeNonModal>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTooltipModeNonModalTemplate
  public typealias ResolvedValue = DivKit.DivTooltipModeNonModal
  @objc deinit
}
@frozen public enum DivTooltipModeTemplate : DivKit.TemplateValue, Swift.Sendable {
  case divTooltipModeNonModalTemplate(DivKit.DivTooltipModeNonModalTemplate)
  case divTooltipModeModalTemplate(DivKit.DivTooltipModeModalTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTooltipModeTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTooltipModeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTooltipMode>
  public typealias ResolvedValue = DivKit.DivTooltipMode
}
extension DivKit.DivTooltipModeTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivTooltipTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Position = DivKit.DivTooltip.Position
  final public let animationIn: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let animationOut: DivKit.Field<DivKit.DivAnimationTemplate>?
  final public let backgroundAccessibilityDescription: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let closeByTapOutside: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let div: DivKit.Field<DivKit.DivTemplate>?
  final public let duration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let id: DivKit.Field<Swift.String>?
  final public let mode: DivKit.Field<DivKit.DivTooltipModeTemplate>?
  final public let offset: DivKit.Field<DivKit.DivPointTemplate>?
  final public let position: DivKit.Field<DivKit.Expression<DivKit.DivTooltipTemplate.Position>>?
  final public let tapOutsideActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTooltipTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTooltip>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTooltipTemplate
  public typealias ResolvedValue = DivKit.DivTooltip
  @objc deinit
}
public struct DivTooltipViewFactory {
}
@_hasMissingDesignatedInitializers final public class DivTransform : Swift.Sendable {
  final public let pivotX: DivKit.DivPivot
  final public let pivotY: DivKit.DivPivot
  final public let rotation: DivKit.Expression<Swift.Double>?
  final public func resolveRotation(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.DivTransform : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTransformTemplate : DivKit.TemplateValue, Swift.Sendable {
  final public let pivotX: DivKit.Field<DivKit.DivPivotTemplate>?
  final public let pivotY: DivKit.Field<DivKit.DivPivotTemplate>?
  final public let rotation: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTransformTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTransform>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTransformTemplate
  public typealias ResolvedValue = DivKit.DivTransform
  @objc deinit
}
public protocol DivTransitionBase {
  var duration: DivKit.Expression<Swift.Int> { get }
  var interpolator: DivKit.Expression<DivKit.DivAnimationInterpolator> { get }
  var startDelay: DivKit.Expression<Swift.Int> { get }
  func resolveDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  func resolveInterpolator(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAnimationInterpolator
  func resolveStartDelay(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
}
@frozen public enum DivTransitionSelector : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case none
  case dataChange
  case stateChange
  case anyChange
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivTransitionSelector]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivTransitionSelector] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@frozen public enum DivTransitionTrigger : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case dataChange
  case stateChange
  case visibilityChange
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivTransitionTrigger]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivTransitionTrigger] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivTrigger : Swift.Sendable {
  @frozen public enum Mode : Swift.String, Swift.CaseIterable, Swift.Sendable {
    case onCondition
    case onVariable
    public init?(rawValue: Swift.String)
    public typealias AllCases = [DivKit.DivTrigger.Mode]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [DivKit.DivTrigger.Mode] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  final public let actions: [DivKit.DivAction]
  final public let condition: DivKit.Expression<Swift.Bool>
  final public let mode: DivKit.Expression<DivKit.DivTrigger.Mode>
  final public func resolveCondition(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  final public func resolveMode(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivTrigger.Mode
  @objc deinit
}
extension DivKit.DivTrigger : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivTriggersStorage {
  final public func set(cardId: DivKit.DivCardID, triggers: [DivKit.DivTrigger])
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivTriggerTemplate : DivKit.TemplateValue, Swift.Sendable {
  public typealias Mode = DivKit.DivTrigger.Mode
  final public let actions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let condition: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let mode: DivKit.Field<DivKit.Expression<DivKit.DivTriggerTemplate.Mode>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTriggerTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTrigger>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTriggerTemplate
  public typealias ResolvedValue = DivKit.DivTrigger
  @objc deinit
}
@frozen public enum DivTypedValue : Swift.Sendable {
  case stringValue(DivKit.StringValue)
  case integerValue(DivKit.IntegerValue)
  case numberValue(DivKit.NumberValue)
  case colorValue(DivKit.ColorValue)
  case booleanValue(DivKit.BooleanValue)
  case urlValue(DivKit.UrlValue)
  case dictValue(DivKit.DictValue)
  case arrayValue(DivKit.ArrayValue)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivTypedValue : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@frozen public enum DivTypedValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  case stringValueTemplate(DivKit.StringValueTemplate)
  case integerValueTemplate(DivKit.IntegerValueTemplate)
  case numberValueTemplate(DivKit.NumberValueTemplate)
  case colorValueTemplate(DivKit.ColorValueTemplate)
  case booleanValueTemplate(DivKit.BooleanValueTemplate)
  case urlValueTemplate(DivKit.UrlValueTemplate)
  case dictValueTemplate(DivKit.DictValueTemplate)
  case arrayValueTemplate(DivKit.ArrayValueTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivTypedValueTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivTypedValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivTypedValue>
  public typealias ResolvedValue = DivKit.DivTypedValue
}
extension DivKit.DivTypedValueTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
public protocol DivUrlHandler {
  func handle(_ url: Foundation.URL, sender: Swift.AnyObject?)
  func handle(_ url: Foundation.URL, info: DivKit.DivActionInfo, sender: Swift.AnyObject?)
}
extension DivKit.DivUrlHandler {
  public func handle(_: Foundation.URL, sender _: Swift.AnyObject?)
  public func handle(_ url: Foundation.URL, info _: DivKit.DivActionInfo, sender: Swift.AnyObject?)
}
public struct DivUrlHandlerDelegate : DivKit.DivUrlHandler {
  public init(_ handle: @escaping (Foundation.URL) -> Swift.Void)
  public init(_ handle: @escaping (Foundation.URL, Swift.AnyObject?) -> Swift.Void)
  public func handle(_ url: Foundation.URL, sender: Swift.AnyObject?)
}
@frozen public enum DivVariable : Swift.Sendable {
  case stringVariable(DivKit.StringVariable)
  case numberVariable(DivKit.NumberVariable)
  case integerVariable(DivKit.IntegerVariable)
  case booleanVariable(DivKit.BooleanVariable)
  case colorVariable(DivKit.ColorVariable)
  case urlVariable(DivKit.UrlVariable)
  case dictVariable(DivKit.DictVariable)
  case arrayVariable(DivKit.ArrayVariable)
  public var value: any Serialization.Serializable {
    get
  }
}
extension DivKit.DivVariable : Serialization.Serializable {
  public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
public enum DivVariableNameTag {
}
public typealias DivVariableName = VGSLFundamentals.Tagged<DivKit.DivVariableNameTag, Swift.String>
public typealias DivVariables = [DivKit.DivVariableName : DivKit.DivVariableValue]
final public class DivVariablesStorage {
  public struct Values {
    public var global: DivKit.DivVariables {
      get
    }
    public var local: [DivKit.DivCardID : DivKit.DivVariables] {
      get
    }
  }
  public struct ChangeEvent {
    @frozen public enum Kind : Swift.Equatable {
      case local(DivKit.DivCardID, Swift.Set<DivKit.DivVariableName>)
      case global(Swift.Set<DivKit.DivVariableName>)
      public static func == (a: DivKit.DivVariablesStorage.ChangeEvent.Kind, b: DivKit.DivVariablesStorage.ChangeEvent.Kind) -> Swift.Bool
    }
    public let kind: DivKit.DivVariablesStorage.ChangeEvent.Kind
    public var changedVariables: Swift.Set<DivKit.DivVariableName> {
      get
    }
  }
  final public let changeEvents: VGSLFundamentals.Signal<DivKit.DivVariablesStorage.ChangeEvent>
  convenience public init()
  public init(outerStorage: DivKit.DivVariableStorage?)
  final public func getVariableValue<T>(cardId: DivKit.DivCardID, name: DivKit.DivVariableName) -> T?
  final public func getVariableValue(cardId: DivKit.DivCardID, name: DivKit.DivVariableName) -> DivKit.DivVariableValue?
  final public func hasValue(cardId: DivKit.DivCardID, name: DivKit.DivVariableName) -> Swift.Bool
  final public func set(cardId: DivKit.DivCardID, variables: DivKit.DivVariables)
  final public func append(variables newVariables: DivKit.DivVariables, for cardId: DivKit.DivCardID, replaceExisting: Swift.Bool = true)
  final public func set(variables: DivKit.DivVariables, triggerUpdate: Swift.Bool)
  final public func append(variables: DivKit.DivVariables, triggerUpdate: Swift.Bool)
  final public func reset()
  final public func reset(cardId: DivKit.DivCardID)
  final public func addObserver(_ action: @escaping (DivKit.DivVariablesStorage.ChangeEvent) -> Swift.Void) -> VGSLFundamentals.Disposable
  @objc deinit
}
extension DivKit.DivVariablesStorage {
  final public func update(cardId: DivKit.DivCardID, name: DivKit.DivVariableName, value: Swift.String)
  final public func update(path: LayoutKitInterface.UIElementPath, name: DivKit.DivVariableName, value: Swift.String)
}
extension Swift.Collection where Self.Element == DivKit.DivVariable {
  public func extractDivVariableValues(_ resolver: DivKit.ExpressionResolver? = nil) -> DivKit.DivVariables
}
extension Swift.Dictionary where Key == Swift.String {
  public func mapToDivVariables(valueTransform: (Value) -> DivKit.DivVariableValue) -> DivKit.DivVariables
}
extension Swift.Dictionary where Key == Swift.String, Value == VGSLUI.RGBAColor {
  public func mapToDivVariables() -> DivKit.DivVariables
}
@_hasMissingDesignatedInitializers final public class DivVariableStorage {
  public struct ChangeEvent {
    public let changedVariables: Swift.Set<DivKit.DivVariableName>
  }
  final public var allValues: DivKit.DivVariables {
    get
  }
  convenience public init(outerStorage: DivKit.DivVariableStorage? = nil)
  final public func getVariableValue(_ name: DivKit.DivVariableName) -> DivKit.DivVariableValue?
  final public func getValue<T>(_ name: DivKit.DivVariableName) -> T?
  final public func hasValue(_ name: DivKit.DivVariableName) -> Swift.Bool
  final public func put(name: DivKit.DivVariableName, value: DivKit.DivVariableValue)
  final public func put(_ variables: DivKit.DivVariables, notifyObservers: Swift.Bool = true)
  final public func replaceAll(_ variables: DivKit.DivVariables, notifyObservers: Swift.Bool = true)
  final public func update(name: DivKit.DivVariableName, value: DivKit.DivVariableValue)
  final public func clear()
  final public func remove(variableNames: Swift.Set<DivKit.DivVariableName>, notifyObservers: Swift.Bool = true)
  final public func addObserver(_ action: @escaping (DivKit.DivVariableStorage.ChangeEvent) -> Swift.Void) -> VGSLFundamentals.Disposable
  @objc deinit
}
@frozen public enum DivVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  case stringVariableTemplate(DivKit.StringVariableTemplate)
  case numberVariableTemplate(DivKit.NumberVariableTemplate)
  case integerVariableTemplate(DivKit.IntegerVariableTemplate)
  case booleanVariableTemplate(DivKit.BooleanVariableTemplate)
  case colorVariableTemplate(DivKit.ColorVariableTemplate)
  case urlVariableTemplate(DivKit.UrlVariableTemplate)
  case dictVariableTemplate(DivKit.DictVariableTemplate)
  case arrayVariableTemplate(DivKit.ArrayVariableTemplate)
  public var value: Any {
    get
  }
  public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivVariableTemplate
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivVariable>
  public typealias ResolvedValue = DivKit.DivVariable
}
extension DivKit.DivVariableTemplate {
  public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
}
@_hasMissingDesignatedInitializers final public class DivVariableTracker {
  final public var usedVariablesByCard: [DivKit.DivCardID : Swift.Set<DivKit.DivVariableName>] {
    get
  }
  @objc deinit
}
@frozen public enum DivVariableValue : Swift.Hashable {
  case string(Swift.String)
  case number(Swift.Double)
  case integer(Swift.Int)
  case bool(Swift.Bool)
  case color(VGSLUI.Color)
  case url(Foundation.URL)
  case dict(DivKit.DivDictionary)
  case array(DivKit.DivArray)
  @inlinable public func typedValue<T>() -> T? {
    switch self {
    case let .string(value):
      return value as? T
    case let .number(value):
      return value as? T
    case let .integer(value):
      return value as? T
    case let .bool(value):
      return value as? T
    case let .color(value):
      return value as? T
    case let .url(value):
      return value as? T
    case let .dict(value):
      return value as? T
    case let .array(value):
      return value as? T
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DivKit.DivVariableValue, b: DivKit.DivVariableValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivVideo : DivKit.DivBase, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let accessibility: DivKit.DivAccessibility?
  final public let alignmentHorizontal: DivKit.Expression<DivKit.DivAlignmentHorizontal>?
  final public let alignmentVertical: DivKit.Expression<DivKit.DivAlignmentVertical>?
  final public let alpha: DivKit.Expression<Swift.Double>
  final public let animators: [DivKit.DivAnimator]?
  final public let aspect: DivKit.DivAspect?
  final public let autostart: DivKit.Expression<Swift.Bool>
  final public let background: [DivKit.DivBackground]?
  final public let border: DivKit.DivBorder?
  final public let bufferingActions: [DivKit.DivAction]?
  final public let columnSpan: DivKit.Expression<Swift.Int>?
  final public let disappearActions: [DivKit.DivDisappearAction]?
  final public let elapsedTimeVariable: Swift.String?
  final public let endActions: [DivKit.DivAction]?
  final public let extensions: [DivKit.DivExtension]?
  final public let fatalActions: [DivKit.DivAction]?
  final public let focus: DivKit.DivFocus?
  final public let functions: [DivKit.DivFunction]?
  final public let height: DivKit.DivSize
  final public let id: Swift.String?
  final public let layoutProvider: DivKit.DivLayoutProvider?
  final public let margins: DivKit.DivEdgeInsets?
  final public let muted: DivKit.Expression<Swift.Bool>
  final public let paddings: DivKit.DivEdgeInsets?
  final public let pauseActions: [DivKit.DivAction]?
  final public let playerSettingsPayload: [Swift.String : Any]?
  final public let preloadRequired: DivKit.Expression<Swift.Bool>
  final public let preview: DivKit.Expression<Swift.String>?
  final public let repeatable: DivKit.Expression<Swift.Bool>
  final public let resumeActions: [DivKit.DivAction]?
  final public let reuseId: DivKit.Expression<Swift.String>?
  final public let rowSpan: DivKit.Expression<Swift.Int>?
  final public let scale: DivKit.Expression<DivKit.DivVideoScale>
  final public let selectedActions: [DivKit.DivAction]?
  final public let tooltips: [DivKit.DivTooltip]?
  final public let transform: DivKit.DivTransform?
  final public let transitionChange: DivKit.DivChangeTransition?
  final public let transitionIn: DivKit.DivAppearanceTransition?
  final public let transitionOut: DivKit.DivAppearanceTransition?
  final public let transitionTriggers: [DivKit.DivTransitionTrigger]?
  final public let variableTriggers: [DivKit.DivTrigger]?
  final public let variables: [DivKit.DivVariable]?
  final public let videoSources: [DivKit.DivVideoSource]
  final public let visibility: DivKit.Expression<DivKit.DivVisibility>
  final public let visibilityAction: DivKit.DivVisibilityAction?
  final public let visibilityActions: [DivKit.DivVisibilityAction]?
  final public let width: DivKit.DivSize
  final public func resolveAlignmentHorizontal(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentHorizontal?
  final public func resolveAlignmentVertical(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivAlignmentVertical?
  final public func resolveAlpha(_ resolver: DivKit.ExpressionResolver) -> Swift.Double
  final public func resolveAutostart(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveColumnSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMuted(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolvePreloadRequired(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolvePreview(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRepeatable(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveReuseId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveRowSpan(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveScale(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVideoScale
  final public func resolveVisibility(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivVisibility
  @objc deinit
}
extension DivKit.DivVideo : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivVideo : DivKit.DivBlockModeling {
  final public func makeBlock(context: DivKit.DivBlockModelingContext) throws -> any LayoutKit.Block
}
extension DivKit.DivVideoSource {
  final public func makeVideo(resolver: DivKit.ExpressionResolver) -> LayoutKit.Video?
}
@frozen public enum DivVideoScale : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case fill
  case noScale
  case fit
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivVideoScale]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivVideoScale] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivVideoSource : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class Resolution : Swift.Sendable {
    public static let type: Swift.String
    final public let height: DivKit.Expression<Swift.Int>
    final public let width: DivKit.Expression<Swift.Int>
    final public func resolveHeight(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    final public func resolveWidth(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    @objc deinit
  }
  public static let type: Swift.String
  final public let bitrate: DivKit.Expression<Swift.Int>?
  final public let mimeType: DivKit.Expression<Swift.String>
  final public let resolution: DivKit.DivVideoSource.Resolution?
  final public let url: DivKit.Expression<Foundation.URL>
  final public func resolveBitrate(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  final public func resolveMimeType(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.DivVideoSource : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivVideoSource.Resolution : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivVideoSourceTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ResolutionTemplate : DivKit.TemplateValue, Swift.Sendable {
    public static let type: Swift.String
    final public let parent: Swift.String?
    final public let height: DivKit.Field<DivKit.Expression<Swift.Int>>?
    final public let width: DivKit.Field<DivKit.Expression<Swift.Int>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivVideoSourceTemplate.ResolutionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivVideoSource.Resolution>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivVideoSourceTemplate.ResolutionTemplate
    public typealias ResolvedValue = DivKit.DivVideoSource.Resolution
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let bitrate: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let mimeType: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let resolution: DivKit.Field<DivKit.DivVideoSourceTemplate.ResolutionTemplate>?
  final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivVideoSourceTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivVideoSource>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivVideoSourceTemplate
  public typealias ResolvedValue = DivKit.DivVideoSource
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivVideoTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let accessibility: DivKit.Field<DivKit.DivAccessibilityTemplate>?
  final public let alignmentHorizontal: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentHorizontal>>?
  final public let alignmentVertical: DivKit.Field<DivKit.Expression<DivKit.DivAlignmentVertical>>?
  final public let alpha: DivKit.Field<DivKit.Expression<Swift.Double>>?
  final public let animators: DivKit.Field<[DivKit.DivAnimatorTemplate]>?
  final public let aspect: DivKit.Field<DivKit.DivAspectTemplate>?
  final public let autostart: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let background: DivKit.Field<[DivKit.DivBackgroundTemplate]>?
  final public let border: DivKit.Field<DivKit.DivBorderTemplate>?
  final public let bufferingActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let columnSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let disappearActions: DivKit.Field<[DivKit.DivDisappearActionTemplate]>?
  final public let elapsedTimeVariable: DivKit.Field<Swift.String>?
  final public let endActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let extensions: DivKit.Field<[DivKit.DivExtensionTemplate]>?
  final public let fatalActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let focus: DivKit.Field<DivKit.DivFocusTemplate>?
  final public let functions: DivKit.Field<[DivKit.DivFunctionTemplate]>?
  final public let height: DivKit.Field<DivKit.DivSizeTemplate>?
  final public let id: DivKit.Field<Swift.String>?
  final public let layoutProvider: DivKit.Field<DivKit.DivLayoutProviderTemplate>?
  final public let margins: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let muted: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let paddings: DivKit.Field<DivKit.DivEdgeInsetsTemplate>?
  final public let pauseActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let playerSettingsPayload: DivKit.Field<[Swift.String : Any]>?
  final public let preloadRequired: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let preview: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let repeatable: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let resumeActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let reuseId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let rowSpan: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let scale: DivKit.Field<DivKit.Expression<DivKit.DivVideoScale>>?
  final public let selectedActions: DivKit.Field<[DivKit.DivActionTemplate]>?
  final public let tooltips: DivKit.Field<[DivKit.DivTooltipTemplate]>?
  final public let transform: DivKit.Field<DivKit.DivTransformTemplate>?
  final public let transitionChange: DivKit.Field<DivKit.DivChangeTransitionTemplate>?
  final public let transitionIn: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionOut: DivKit.Field<DivKit.DivAppearanceTransitionTemplate>?
  final public let transitionTriggers: DivKit.Field<[DivKit.DivTransitionTrigger]>?
  final public let variableTriggers: DivKit.Field<[DivKit.DivTriggerTemplate]>?
  final public let variables: DivKit.Field<[DivKit.DivVariableTemplate]>?
  final public let videoSources: DivKit.Field<[DivKit.DivVideoSourceTemplate]>?
  final public let visibility: DivKit.Field<DivKit.Expression<DivKit.DivVisibility>>?
  final public let visibilityAction: DivKit.Field<DivKit.DivVisibilityActionTemplate>?
  final public let visibilityActions: DivKit.Field<[DivKit.DivVisibilityActionTemplate]>?
  final public let width: DivKit.Field<DivKit.DivSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivVideoTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivVideo>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivVideoTemplate
  public typealias ResolvedValue = DivKit.DivVideo
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency final public class DivView : VGSLUI.VisibleBoundsTrackingView {
  @_Concurrency.MainActor @preconcurrency public init(divKitComponents: DivKit.DivKitComponents, divViewPreloader: DivKit.DivViewPreloader? = nil)
  @_Concurrency.MainActor @preconcurrency final public func setSource(_ source: DivKit.DivViewSource, debugParams: DivKit.DebugParams = DebugParams(), shouldResetPreviousCardData: Swift.Bool = false) async
  @_Concurrency.MainActor @preconcurrency final public func showCardId(_ cardId: DivKit.DivCardID, shouldResetPreviousCardData: Swift.Bool = false)
  @_Concurrency.MainActor @preconcurrency final public func setParentScrollView(_ parentScrollView: any UIKit.UIView & VGSLUI.ScrollViewType)
  @_Concurrency.MainActor @preconcurrency final public func applyPatch(_ patch: DivKit.DivPatch, cardId: DivKit.DivCardID)
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override final public func layoutSublayers(of layer: QuartzCore.CALayer)
  @_Concurrency.MainActor @preconcurrency @objc override final public func removeFromSuperview()
  @_Concurrency.MainActor @preconcurrency final public var cardSize: DivKit.DivViewSize? {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public func addObserver(_ onCardSizeChanged: @escaping (DivKit.DivViewSize) -> Swift.Void) -> VGSLFundamentals.Disposable
  @_Concurrency.MainActor @preconcurrency @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency final public func onVisibleBoundsChanged(to: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency final public func onVisibleBoundsChanged(from _: CoreFoundation.CGRect, to: CoreFoundation.CGRect)
  @objc deinit
}
extension DivKit.DivView : LayoutKit.ElementStateObserver {
  @_Concurrency.MainActor @preconcurrency final public func elementStateChanged(_ state: any LayoutKit.ElementState, forPath path: LayoutKitInterface.UIElementPath)
  @_Concurrency.MainActor @preconcurrency final public func focusedElementChanged(isFocused: Swift.Bool, forPath path: LayoutKitInterface.UIElementPath)
  @_Concurrency.MainActor @preconcurrency final public func clearFocus()
}
extension DivKit.DivView : LayoutKit.UIActionEventPerforming {
  @_Concurrency.MainActor @preconcurrency final public func perform(uiActionEvent event: LayoutKit.UIActionEvent, from sender: Swift.AnyObject)
}
extension DivKit.DivView {
  @_Concurrency.MainActor @preconcurrency @objc override final public var accessibilityElements: [Any]? {
    @objc get
    @objc set
  }
}
extension DivKit.DivView : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor @preconcurrency @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@_Concurrency.MainActor final public class DivViewPreloader {
  public struct DivViewSizeChange {
    public let cardId: DivKit.DivCardID
    public let estimatedSize: DivKit.DivViewSize
  }
  @_Concurrency.MainActor public init(divKitComponents: DivKit.DivKitComponents)
  @_Concurrency.MainActor final public func setSource(_ source: DivKit.DivViewSource, debugParams: DivKit.DebugParams = DebugParams()) async
  @_Concurrency.MainActor final public func setSources(_ sources: [DivKit.DivViewSource], debugParams: DivKit.DebugParams = DebugParams()) async
  @_Concurrency.MainActor final public func expectedSize(for cardId: DivKit.DivCardID) -> DivKit.DivViewSize?
  @_Concurrency.MainActor final public func addObserver(_ onCardSizeChanged: @escaping (DivKit.DivViewPreloader.DivViewSizeChange) -> Swift.Void) -> VGSLFundamentals.Disposable
  @objc deinit
}
public struct DivViewSize : Swift.Equatable {
  public enum DivDimension : Swift.Equatable {
    case matchParent
    case desired(CoreFoundation.CGFloat)
    case dependsOnOtherDimensionSize((CoreFoundation.CGFloat) -> CoreFoundation.CGFloat)
    public static func == (lhs: DivKit.DivViewSize.DivDimension, rhs: DivKit.DivViewSize.DivDimension) -> Swift.Bool
  }
  public init(block: any LayoutKit.Block)
  public let width: DivKit.DivViewSize.DivDimension
  public let height: DivKit.DivViewSize.DivDimension
  public func sizeFor(parentViewSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public static func == (a: DivKit.DivViewSize, b: DivKit.DivViewSize) -> Swift.Bool
}
public struct DivViewSource {
  public enum Kind {
    case json([Swift.String : Any])
    case data(Foundation.Data)
    case divData(DivKit.DivData)
  }
  public init(kind: DivKit.DivViewSource.Kind, cardId: DivKit.DivCardID)
}
@frozen public enum DivVisibility : Swift.String, Swift.CaseIterable, Swift.Sendable {
  case visible
  case invisible
  case gone
  public init?(rawValue: Swift.String)
  public typealias AllCases = [DivKit.DivVisibility]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [DivKit.DivVisibility] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DivVisibilityAction : DivKit.DivSightAction, @unchecked Swift.Sendable {
  final public let downloadCallbacks: DivKit.DivDownloadCallbacks?
  final public let isEnabled: DivKit.Expression<Swift.Bool>
  final public let logId: DivKit.Expression<Swift.String>
  final public let logLimit: DivKit.Expression<Swift.Int>
  final public let payload: [Swift.String : Any]?
  final public let referer: DivKit.Expression<Foundation.URL>?
  final public let scopeId: Swift.String?
  final public let typed: DivKit.DivActionTyped?
  final public let url: DivKit.Expression<Foundation.URL>?
  final public let visibilityDuration: DivKit.Expression<Swift.Int>
  final public let visibilityPercentage: DivKit.Expression<Swift.Int>
  final public func resolveIsEnabled(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool
  final public func resolveLogId(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  final public func resolveLogLimit(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveReferer(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveUrl(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  final public func resolveVisibilityDuration(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  final public func resolveVisibilityPercentage(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  @objc deinit
}
extension DivKit.DivVisibilityAction : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivVisibilityActionTemplate : DivKit.TemplateValue, @unchecked Swift.Sendable {
  final public let downloadCallbacks: DivKit.Field<DivKit.DivDownloadCallbacksTemplate>?
  final public let isEnabled: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let logId: DivKit.Field<DivKit.Expression<Swift.String>>?
  final public let logLimit: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let payload: DivKit.Field<[Swift.String : Any]>?
  final public let referer: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let scopeId: DivKit.Field<Swift.String>?
  final public let typed: DivKit.Field<DivKit.DivActionTypedTemplate>?
  final public let url: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  final public let visibilityDuration: DivKit.Field<DivKit.Expression<Swift.Int>>?
  final public let visibilityPercentage: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivVisibilityActionTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivVisibilityAction>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivVisibilityActionTemplate
  public typealias ResolvedValue = DivKit.DivVisibilityAction
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DivWrapContentSize : Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ConstraintSize : Swift.Sendable {
    final public let unit: DivKit.Expression<DivKit.DivSizeUnit>
    final public let value: DivKit.Expression<Swift.Int>
    final public func resolveUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
    final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
    @objc deinit
  }
  public static let type: Swift.String
  final public let constrained: DivKit.Expression<Swift.Bool>?
  final public let maxSize: DivKit.DivWrapContentSize.ConstraintSize?
  final public let minSize: DivKit.DivWrapContentSize.ConstraintSize?
  final public func resolveConstrained(_ resolver: DivKit.ExpressionResolver) -> Swift.Bool?
  @objc deinit
}
extension DivKit.DivWrapContentSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
extension DivKit.DivWrapContentSize.ConstraintSize : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class DivWrapContentSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
  @_hasMissingDesignatedInitializers final public class ConstraintSizeTemplate : DivKit.TemplateValue, Swift.Sendable {
    final public let unit: DivKit.Field<DivKit.Expression<DivKit.DivSizeUnit>>?
    final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
    convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
    public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivWrapContentSizeTemplate.ConstraintSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivWrapContentSize.ConstraintSize>
    final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivWrapContentSizeTemplate.ConstraintSizeTemplate
    public typealias ResolvedValue = DivKit.DivWrapContentSize.ConstraintSize
    @objc deinit
  }
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let constrained: DivKit.Field<DivKit.Expression<Swift.Bool>>?
  final public let maxSize: DivKit.Field<DivKit.DivWrapContentSizeTemplate.ConstraintSizeTemplate>?
  final public let minSize: DivKit.Field<DivKit.DivWrapContentSizeTemplate.ConstraintSizeTemplate>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.DivWrapContentSizeTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.DivWrapContentSize>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.DivWrapContentSizeTemplate
  public typealias ResolvedValue = DivKit.DivWrapContentSize
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class EndDestination : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.EndDestination : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class EndDestinationTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.EndDestinationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.EndDestination>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.EndDestinationTemplate
  public typealias ResolvedValue = DivKit.EndDestination
  @objc deinit
}
@frozen public enum Expression<T> : Swift.Sendable where T : Swift.Sendable {
  case value(T)
  case link(DivKit.ExpressionLink<T>)
}
extension DivKit.Expression : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: DivKit.Expression<T>, rhs: DivKit.Expression<T>) -> Swift.Bool
}
@inlinable internal func expressionTransform<T, U>(_ value: Any?, transform: (U) -> T?, validator: Serialization.AnyValueValidator<T>? = nil) -> DivKit.Expression<T>? where T : Swift.Sendable {
  guard let value else {
    return nil
  }

  if let rawValue = value as? String {
    if let link = ExpressionLink<T>(
      rawValue: rawValue,
      validator: validator,
      errorTracker: { DivKitLogger.error($0.description) }
    ) {
      return .link(link)
    }
  }

  guard let castedValue: U = cast(value) else {
    DivKitLogger.error("Failed to cast value: \(value)")
    return nil
  }

  if let transformedValue = transform(castedValue), validator?.isValid(transformedValue) != false {
    return .value(transformedValue)
  }

  return nil
}
@inlinable internal func cast<T>(_ value: Any) -> T? {
  if let castedValue = value as? T {
    return castedValue
  }

  if T.self == Int.self, let doubleValue = value as? Double {
    return Int(doubleValue) as? T
  }

  return nil
}
@inlinable internal func deserialize<T>(_ value: Any, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<DivKit.Expression<T>> where T : Serialization.ValidSerializationValue, T : Swift.Sendable {
  deserialize(value, transform: { $0 }, validator: validator)
}
@inlinable internal func deserialize<T, U>(_ value: Any, transform: (T) -> U?, validator: Serialization.AnyValueValidator<U>? = nil) -> Serialization.DeserializationResult<DivKit.Expression<U>> where T : Serialization.ValidSerializationValue, U : Swift.Sendable {
  guard let result: Expression<U> = expressionTransform(
    value,
    transform: transform,
    validator: validator
  ) else {
    return .failure(NonEmptyArray(.typeMismatch(
      expected: "Expression<\(U.self)>",
      representation: value
    )))
  }

  return .success(result)
}
@inlinable internal func deserialize<T, U>(_ value: Any, transform: (T) -> U?, validator: Serialization.AnyArrayValueValidator<DivKit.Expression<U>>? = nil) -> Serialization.DeserializationResult<[DivKit.Expression<U>]> where T : Serialization.ValidSerializationValue, U : Swift.Sendable {
  deserialize(
    value,
    transform: { (rawElement: T) -> DeserializationResult<Expression<U>> in
      deserialize(rawElement, transform: transform)
    },
    validator: validator
  )
}
@inlinable internal func deserialize<T>(_ value: Any, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<DivKit.Expression<T>> where T : Swift.RawRepresentable, T : Swift.Sendable, T.RawValue == Swift.String {
  guard let result: Expression<T> = expressionTransform(
    value,
    transform: T.init(rawValue:),
    validator: validator
  ) else {
    return .failure(NonEmptyArray(.typeMismatch(
      expected: "Expression<\(T.self)>",
      representation: value
    )))
  }

  if case let .value(value) = result, validator?.isValid(value) == false {
    return .failure(NonEmptyArray(.invalidValue(result: result, value: value)))
  }

  return .success(result)
}
public struct ExpressionError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  public let description: Swift.String
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ExpressionLink<T> : Swift.Sendable where T : Swift.Sendable {
  @usableFromInline
  internal init?(rawValue: Swift.String, validator: Serialization.AnyValueValidator<T>? = nil, errorTracker: DivKit.ExpressionErrorTracker? = nil, resolveNested: Swift.Bool = true)
}
extension DivKit.ExpressionLink : Swift.Equatable {
  public static func == (lhs: DivKit.ExpressionLink<T>, rhs: DivKit.ExpressionLink<T>) -> Swift.Bool
}
public typealias ExpressionErrorTracker = (DivKit.ExpressionError) -> Swift.Void
@_hasMissingDesignatedInitializers final public class ExpressionResolver {
  final public func resolve(_ expression: Swift.String) -> Any?
  final public func resolveString(_ expression: Swift.String) -> Swift.String?
  final public func resolveColor(_ expression: Swift.String) -> VGSLUI.Color?
  final public func resolveUrl(_ expression: Swift.String) -> Foundation.URL?
  final public func resolveEnum<T>(_ expression: Swift.String) -> T? where T : Swift.RawRepresentable, T.RawValue == Swift.String
  final public func resolveNumeric<T>(_ expression: Swift.String) -> T?
  @objc deinit
}
@frozen indirect public enum Field<T> : Swift.Sendable where T : Swift.Sendable {
  case value(T)
  case link(Swift.String)
}
extension DivKit.Field {
  @usableFromInline
  internal func resolveValue(validator: Serialization.AnyValueValidator<T>? = nil, valueForLink: (Swift.String) -> Serialization.DeserializationResult<T>) -> Serialization.DeserializationResult<T>
  @inlinable internal func value(validatedBy validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> {
    resolveValue(
      validator: validator,
      valueForLink: { _ in .noValue }
    )
  }
  @inlinable internal func resolveValue<U>(context: DivKit.TemplatesContext, transform: (U) -> T?, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> where U : Serialization.ValidSerializationValue {
    resolveValue(
      validator: validator,
      valueForLink: { link in
        safeValueForLink {
          try context.templateData.getField(link, transform: transform, validator: validator)
        }
      }
    )
  }
  @inlinable internal func resolveOptionalValue<U>(context: DivKit.TemplatesContext, transform: (U) -> T?) -> Serialization.DeserializationResult<T> where U : Serialization.ValidSerializationValue {
    resolveValue(
      valueForLink: { link in
        let result = safeValueForLink {
          try context.templateData.getField(link, transform: transform)
        }
        if case let .failure(errors) = result {
          if errors.count == 1, case .noData = errors.first {
            return .noValue
          }
        }
        return result
      }
    )
  }
  @inlinable internal func resolveOptionalValue<U>(context: DivKit.TemplatesContext, transform: (U) -> T?, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> where U : Serialization.ValidSerializationValue {
    let result = resolveOptionalValue(context: context, transform: transform)
    if case .noValue = result {
      return .noValue
    }
    guard let resultValue = result.value, validator?.isValid(resultValue) != false else {
      if let resultErrors = result.errorsOrWarnings {
        return .failure(NonEmptyArray(.composite(
          error: .invalidValue(result: result.value, from: nil),
          causes: resultErrors
        )))
      }
      return .failure(NonEmptyArray(.invalidValue(result: result.value, value: nil)))
    }
    return result
  }
}
extension DivKit.Field where T : Serialization.ValidSerializationValue {
  @inlinable internal func resolveValue(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> {
    resolveValue(context: context, transform: { $0 as T }, validator: validator)
  }
  @inlinable internal func resolveOptionalValue(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> {
    resolveOptionalValue(context: context, transform: { $0 as T }, validator: validator)
  }
}
extension DivKit.Field where T : Swift.RawRepresentable, T.RawValue : Serialization.ValidSerializationValue {
  @inlinable internal func resolveValue(context: DivKit.TemplatesContext) -> Serialization.DeserializationResult<T> {
    resolveValue(context: context, transform: T.init(rawValue:))
  }
  @inlinable internal func resolveOptionalValue(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<T>? = nil) -> Serialization.DeserializationResult<T> {
    resolveOptionalValue(context: context, transform: T.init(rawValue:), validator: validator)
  }
}
extension DivKit.Field {
  @inlinable internal func resolveParent<U>(templates: [DivKit.TemplateName : Any]) throws -> DivKit.Field<[U]> where T == [U], U : DivKit.TemplateValue, U : Swift.Sendable {
    switch self {
    case .link:
      return self
    case let .value(value):
      var result: [U] = []
      result.reserveCapacity(value.count)
      for index in value.indices {
        try? result.append(value[index].resolveParent(templates: templates))
      }
      return .value(result)
    }
  }
  @inlinable internal func tryResolveParent<U>(templates: [DivKit.TemplateName : Any]) -> DivKit.Field<[U]>? where T == [U], U : DivKit.TemplateValue, U : Swift.Sendable {
    try? resolveParent(templates: templates)
  }
}
extension DivKit.Field where T : DivKit.TemplateValue {
  @usableFromInline
  internal typealias ResolvedValue = T.ResolvedValue
  @inlinable internal func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.Field<T> {
    switch self {
    case let .link(link):
      .link(link)
    case let .value(value):
      try .value(value.resolveParent(templates: templates))
    }
  }
  @inlinable internal func resolveValue(context: DivKit.TemplatesContext, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.Field<T>.ResolvedValue> {
    switch self {
    case let .link(link):
      let valueDictResult: DeserializationResult<[String: Any]> = safeValueForLink {
        try context.templateData.getField(link)
      }
      guard let valueDict = valueDictResult.value else {
        if let errorsOrWarnings = valueDictResult.errorsOrWarnings {
          return .failure(errorsOrWarnings)
        }
        return .noValue
      }
      return T.resolveValue(
        context: modified(context) { $0.templateData = valueDict },
        useOnlyLinks: false
      )
    case let .value(value):
      return value.resolveValue(context: context, useOnlyLinks: useOnlyLinks)
    }
  }
  @inlinable internal func tryResolveParent(templates: [DivKit.TemplateName : Any]) -> DivKit.Field<T>? {
    switch self {
    case .link:
      self
    case let .value(value):
      value.tryResolveParent(templates: templates).map(Field.value)
    }
  }
  @inlinable internal func resolveOptionalValue(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<T.ResolvedValue>? = nil, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<T.ResolvedValue> {
    let result = resolveValue(context: context, useOnlyLinks: useOnlyLinks)
    guard let value = result.value else {
      return .noValue
    }
    guard validator?.isValid(value) != false else {
      return .failure(NonEmptyArray(.invalidValue(result: result.value, value: nil)))
    }
    return result
  }
}
extension DivKit.Field {
  @inlinable internal func resolveValue<U>(context: DivKit.TemplatesContext, validator: Serialization.AnyArrayValueValidator<U.ResolvedValue>? = nil, useOnlyLinks _: Swift.Bool) -> Serialization.DeserializationResult<Swift.Array<U>.ResolvedValue> where T == [U], U : DivKit.TemplateValue, U : Swift.Sendable, U.ResolvedValue : Swift.Sendable {
    switch self {
    case let .value(value):
      value
        .resolveParent(templates: context.templates)
        .resolveValue(context: context, validator: validator)
    case let .link(link):
      context.getArray(link, validator: validator, type: T.Element.self)
    }
  }
  @inlinable internal func resolveOptionalValue<U>(context: DivKit.TemplatesContext, validator: Serialization.AnyArrayValueValidator<U.ResolvedValue>? = nil, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<Swift.Array<U>.ResolvedValue> where T == [U], U : DivKit.TemplateValue, U : Swift.Sendable, U.ResolvedValue : Swift.Sendable {
    let result = resolveValue(context: context, validator: validator, useOnlyLinks: useOnlyLinks)
    if case let .failure(errors) = result, errors.count == 1, case .noData = errors.first {
      return .noValue
    }
    return result
  }
}
@inlinable internal func safeValueForLink<T>(_ valueForLink: () throws -> T) -> Serialization.DeserializationResult<T> {
  do {
    return try .success(valueForLink())
  } catch let error as DeserializationError {
    return .failure(NonEmptyArray(error))
  } catch {
    assertionFailure("Closure should throw only DeserializationError")
    return .failure(NonEmptyArray(.unexpectedError(message: error.localizedDescription)))
  }
}
extension DivKit.Field {
  @inlinable internal func resolveValue<E>(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, E : Serialization.ValidSerializationValue, E : Swift.Sendable {
    resolveValue(
      context: context,
      transform: { $0 as E },
      validator: validator
    )
  }
  @inlinable internal func resolveValue<E>(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, E : Swift.RawRepresentable, E : Swift.Sendable, E.RawValue == Swift.String {
    switch self {
    case let .value(value):
      .success(value)
    case let .link(link):
      safeValueForLink {
        try context.templateData.getField(
          link,
          transform: {
            expressionTransform($0, transform: E.init(rawValue:), validator: validator)
          }
        )
      }
    }
  }
  @inlinable internal func resolveValue<U, E>(context: DivKit.TemplatesContext, transform: (U) -> E?, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, U : Serialization.ValidSerializationValue, E : Swift.Sendable {
    switch self {
    case let .value(value):
      .success(value)
    case let .link(link):
      safeValueForLink {
        try context.templateData.getField(
          link,
          transform: { expressionTransform($0, transform: transform, validator: validator) }
        )
      }
    }
  }
  @inlinable internal func resolveValue<U, E>(context: DivKit.TemplatesContext, transform: (U) -> E?, validator: Serialization.AnyArrayValueValidator<DivKit.Expression<E>>) -> Serialization.DeserializationResult<T> where T == [DivKit.Expression<E>], U : Serialization.ValidSerializationValue, E : Swift.Sendable {
    switch self {
    case let .value(value):
      guard validator.isValid(value) != false else {
        return .failure(NonEmptyArray(.invalidValue(result: value, value: nil)))
      }
      return .success(value)
    case let .link(link):
      return context.templateData.getArray(
        link,
        transform: { (value: U) in
          expressionTransform(value, transform: transform)
        },
        validator: validator
      )
    }
  }
  @inlinable internal func resolveOptionalValue<E>(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, E : Serialization.ValidSerializationValue, E : Swift.Sendable {
    resolveOptionalValue(
      context: context,
      transform: { $0 as E },
      validator: validator
    )
  }
  @inlinable internal func resolveOptionalValue<E>(context: DivKit.TemplatesContext, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, E : Swift.RawRepresentable, E : Swift.Sendable, E.RawValue == Swift.String {
    let result = resolveValue(
      context: context,
      validator: validator
    )
    if case let .failure(errors) = result,
       errors.count == 1,
       case .noData = errors.first {
      return .noValue
    }
    return result
  }
  @inlinable internal func resolveOptionalValue<U, E>(context: DivKit.TemplatesContext, transform: (U) -> E?, validator: Serialization.AnyValueValidator<E>? = nil) -> Serialization.DeserializationResult<T> where T == DivKit.Expression<E>, U : Serialization.ValidSerializationValue, E : Swift.Sendable {
    let result = resolveValue(
      context: context,
      transform: transform,
      validator: validator
    )
    if case let .failure(errors) = result,
       errors.count == 1,
       case .noData = errors.first {
      return .noValue
    }
    return result
  }
  @inlinable internal func resolveOptionalValue<U, E>(context: DivKit.TemplatesContext, transform: (U) -> E?, validator: Serialization.AnyArrayValueValidator<DivKit.Expression<E>>) -> Serialization.DeserializationResult<T> where T == [DivKit.Expression<E>], U : Serialization.ValidSerializationValue, E : Swift.Sendable {
    let result = resolveValue(
      context: context,
      transform: transform,
      validator: validator
    )
    if case let .failure(errors) = result,
       errors.count == 1,
       case .noData = errors.first {
      return .noValue
    }
    return result
  }
}
public struct FontParams : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DivKit.FontParams, b: DivKit.FontParams) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FontParamsProvider {
  func resolveFontFamily(_ expressionResolver: DivKit.ExpressionResolver) -> Swift.String?
  func resolveFontWeight(_ expressionResolver: DivKit.ExpressionResolver) -> DivKit.DivFontWeight
  func resolveFontWeightValue(_ expressionResolver: DivKit.ExpressionResolver) -> Swift.Int?
  func resolveFontSize(_ resolver: DivKit.ExpressionResolver) -> Swift.Int
  func resolveFontSizeUnit(_ resolver: DivKit.ExpressionResolver) -> DivKit.DivSizeUnit
  func resolveFontFeatureSettings(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  func resolveFontVariationSettings(_ resolver: DivKit.ExpressionResolver) -> [Swift.String : Any]?
}
extension DivKit.FontParamsProvider {
  public func resolveFontParams(_ expressionResolver: DivKit.ExpressionResolver) -> DivKit.FontParams
  public func resolveFontFeatureSettings(_: DivKit.ExpressionResolver) -> Swift.String?
  public func resolveFontVariationSettings(_: DivKit.ExpressionResolver) -> [Swift.String : Any]?
}
extension DivKit.DivBlockModelingContext {
  public func font(_ params: DivKit.FontParams) -> VGSLUI.Font
}
@_hasMissingDesignatedInitializers final public class IndexDestination : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.IndexDestination : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class IndexDestinationTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.IndexDestinationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.IndexDestination>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.IndexDestinationTemplate
  public typealias ResolvedValue = DivKit.IndexDestination
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class IntegerValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.IntegerValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class IntegerValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.IntegerValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.IntegerValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.IntegerValueTemplate
  public typealias ResolvedValue = DivKit.IntegerValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class IntegerVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.IntegerVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class IntegerVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.IntegerVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.IntegerVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.IntegerVariableTemplate
  public typealias ResolvedValue = DivKit.IntegerVariable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NumberValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.NumberValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class NumberValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.NumberValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.NumberValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.NumberValueTemplate
  public typealias ResolvedValue = DivKit.NumberValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NumberVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<Swift.Double>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Double?
  @objc deinit
}
extension DivKit.NumberVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class NumberVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Double>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.NumberVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.NumberVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.NumberVariableTemplate
  public typealias ResolvedValue = DivKit.NumberVariable
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class OffsetDestination : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.Int>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.Int?
  @objc deinit
}
extension DivKit.OffsetDestination : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class OffsetDestinationTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.Int>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.OffsetDestinationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.OffsetDestination>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.OffsetDestinationTemplate
  public typealias ResolvedValue = DivKit.OffsetDestination
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PhoneMasks : @unchecked Swift.Sendable {
  public static let extraNumbers: Swift.String
  final public let value: [Swift.String : Any]
  public static let VALUE_DEFAULT: ([Swift.String : Any])
  @objc deinit
}
public struct RawDivData : Serialization.Deserializable, @unchecked Swift.Sendable {
  public let card: [Swift.String : Any]
  public let templates: [Swift.String : Any]
  public init(dictionary: [Swift.String : Any]) throws
  public func resolve() -> Serialization.DeserializationResult<DivKit.DivData>
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  @inlinable internal func link(for key: Swift.String) -> Swift.String? {
    self["$" + key] as? String
  }
  @inlinable internal func getOptionalField<T, U>(_ key: Swift.String, transform: (U) -> T?) -> DivKit.Field<T>? where T : Swift.Sendable {
    if let value: T = try? getOptionalField(key, transform: transform) {
      return .value(value)
    }
    if let link = link(for: key) {
      return .link(link)
    }
    return nil
  }
  @inlinable internal func getOptionalField<T>(_ key: Swift.String) -> DivKit.Field<T>? where T : Swift.RawRepresentable, T : Swift.Sendable {
    getOptionalField(key, transform: T.init(rawValue:))
  }
  @inlinable internal func getOptionalField<T>(_ key: Swift.String) -> DivKit.Field<T>? where T : Serialization.ValidSerializationValue, T : Swift.Sendable {
    getOptionalField(key, transform: { $0 as T })
  }
  @inlinable internal func getOptionalField<T>(_ key: Swift.String, templateToType: [DivKit.TemplateName : Swift.String]) -> DivKit.Field<T>? where T : DivKit.TemplateValue, T : Swift.Sendable {
    getOptionalField(
      key,
      transform: { (dict: Self) in try? T(dictionary: dict, templateToType: templateToType) }
    )
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  @inlinable internal func getOptionalArray<T, U>(_ key: Swift.String, transform: (U) throws -> T, validator: Serialization.AnyArrayValueValidator<T>? = nil) -> DivKit.Field<[T]>? where T : Swift.Sendable {
    if let value: [T] = try? getOptionalArray(
      key,
      transform: transform,
      validator: validator
    ) {
      return .value(value)
    }
    return link(for: key).map { .link($0) }
  }
  @inlinable internal func getOptionalArray<T, U>(_ key: Swift.String, transform: (U) -> T?, validator: Serialization.AnyArrayValueValidator<T>? = nil) -> DivKit.Field<[T]>? where T : Swift.Sendable {
    getOptionalArray(
      key,
      transform: { (value: U) throws -> T in
        guard let result = transform(value) else {
          throw DeserializationError.generic
        }
        return result
      },
      validator: validator
    )
  }
  @inlinable internal func getOptionalArray<T>(_ key: Swift.String) -> DivKit.Field<[T]>? where T : Swift.RawRepresentable, T : Swift.Sendable {
    getOptionalArray(key, transform: T.init(rawValue:))
  }
  @inlinable internal func getOptionalArray<T>(_ key: Swift.String, templateToType: [DivKit.TemplateName : Swift.String]) -> DivKit.Field<[T]>? where T : DivKit.TemplateValue, T : Swift.Sendable {
    getOptionalArray(
      key,
      transform: { (dict: Self) in try? T(dictionary: dict, templateToType: templateToType) }
    )
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  @inlinable internal func getField<T>(_ key: Swift.String, templateToType: [DivKit.TemplateName : Swift.String]) throws -> T where T : DivKit.TemplateValue {
    try getField(
      key,
      transform: { (dict: Self) in try T(dictionary: dict, templateToType: templateToType) }
    )
  }
}
extension DivKit.TemplatesContext {
  @inlinable internal func getArray<T>(_ key: Swift.String, validator: Serialization.AnyArrayValueValidator<T.ResolvedValue>? = nil, type: T.Type) -> Serialization.DeserializationResult<[T.ResolvedValue]> where T : DivKit.TemplateValue, T.ResolvedValue : Swift.Sendable {
    templateData.getArray(
      key,
      transform: makeTemplateDeserializer(
        templates: templates,
        templateToType: templateToType,
        type: type
      ),
      validator: validator
    )
  }
}
@inlinable internal func deserialize<T>(_ value: Any, templates: [DivKit.TemplateName : Any], templateToType: [DivKit.TemplateName : Swift.String], type: T.Type) -> Serialization.DeserializationResult<T.ResolvedValue> where T : DivKit.TemplateValue {
  deserialize(
    value,
    transform: makeTemplateDeserializer(
      templates: templates,
      templateToType: templateToType,
      type: type
    )
  )
}
@inlinable internal func deserialize<T>(_ value: Any, templates: [DivKit.TemplateName : Any], templateToType: [DivKit.TemplateName : Swift.String], validator: Serialization.AnyArrayValueValidator<T.ResolvedValue>? = nil, type: T.Type) -> Serialization.DeserializationResult<[T.ResolvedValue]> where T : DivKit.TemplateValue, T.ResolvedValue : Swift.Sendable {
  deserialize(
    value,
    transform: makeTemplateDeserializer(
      templates: templates,
      templateToType: templateToType,
      type: type
    ),
    validator: validator
  )
}
@usableFromInline
internal func makeTemplateDeserializer<T>(templates: [DivKit.TemplateName : Any], templateToType: [DivKit.TemplateName : Swift.String], type _: T.Type) -> (([Swift.String : Any]) -> Serialization.DeserializationResult<T.ResolvedValue>) where T : DivKit.TemplateValue
@_hasMissingDesignatedInitializers final public class StartDestination : Swift.Sendable {
  public static let type: Swift.String
  @objc deinit
}
extension DivKit.StartDestination : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class StartDestinationTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.StartDestinationTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.StartDestination>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.StartDestinationTemplate
  public typealias ResolvedValue = DivKit.StartDestination
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StringValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Swift.String>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.StringValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class StringValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.StringValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.StringValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.StringValueTemplate
  public typealias ResolvedValue = DivKit.StringValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StringVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<Swift.String>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Swift.String?
  @objc deinit
}
extension DivKit.StringVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class StringVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<Swift.String>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.StringVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.StringVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.StringVariableTemplate
  public typealias ResolvedValue = DivKit.StringVariable
  @objc deinit
}
public struct SubmitRequest : Swift.Equatable {
  public let url: Foundation.URL
  public let method: Swift.String
  public let headers: [Swift.String : Swift.String]
  public static func == (a: DivKit.SubmitRequest, b: DivKit.SubmitRequest) -> Swift.Bool
}
public protocol TemplateValue {
  associatedtype ResolvedValue
  init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> Self
  static func resolveValue(context: DivKit.TemplatesContext, parent: Self?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<Self.ResolvedValue>
}
extension DivKit.TemplateValue {
  @usableFromInline
  internal func tryResolveParent(templates: [DivKit.TemplateName : Any]) -> Self?
  @usableFromInline
  internal func resolveValue(context: DivKit.TemplatesContext, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<Self.ResolvedValue>
  @usableFromInline
  internal static func resolveValue(context: DivKit.TemplatesContext, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<Self.ResolvedValue>
}
extension Swift.Array where Element : DivKit.TemplateValue {
  @usableFromInline
  internal typealias ResolvedValue = [Element.ResolvedValue]
  @usableFromInline
  internal func resolveParent(templates: [DivKit.TemplateName : Any]) -> [Element]
  @usableFromInline
  internal func resolveValue(context: DivKit.TemplatesContext, validator: Serialization.AnyArrayValueValidator<Element.ResolvedValue>?) -> Serialization.DeserializationResult<[Element.ResolvedValue]>
}
@_hasMissingDesignatedInitializers final public class TimeMeasure : @unchecked Swift.Sendable {
  public struct Time {
    public var value: Swift.Int
    public var status: DivKit.TimeMeasure.Status
    public var description: Swift.String {
      get
    }
  }
  public enum Status : Swift.String {
    case cold
    case warm
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public var time: DivKit.TimeMeasure.Time? {
    get
  }
  final public func updateMeasure<T>(action: () throws -> T) throws -> T
  @objc deinit
}
public typealias DivArray = [Swift.AnyHashable]
public typealias DivDictionary = [Swift.String : Swift.AnyHashable]
@_hasMissingDesignatedInitializers final public class UrlValue : Swift.Sendable {
  public static let type: Swift.String
  final public let value: DivKit.Expression<Foundation.URL>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.UrlValue : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class UrlValueTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let value: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.UrlValueTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.UrlValue>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.UrlValueTemplate
  public typealias ResolvedValue = DivKit.UrlValue
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class UrlVariable : Swift.Sendable {
  public static let type: Swift.String
  final public let name: Swift.String
  final public let value: DivKit.Expression<Foundation.URL>
  final public func resolveValue(_ resolver: DivKit.ExpressionResolver) -> Foundation.URL?
  @objc deinit
}
extension DivKit.UrlVariable : Serialization.Serializable {
  final public func toDictionary() -> [Swift.String : any Serialization.ValidSerializationValue]
}
@_hasMissingDesignatedInitializers final public class UrlVariableTemplate : DivKit.TemplateValue, Swift.Sendable {
  public static let type: Swift.String
  final public let parent: Swift.String?
  final public let name: DivKit.Field<Swift.String>?
  final public let value: DivKit.Field<DivKit.Expression<Foundation.URL>>?
  convenience public init(dictionary: [Swift.String : Any], templateToType: [DivKit.TemplateName : Swift.String]) throws
  public static func resolveValue(context: DivKit.TemplatesContext, parent: DivKit.UrlVariableTemplate?, useOnlyLinks: Swift.Bool) -> Serialization.DeserializationResult<DivKit.UrlVariable>
  final public func resolveParent(templates: [DivKit.TemplateName : Any]) throws -> DivKit.UrlVariableTemplate
  public typealias ResolvedValue = DivKit.UrlVariable
  @objc deinit
}
extension DivKit.DivFontWeight : Swift.Equatable {}
extension DivKit.DivFontWeight : Swift.Hashable {}
extension DivKit.DivFontWeight : Swift.RawRepresentable {}
extension DivKit.DivFontWeight : Swift.BitwiseCopyable {}
extension DivKit.DivAccessibility.Kind : Swift.Equatable {}
extension DivKit.DivAccessibility.Kind : Swift.Hashable {}
extension DivKit.DivAccessibility.Kind : Swift.RawRepresentable {}
extension DivKit.DivAccessibility.Kind : Swift.BitwiseCopyable {}
extension DivKit.DivAccessibility.Mode : Swift.Equatable {}
extension DivKit.DivAccessibility.Mode : Swift.Hashable {}
extension DivKit.DivAccessibility.Mode : Swift.RawRepresentable {}
extension DivKit.DivAccessibility.Mode : Swift.BitwiseCopyable {}
extension DivKit.DivActionScrollBy.Overflow : Swift.Equatable {}
extension DivKit.DivActionScrollBy.Overflow : Swift.Hashable {}
extension DivKit.DivActionScrollBy.Overflow : Swift.RawRepresentable {}
extension DivKit.DivActionScrollBy.Overflow : Swift.BitwiseCopyable {}
extension DivKit.DivActionSubmit.Request.Method : Swift.Equatable {}
extension DivKit.DivActionSubmit.Request.Method : Swift.Hashable {}
extension DivKit.DivActionSubmit.Request.Method : Swift.RawRepresentable {}
extension DivKit.DivActionSubmit.Request.Method : Swift.BitwiseCopyable {}
extension DivKit.DivActionTimer.Action : Swift.Equatable {}
extension DivKit.DivActionTimer.Action : Swift.Hashable {}
extension DivKit.DivActionTimer.Action : Swift.RawRepresentable {}
extension DivKit.DivActionTimer.Action : Swift.BitwiseCopyable {}
extension DivKit.DivActionURLHandler.UpdateReason : Swift.Sendable {}
extension DivKit.DivActionVideo.Action : Swift.Equatable {}
extension DivKit.DivActionVideo.Action : Swift.Hashable {}
extension DivKit.DivActionVideo.Action : Swift.RawRepresentable {}
extension DivKit.DivActionVideo.Action : Swift.BitwiseCopyable {}
extension DivKit.DivAlignmentHorizontal : Swift.Equatable {}
extension DivKit.DivAlignmentHorizontal : Swift.Hashable {}
extension DivKit.DivAlignmentHorizontal : Swift.RawRepresentable {}
extension DivKit.DivAlignmentHorizontal : Swift.BitwiseCopyable {}
extension DivKit.DivAlignmentVertical : Swift.Equatable {}
extension DivKit.DivAlignmentVertical : Swift.Hashable {}
extension DivKit.DivAlignmentVertical : Swift.RawRepresentable {}
extension DivKit.DivAlignmentVertical : Swift.BitwiseCopyable {}
extension DivKit.DivAnimation.Name : Swift.Equatable {}
extension DivKit.DivAnimation.Name : Swift.Hashable {}
extension DivKit.DivAnimation.Name : Swift.RawRepresentable {}
extension DivKit.DivAnimation.Name : Swift.BitwiseCopyable {}
extension DivKit.DivAnimationInterpolator : Swift.Equatable {}
extension DivKit.DivAnimationInterpolator : Swift.Hashable {}
extension DivKit.DivAnimationInterpolator : Swift.RawRepresentable {}
extension DivKit.DivAnimationInterpolator : Swift.BitwiseCopyable {}
extension DivKit.DivAnimationDirection : Swift.Equatable {}
extension DivKit.DivAnimationDirection : Swift.Hashable {}
extension DivKit.DivAnimationDirection : Swift.RawRepresentable {}
extension DivKit.DivAnimationDirection : Swift.BitwiseCopyable {}
extension DivKit.DivBlendMode : Swift.Equatable {}
extension DivKit.DivBlendMode : Swift.Hashable {}
extension DivKit.DivBlendMode : Swift.RawRepresentable {}
extension DivKit.DivBlendMode : Swift.BitwiseCopyable {}
extension DivKit.DivContainer.LayoutMode : Swift.Equatable {}
extension DivKit.DivContainer.LayoutMode : Swift.Hashable {}
extension DivKit.DivContainer.LayoutMode : Swift.RawRepresentable {}
extension DivKit.DivContainer.LayoutMode : Swift.BitwiseCopyable {}
extension DivKit.DivContainer.Orientation : Swift.Equatable {}
extension DivKit.DivContainer.Orientation : Swift.Hashable {}
extension DivKit.DivContainer.Orientation : Swift.RawRepresentable {}
extension DivKit.DivContainer.Orientation : Swift.BitwiseCopyable {}
extension DivKit.DivContentAlignmentHorizontal : Swift.Equatable {}
extension DivKit.DivContentAlignmentHorizontal : Swift.Hashable {}
extension DivKit.DivContentAlignmentHorizontal : Swift.RawRepresentable {}
extension DivKit.DivContentAlignmentHorizontal : Swift.BitwiseCopyable {}
extension DivKit.DivContentAlignmentVertical : Swift.Equatable {}
extension DivKit.DivContentAlignmentVertical : Swift.Hashable {}
extension DivKit.DivContentAlignmentVertical : Swift.RawRepresentable {}
extension DivKit.DivContentAlignmentVertical : Swift.BitwiseCopyable {}
extension DivKit.ResourcePreloadFilter : Swift.Equatable {}
extension DivKit.ResourcePreloadFilter : Swift.Hashable {}
extension DivKit.DivDisappearAction : DivKit.DivActionBase {}
extension DivKit.DivErrorKind : Swift.Equatable {}
extension DivKit.DivErrorKind : Swift.Hashable {}
extension DivKit.DivErrorKind : Swift.RawRepresentable {}
extension DivKit.DivErrorLevel : Swift.Equatable {}
extension DivKit.DivErrorLevel : Swift.Hashable {}
extension DivKit.DivEvaluableType : Swift.Equatable {}
extension DivKit.DivEvaluableType : Swift.Hashable {}
extension DivKit.DivEvaluableType : Swift.RawRepresentable {}
extension DivKit.DivEvaluableType : Swift.BitwiseCopyable {}
extension DivKit.DivGallery.CrossContentAlignment : Swift.Equatable {}
extension DivKit.DivGallery.CrossContentAlignment : Swift.Hashable {}
extension DivKit.DivGallery.CrossContentAlignment : Swift.RawRepresentable {}
extension DivKit.DivGallery.CrossContentAlignment : Swift.BitwiseCopyable {}
extension DivKit.DivGallery.Orientation : Swift.Equatable {}
extension DivKit.DivGallery.Orientation : Swift.Hashable {}
extension DivKit.DivGallery.Orientation : Swift.RawRepresentable {}
extension DivKit.DivGallery.Orientation : Swift.BitwiseCopyable {}
extension DivKit.DivGallery.ScrollMode : Swift.Equatable {}
extension DivKit.DivGallery.ScrollMode : Swift.Hashable {}
extension DivKit.DivGallery.ScrollMode : Swift.RawRepresentable {}
extension DivKit.DivGallery.ScrollMode : Swift.BitwiseCopyable {}
extension DivKit.DivGallery.Scrollbar : Swift.Equatable {}
extension DivKit.DivGallery.Scrollbar : Swift.Hashable {}
extension DivKit.DivGallery.Scrollbar : Swift.RawRepresentable {}
extension DivKit.DivGallery.Scrollbar : Swift.BitwiseCopyable {}
extension DivKit.DivHostingView : Swift.Sendable {}
extension DivKit.DivImageScale : Swift.Equatable {}
extension DivKit.DivImageScale : Swift.Hashable {}
extension DivKit.DivImageScale : Swift.RawRepresentable {}
extension DivKit.DivImageScale : Swift.BitwiseCopyable {}
extension DivKit.DivIndicator.Animation : Swift.Equatable {}
extension DivKit.DivIndicator.Animation : Swift.Hashable {}
extension DivKit.DivIndicator.Animation : Swift.RawRepresentable {}
extension DivKit.DivIndicator.Animation : Swift.BitwiseCopyable {}
extension DivKit.DivInput.Autocapitalization : Swift.Equatable {}
extension DivKit.DivInput.Autocapitalization : Swift.Hashable {}
extension DivKit.DivInput.Autocapitalization : Swift.RawRepresentable {}
extension DivKit.DivInput.Autocapitalization : Swift.BitwiseCopyable {}
extension DivKit.DivInput.EnterKeyType : Swift.Equatable {}
extension DivKit.DivInput.EnterKeyType : Swift.Hashable {}
extension DivKit.DivInput.EnterKeyType : Swift.RawRepresentable {}
extension DivKit.DivInput.EnterKeyType : Swift.BitwiseCopyable {}
extension DivKit.DivInput.KeyboardType : Swift.Equatable {}
extension DivKit.DivInput.KeyboardType : Swift.Hashable {}
extension DivKit.DivInput.KeyboardType : Swift.RawRepresentable {}
extension DivKit.DivInput.KeyboardType : Swift.BitwiseCopyable {}
extension DivKit.DivLineStyle : Swift.Equatable {}
extension DivKit.DivLineStyle : Swift.Hashable {}
extension DivKit.DivLineStyle : Swift.RawRepresentable {}
extension DivKit.DivLineStyle : Swift.BitwiseCopyable {}
extension DivKit.DivPager.ItemAlignment : Swift.Equatable {}
extension DivKit.DivPager.ItemAlignment : Swift.Hashable {}
extension DivKit.DivPager.ItemAlignment : Swift.RawRepresentable {}
extension DivKit.DivPager.ItemAlignment : Swift.BitwiseCopyable {}
extension DivKit.DivPager.Orientation : Swift.Equatable {}
extension DivKit.DivPager.Orientation : Swift.Hashable {}
extension DivKit.DivPager.Orientation : Swift.RawRepresentable {}
extension DivKit.DivPager.Orientation : Swift.BitwiseCopyable {}
extension DivKit.DivPatch.Mode : Swift.Equatable {}
extension DivKit.DivPatch.Mode : Swift.Hashable {}
extension DivKit.DivPatch.Mode : Swift.RawRepresentable {}
extension DivKit.DivPatch.Mode : Swift.BitwiseCopyable {}
extension DivKit.DivRadialGradientRelativeRadius.Value : Swift.Equatable {}
extension DivKit.DivRadialGradientRelativeRadius.Value : Swift.Hashable {}
extension DivKit.DivRadialGradientRelativeRadius.Value : Swift.RawRepresentable {}
extension DivKit.DivRadialGradientRelativeRadius.Value : Swift.BitwiseCopyable {}
extension DivKit.DivSeparator.DelimiterStyle.Orientation : Swift.Equatable {}
extension DivKit.DivSeparator.DelimiterStyle.Orientation : Swift.Hashable {}
extension DivKit.DivSeparator.DelimiterStyle.Orientation : Swift.RawRepresentable {}
extension DivKit.DivSeparator.DelimiterStyle.Orientation : Swift.BitwiseCopyable {}
extension DivKit.DivSizeUnit : Swift.Equatable {}
extension DivKit.DivSizeUnit : Swift.Hashable {}
extension DivKit.DivSizeUnit : Swift.RawRepresentable {}
extension DivKit.DivSizeUnit : Swift.BitwiseCopyable {}
extension DivKit.DivSlideTransition.Edge : Swift.Equatable {}
extension DivKit.DivSlideTransition.Edge : Swift.Hashable {}
extension DivKit.DivSlideTransition.Edge : Swift.RawRepresentable {}
extension DivKit.DivSlideTransition.Edge : Swift.BitwiseCopyable {}
extension DivKit.DivStateLifetime : Swift.Equatable {}
extension DivKit.DivStateLifetime : Swift.Hashable {}
extension DivKit.DivTabs.TabTitleStyle.AnimationType : Swift.Equatable {}
extension DivKit.DivTabs.TabTitleStyle.AnimationType : Swift.Hashable {}
extension DivKit.DivTabs.TabTitleStyle.AnimationType : Swift.RawRepresentable {}
extension DivKit.DivTabs.TabTitleStyle.AnimationType : Swift.BitwiseCopyable {}
extension DivKit.DivText.Truncate : Swift.Equatable {}
extension DivKit.DivText.Truncate : Swift.Hashable {}
extension DivKit.DivText.Truncate : Swift.RawRepresentable {}
extension DivKit.DivText.Truncate : Swift.BitwiseCopyable {}
extension DivKit.DivText.Image.IndexingDirection : Swift.Equatable {}
extension DivKit.DivText.Image.IndexingDirection : Swift.Hashable {}
extension DivKit.DivText.Image.IndexingDirection : Swift.RawRepresentable {}
extension DivKit.DivText.Image.IndexingDirection : Swift.BitwiseCopyable {}
extension DivKit.DivText.Image.Accessibility.Kind : Swift.Equatable {}
extension DivKit.DivText.Image.Accessibility.Kind : Swift.Hashable {}
extension DivKit.DivText.Image.Accessibility.Kind : Swift.RawRepresentable {}
extension DivKit.DivText.Image.Accessibility.Kind : Swift.BitwiseCopyable {}
extension DivKit.DivTextAlignmentVertical : Swift.Equatable {}
extension DivKit.DivTextAlignmentVertical : Swift.Hashable {}
extension DivKit.DivTextAlignmentVertical : Swift.RawRepresentable {}
extension DivKit.DivTextAlignmentVertical : Swift.BitwiseCopyable {}
extension DivKit.DivTimerAction : Swift.Equatable {}
extension DivKit.DivTimerAction : Swift.Hashable {}
extension DivKit.DivTooltip.Position : Swift.Equatable {}
extension DivKit.DivTooltip.Position : Swift.Hashable {}
extension DivKit.DivTooltip.Position : Swift.RawRepresentable {}
extension DivKit.DivTooltip.Position : Swift.BitwiseCopyable {}
extension DivKit.DivTransitionSelector : Swift.Equatable {}
extension DivKit.DivTransitionSelector : Swift.Hashable {}
extension DivKit.DivTransitionSelector : Swift.RawRepresentable {}
extension DivKit.DivTransitionSelector : Swift.BitwiseCopyable {}
extension DivKit.DivTransitionTrigger : Swift.Equatable {}
extension DivKit.DivTransitionTrigger : Swift.Hashable {}
extension DivKit.DivTransitionTrigger : Swift.RawRepresentable {}
extension DivKit.DivTransitionTrigger : Swift.BitwiseCopyable {}
extension DivKit.DivTrigger.Mode : Swift.Equatable {}
extension DivKit.DivTrigger.Mode : Swift.Hashable {}
extension DivKit.DivTrigger.Mode : Swift.RawRepresentable {}
extension DivKit.DivTrigger.Mode : Swift.BitwiseCopyable {}
extension DivKit.DivVariablesStorage.ChangeEvent.Kind : Swift.Sendable {}
extension DivKit.DivVideoScale : Swift.Equatable {}
extension DivKit.DivVideoScale : Swift.Hashable {}
extension DivKit.DivVideoScale : Swift.RawRepresentable {}
extension DivKit.DivVideoScale : Swift.BitwiseCopyable {}
extension DivKit.DivViewPreloader : Swift.Sendable {}
extension DivKit.DivVisibility : Swift.Equatable {}
extension DivKit.DivVisibility : Swift.Hashable {}
extension DivKit.DivVisibility : Swift.RawRepresentable {}
extension DivKit.DivVisibility : Swift.BitwiseCopyable {}
extension DivKit.DivVisibilityAction : DivKit.DivActionBase {}
extension DivKit.TimeMeasure.Status : Swift.Equatable {}
extension DivKit.TimeMeasure.Status : Swift.Hashable {}
extension DivKit.TimeMeasure.Status : Swift.RawRepresentable {}
